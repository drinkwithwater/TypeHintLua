
const AutoFlag = require "thlua.auto.AutoFlag"
const Reference = require "thlua.refer.Reference"
const AutoHolder = require "thlua.auto.AutoHolder"

const DotsTail = require "thlua.tuple.DotsTail"
const AutoTail = require "thlua.auto.AutoTail"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const AutoTuple = {}
AutoTuple.__index = AutoTuple

function:class(clazz.AutoTuple) AutoTuple.new(vManager:clazz.TypeManager, vNode:clazz.IAstNode, vParList:List(Union(clazz.AutoHolder, clazz.UAllType)), vDots:OrFalse(clazz.UAllType, clazz.AutoFlag))
	const self = setmetatable({.class
		_manager=vManager,
		_node=vNode,
		_parList=vParList,
		_dots=false@OrFalse(clazz.UAllType, clazz.AutoTail),
	}, AutoTuple)
	if vDots == AutoFlag then
		self._dots = AutoTail.new(vManager)
	else
		self._dots = vDots
	end
	return self
end

function AutoTuple:finishTypeTuple(vContext:clazz.Context):Ret(clazz.UTypeTuple)
	const nTypeList:List(clazz.UAllType) = {}
	for k,v in ipairs(self._parList) do
		if not AutoHolder.is(v) then
			nTypeList[k] = v
		else
			const nType = v:getType()
			if not nType then
				vContext:error("auto deduce failed")
				error("auto deduce failed")
			else
				nTypeList[k] = nType
			end
		end
	end
	const nDots = self._dots
	if AutoTail.is(nDots) then
		const nTailTuple = nDots:checkTypeTuple(vContext)
		if not nTailTuple then
			vContext:error("auto deduce failed for dots tail")
			error("auto deduce failed for dots tail")
		else
			for i=1,#nTailTuple do
				nTypeList[#nTypeList + 1] = nTailTuple:get(i)
			end
			const nFinalTuple = self._manager:TypeTuple(self._node, table.unpack(nTypeList))
			const nRepeatType = nTailTuple:getRepeatType()
			if nRepeatType then
				return nFinalTuple:Dots(nRepeatType)
			else
				return nFinalTuple
			end
		end
	else
		const nTuple = self._manager:TypeTuple(self._node, table.unpack(nTypeList))
		if not nDots then
			return nTuple
		else
			return nTuple:Dots(nDots)
		end
	end
end

function AutoTuple:makeTermTuple(vContext:clazz.Context):Ret(clazz.UTermTuple)
	const nTermList:List(clazz.UAutoTerm) = {}
	for k,v in ipairs(self._parList) do
		if not AutoHolder.is(v) then
			nTermList[k] = vContext:RefineTerm(v)
		else
			nTermList[k] = v
		end
	end
	const nDots = self._dots
	if not nDots or AutoTail.is(nDots) then
		return vContext:UTermTupleByTail(nTermList, nDots)
	else
		const nTail = DotsTail.new(vContext, nDots)
		return vContext:UTermTupleByTail(nTermList, nTail)
	end
end

function.open AutoTuple.is(t):isguard(clazz.AutoTuple)
	return getmetatable(t) == AutoTuple
end

return AutoTuple
