
const Reference = require "thlua.refer.Reference"
const LuaFunction = require "thlua.func.LuaFunction"
const TermCase = require "thlua.term.TermCase"

const Exception = require "thlua.Exception"
const OpenFnCom = require "thlua.func.OpenFnCom"
const LateFnCom = require "thlua.func.LateFnCom"
const FnHintCom = require "thlua.func.FnHintCom"
const ClassFactory = require "thlua.func.ClassFactory"
const MetaObject = require "thlua.object.MetaObject"

const FunctionBuilder = {}

(@let.class = import("thlua.type.TypeClass").class)

(@do

class.FnLongHint = Struct {
	RetClass=Fn(class.FnLongHint, class.Reference, OrNil(class.UAllType)):Ret(class.FnLongHint),
	Ret=Fn(class.FnLongHint):Dots(class.UAllType):Ret(class.FnLongHint),
	RetIs=Fn(class.FnLongHint, class.UAllType):Ret(class.FnLongHint),
}

end)

FunctionBuilder.__index=FunctionBuilder

function.class FunctionBuilder.new(vContext:class.Context,
	vNode:class.IAstNode,
	vFnNewInfo:class.FuncNewInfo
):RetClass(let.FunctionBuilder)
	const nManager = vContext:getTypeManager()
	const nLuaFunc = nManager:LuaFunction()
	const nHintCom = FnHintCom.new(nManager, nLuaFunc, vFnNewInfo)
	nLuaFunc:init(vContext, vNode, nHintCom, vFnNewInfo.genFunc)
	return setmetatable({.class
		_node=vNode,
		_context=vContext,
		_prefixHint=vFnNewInfo.prefixHint,
		_manager=nManager,
		_retTuples=false@Union(False, class.RetTuples),
		_hasRet=vFnNewInfo.hasRet,
		_luaFunc=nLuaFunc,
		_retMaker=vFnNewInfo.retMaker,
	}, FunctionBuilder)
end

function FunctionBuilder:_buildOpen():Ret(class.LuaFunction)
	const nSuffixHint = self._retMaker({})
	const nOpenCom = OpenFnCom.new(self._manager, self._luaFunc)
	local nSetReturn = false
	const ok, err = pcall(nSuffixHint.caller, {
		RetClass=function(vHint, _, _)
			return vHint
		end,
		Ret=function(vHint, ...)
			return vHint
		end,
		RetIs=function(vHint, vType)
			assert(not nSetReturn, "RetIs can only use once here")
			nOpenCom:initByGuard(self._context, vType)
			nSetReturn = true
			return vHint
		end,
	})
	if not nSetReturn then
		nOpenCom:initByOpen()
	end
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	return self._luaFunc
end

function FunctionBuilder:_buildClass():Ret(class.LuaFunction)
	const nSuffixHint = self._retMaker({})
	const nFactoryCom = ClassFactory.new(self._manager, self._luaFunc)
	const ok, err = pcall(nSuffixHint.caller, {
		RetClass=function(vHint, vRefer, vStruct)
			assert(vRefer and Reference.is(vRefer), Exception.new("RetClass's first arg must be a Reference"))
			vRefer:setRawAsync(self._node, function()
				local nImplType = vStruct
				if Reference.is(nImplType) then
					nImplType = nImplType:waitTypeCom():getTypeAwait()
					assert(not nImplType:isUnion(), "interface can't be union")
				end
				self._context:recordDefineLuaFunction(nFactoryCom)
				local nInterface = self._manager.type.Object
				if nImplType then
					assert(MetaObject.is(nImplType), "implement type must be MetaObject")
					nInterface = nImplType
				end
				const nTable = nFactoryCom:createLuaTable(self._context, vRefer, nInterface)
				return {nTable}
			end, function(vLuaTable)
				nFactoryCom:runBuild()
			end)
			nRefer = vRefer
			return vHint
		end,
		Ret=function(vHint, ...)
			return vHint
		end,
		RetIs=function(vHint, vType)
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	return self._luaFunc
end

function FunctionBuilder:_buildDefault(vPass:Boolean, vMember:Boolean):Ret(class.LuaFunction)
	const nSuffixHint = self._retMaker({})
	if vMember then
		self._luaFunc:setMember()
	end
	const ok, err = pcall(nSuffixHint.caller, {
		RetClass=function(vHint, _, _)
			error("RetClass can not be used here")
			return vHint
		end,
		Ret=function(vHint, ...:class.UAllType)
			local nRetTuples = self._retTuples
			if not nRetTuples then
				nRetTuples = self._manager:SingleRetTuples(self._manager:Tuple(...))
			else
				nRetTuples = self._manager:retConcat(self._node, nRetTuples, self._manager:Tuple(...))
			end
			self._retTuples = nRetTuples
			return vHint
		end,
		RetIs=function(vHint, vType)
			error("ret cannot used here")
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	local nRetTuples = self._retTuples
	if not self._hasRet then
		if not nRetTuples then
			nRetTuples = self._manager:VoidRetTuples()
		elseif not vPass then
			local hasVoid = false
			local hasSome = false
			nRetTuples:foreachWithFirst(function(vTypeTuple, _)
				if #vTypeTuple > 0 then
					hasSome = true
				else
					hasVoid = true
				end
			end)
			if hasSome and not hasVoid then
				self._context:getRuntime():nodeError(self._node, "hint return something but block has no RetStat")
			end
		end
	end
	const nLateFnCom = LateFnCom.new(self._manager, self._luaFunc)
	nLateFnCom:init(nRetTuples, vPass)
	self._context:recordLateLuaFunction(nLateFnCom)
	return self._luaFunc
end

function FunctionBuilder:build():Ret(class.LuaFunction)
	const nAttrSet = self._prefixHint.attrSet
	if nAttrSet.open then
		return self:_buildOpen()
	end
	if nAttrSet.class then
		return self:_buildClass()
	end
	return self:_buildDefault(nAttrSet.pass and true or false, nAttrSet.member and true or false)
end

return FunctionBuilder
