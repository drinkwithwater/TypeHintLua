
local Reference = require "thlua.type.Reference"
local LuaFunction = require "thlua.func.LuaFunction"
local Variable = require "thlua.func.Variable"
local TermCase = require "thlua.term.TermCase"

local OpenFnInfo = require "thlua.func.OpenFnInfo"
local NocheckFnInfo = require "thlua.func.NocheckFnInfo"
local NewFnInfo = require "thlua.func.NewFnInfo"

local FunctionBuilder = {}

(@var.class = import("thlua.type.TypeClass").class)

FunctionBuilder.__index=FunctionBuilder

function FunctionBuilder.new(vContext:class.Context,
	vNode:class.AstNode, vAutoArgs:class.AutoArguments, vRunFunc:class.GenFunc)::RetNew(class.FunctionBuilder)
	local nManager = vContext._manager
	local nLuaFunc = nManager:LuaFunction()
	nLuaFunc:init(vContext, vNode, vRunFunc)
	return setmetatable({::New()
		_context=vContext,
		_manager=nManager,
		_retTuples=false,
		_fnInfo=false,
		_runFunc=vRunFunc,
		_newTypeRefer=false,
		_newTypeImpl=false,
		_luaFunc=nLuaFunc,
		_autoArgs=vAutoArgs,
		_guardFunc=false,
		_tag=LuaFunction.DEFAULT,
	}, FunctionBuilder)
end

function FunctionBuilder.newLongHint(self)
	return {
		RetNew=function(vLongHint, vRefer, vStruct)
			--[[assert(not self._fnInfo, "function builder case conflict")
			vRefer:setTypeCtor(self._luaFunc)
			local nInfo = NewFnInfo.new(self._manager, self._luaFunc)
			self._fnInfo = nInfo
			nInfo:initByRetNew(vRefer, vStruct)
			return vLongHint]]
 			vRefer:setTypeCtor(self._luaFunc)
			self._tag = LuaFunction.DEFINE
			self._newTypeRefer = vRefer
			self._newTypeImpl = vStruct
			assert(not self._retTuples, "define function can't return other")
			self._retTuples = self._manager:EmptyRetTuples():Add(self._manager:Tuple(vRefer))
 			return vLongHint
		end,
		Ret=function(vLongHint, ...)
			local nRetTuples = self._retTuples
			if not nRetTuples then
				nRetTuples = self._manager:EmptyRetTuples()
			end
			self._retTuples = nRetTuples:Add(self._manager:Tuple(...))
			return vLongHint
		end,
		nocheck=function(vLongHint)
			assert(not self._fnInfo, "function builder case conflict")
			local nInfo = NocheckFnInfo.new(self._manager, self._luaFunc)
			self._fnInfo = nInfo
			return vLongHint
		end,
		open=function(vLongHint)
			assert(not self._fnInfo, "function builder case conflict")
			local nOpenInfo = OpenFnInfo.new(self._manager, self._luaFunc)
			nOpenInfo:initByOpen(self._runFunc)
			self._fnInfo = nOpenInfo
			return vLongHint
		end,
		isguard=function(vLongHint, vType)
			assert(not self._fnInfo, "function builder case conflict")
			local nOpenInfo = OpenFnInfo.new(self._manager, self._luaFunc)
			nOpenInfo:initByGuard(vType)
			self._fnInfo = nOpenInfo
			return vLongHint
		end,
	}
end

function FunctionBuilder:build()
	local nTag = self._tag
	if self._fnInfo then
		nTag = self._fnInfo.tag
	end
	if nTag == LuaFunction.NOCHECK then
		if not self._retTuples then
			error("nocheck-fn must set ret")
		end
		local nTypeFn = self._manager:Function(self._autoArgs:checkWhenNocheck(self._context), self._retTuples)
		self._fnInfo:setTypeFn(nTypeFn)
	elseif nTag == LuaFunction.DEFINE then
		self._luaFunc:setUnionFn({
			tag=nTag,
			fn=self._manager:Function(self._autoArgs:checkWhenNocheck(self._context), self._retTuples),
			retTuples=self._retTuples,
			autoArgs=self._autoArgs,
			runFunc=self._runFunc,
			newTypeRefer=self._newTypeRefer,
			newTypeImpl=self._newTypeImpl,
			once=false,
		})
		self._context:getRuntime():recordDefineLuaFunction(self._luaFunc)
	elseif nTag == LuaFunction.DEFAULT then
		local nRetTuples = self._retTuples
		self._luaFunc:setUnionFn({
			tag=nTag,
			fn=false,
			autoArgs=self._autoArgs,
			runFunc=self._runFunc,
			retTuples=nRetTuples,
			once=false,
		})
		if (not self._autoArgs:hasVariable()) then
			self._context:getRuntime():recordLateLuaFunction(self._luaFunc)
		end
	end
	return self._luaFunc
end


return FunctionBuilder
