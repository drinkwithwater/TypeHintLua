
local Reference = require "thlua.type.Reference"
local LuaFunction = require "thlua.func.LuaFunction"
local Variable = require "thlua.func.Variable"
local TermCase = require "thlua.term.TermCase"

local Exception = require "thlua.Exception"
local OpenFnCom = require "thlua.func.OpenFnCom"
local FixedRetFnCom = require "thlua.func.FixedRetFnCom"
local NewRetFnCom = require "thlua.func.NewRetFnCom"

local FunctionBuilder = {}

(@let.class = import("thlua.type.TypeClass").class)

FunctionBuilder.__index=FunctionBuilder

function FunctionBuilder.new(vContext:class.Context,
	vNode:class.AstNode, vAutoArgs:class.AutoArguments, vHasRet:Boolean, vRunFunc:class.GenFunc)::RetClass(class.FunctionBuilder)
	local nManager = vContext._manager
	local nLuaFunc = nManager:LuaFunction()
	nLuaFunc:init(vContext, vNode, vAutoArgs, vRunFunc)
	return setmetatable({::Self()
		_context=vContext,
		_manager=nManager,
		_retTuples=false,
		_nocheck=false,
		_fnCom=false,
		_hasRet=vHasRet,
		_luaFunc=nLuaFunc,
		_autoArgs=vAutoArgs,
	}, FunctionBuilder)
end

function FunctionBuilder.newLongHint(self)
	return {
		member=function(vLongHint)
			self._autoArgs:setSelf(self._context)
			return vLongHint
		end,
		RetClass=function(vLongHint, vRefer, vStruct)
			if not self._hasRet then
				self._context:error("hint return something but block has no RetStat")
			end
			assert(vRefer and Reference.is(vRefer), Exception.new("RetClass's first arg must be a Reference"))
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			assert(not self._retTuples, Exception.new("function builder case conflict"))
			local nCom = NewRetFnCom.new(self._manager, self._luaFunc)
			vRefer:setTypeCtor(nCom)
			self._fnCom = nCom
			nCom:initByRetClass(self._context, true, vRefer, vStruct)
			return vLongHint
		end,
		Ret=function(vLongHint, ...)
			if not self._hasRet and select("#", ...) > 0 then
				self._context:error("hint return something but block has no RetStat")
			end
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			local nRetTuples = self._retTuples
			if not nRetTuples then
				nRetTuples = self._manager:SingleRetTuples(self._manager:Tuple(...))
			else
				nRetTuples = nRetTuples:Add(self._manager:Tuple(...))
			end
			self._retTuples = nRetTuples
			return vLongHint
		end,
		nocheck=function(vLongHint)
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			self._nocheck=true
			return vLongHint
		end,
		open=function(vLongHint)
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			assert(not self._retTuples, Exception.new("function builder case conflict"))
			local nOpenCom = OpenFnCom.new(self._manager, self._luaFunc)
			nOpenCom:initByOpen(self._context)
			self._fnCom = nOpenCom
			return vLongHint
		end,
		isguard=function(vLongHint, vType)
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			local nOpenCom = OpenFnCom.new(self._manager, self._luaFunc)
			nOpenCom:initByGuard(self._context, vType)
			self._fnCom = nOpenCom
			return vLongHint
		end,
	}
end

function FunctionBuilder:build()
	local nFnCom = self._fnCom
	if not nFnCom then
		local nRetTuples = self._retTuples
		if not self._hasRet then
			nRetTuples = self._manager:VoidRetTuples()
		end
		nFnCom = FixedRetFnCom.new(self._manager, self._luaFunc)
		nFnCom:init(self._context, nRetTuples, self._nocheck)
		self._context:getRuntime():recordLateLuaFunction(nFnCom)
	else
		local nTag = nFnCom.tag
		if nTag == LuaFunction.NEW_RET then
			self._context:getRuntime():recordDefineLuaFunction(nFnCom)
		elseif nTag == LuaFunction.OPEN then
			-- pass
		else
			error("invalid tag:"..tostring(nTag))
		end
	end
	return self._luaFunc
end


return FunctionBuilder
