
const Reference = require "thlua.refer.Reference"
const Exception = require "thlua.Exception"
const Enum = require "thlua.Enum"
const MetaObject = require "thlua.object.MetaObject"

const LateFnCom = require "thlua.func.LateFnCom"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node

	clazz.UDefaultFunction = Union(clazz.TypeFunction, clazz.PolyFunction, clazz.MemberFunction)

	clazz.FnPrefixHint = Struct {
		class=Fn(clazz.FnPrefixHint, Any):Ret(clazz.FnPrefixHint),
	}

	clazz.FnSuffixHint = Struct {
		impl=Fn(clazz.FnSuffixHint, clazz.UAllType):Ret(clazz.FnSuffixHint),
		Ret=Fn(clazz.FnSuffixHint):Dots(clazz.UAllType):Ret(clazz.FnSuffixHint),
		isguard=Fn(clazz.FnSuffixHint, clazz.UAllType):Ret(clazz.FnSuffixHint),
	}

	clazz.FuncNewInfo = Struct ({
		_prefixHint=clazz.TLongHintInfo(clazz.FnPrefixHint),
		_parNum=Integer,
		_isvararg=Boolean,
		_hasRet=Boolean,
		_polyParNum=OrFalse(Integer), -- if not full hint, _polyParNum is false
		_parMaker=Fn(List(clazz.UAllType), OrFalse(clazz.UAllType)):Ret(List(OrFalse(clazz.UAllType)), OrFalse(clazz.UAllType)),
		_retMaker=Fn(List(clazz.UAllType), OrFalse(clazz.UAllType)):Ret(clazz.TLongHintInfo(clazz.FnSuffixHint)),
		_genFunc=clazz.GenFunc,
	}, {
		__next=KeyOf(clazz.FuncNewInfo)
	})
end)

const FunctionBuilder = {}
FunctionBuilder.__index=FunctionBuilder

function:class(clazz.FunctionBuilder) FunctionBuilder.new(
	vManager:clazz.TypeManager,
	vContext:clazz.Context,
	vNode:clazz.IAstNode,
	vInfo:clazz.FuncNewInfo
)
	const self = {.class
		_manager=vManager,
		_context=vContext,
		_node=vNode,
		_member=false@Boolean,
		_luaFunc=vManager:LuaFunction(),
		_pass=vInfo._prefixHint.attrSet.pass and true or false,
	}
	for k,v in pairs(vInfo) do
		self[k] = v
	end
	setmetatable(self, FunctionBuilder)
	return self
end

function FunctionBuilder:error(...:Truth)
	if not self._pass then
		self._context:getRuntime():nodeError(self._node, ...)
	end
end

function FunctionBuilder:checkWhenCast(vContext:clazz.Context, vCastTypeFn:clazz.TypeFunction):Ret(clazz.TypeFunction)
	-- 1. check par
	const nParTuple = self:_makeParTupleByCast(vContext, vCastTypeFn:getParTuple())
	-- 2. check ret
	const nHintRetTuples = self:_makeRetTuples(vContext, {}, false)
	const nCastRetTuples = vCastTypeFn:getRetTuples()
	if nHintRetTuples then
		if not nCastRetTuples:containTuples(nHintRetTuples) then
			self:error("interface-fn ret and hint ret notmatch")
		end
		return self._manager:Function(nParTuple, nHintRetTuples)
	else
		return self._manager:Function(nParTuple, nCastRetTuples)
	end
end

function FunctionBuilder:_makeRetTuples(
	vContext:clazz.Context,
	vTypeList:List(clazz.UAllType),
	vSelfType:OrFalse(clazz.UAllType)
):Ret(OrFalse(clazz.RetTuples))
	const nSuffixHint = self._retMaker(vTypeList, vSelfType)
	local nRetTuples:OrFalse(clazz.RetTuples) = false
	const ok, err = pcall(nSuffixHint.caller, {
		impl=function(vHint, _)
			error("impl can only be used with function:class")
			return vHint
		end,
		Ret=function(vHint, ...:clazz.UAllType)
			if not nRetTuples then
				nRetTuples = self._manager:SingleRetTuples(self._manager:Tuple(...))
			else
				nRetTuples = self._manager:retConcat(self._node, nRetTuples, self._manager:Tuple(...))
			end
			return vHint
		end,
		isguard=function(vHint, vType)
			error("isguard can only be used with function.open")
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	if not self._hasRet then
		if nRetTuples and not self._pass then
			local hasVoid = false
			local hasSome = false
			nRetTuples:foreachWithFirst(function(vTypeTuple, _)
				if #vTypeTuple > 0 then
					hasSome = true
				else
					hasVoid = true
				end
			end)
			if hasSome and not hasVoid then
				self:error("hint return something but block has no RetStat")
			end
		end
	end
	return nRetTuples
end

function FunctionBuilder:_makeParTupleByCast(vContext:clazz.Context, vTypeTuple:clazz.UTypeTuple):Ret(clazz.UTypeTuple)
	const nParList, nDotsType = self._parMaker({}, false)
	local nNewList:List(clazz.UAllType) = {}
	if #vTypeTuple ~= self._parNum then
		self:error("arguments num not match when specification")
	end
	for i, nPar in ipairs(nParList) do
		local nInputType = vTypeTuple:get(i)
		if not nPar then
			nNewList[i] = nInputType
		else
			nNewList[i] = nPar
			if not nPar:containAll(nInputType) then
				self:error("arguments type not match when checkout")
			end
		end
	end
	local nTuple = self._manager:Tuple(table.unpack(nNewList))
	const nRepeatType = vTypeTuple:getRepeatType()
	if self._isvararg then
		if not nRepeatType then
			self:error("arguments type not match for not dots")
		end
		if not nDotsType then
			return nTuple:Dots(nRepeatType or self._manager.type.Truth)
		else
			if nRepeatType and not nDotsType:containAll(nRepeatType) then
				self:error("arguments type not match for wrong dots")
			end
			return nTuple:Dots(nDotsType)
		end
	else
		if nRepeatType then
			self:error("arguments type not match for dots")
		end
		return nTuple
	end
end

function FunctionBuilder:_checkParTupleByDefault():Ret(clazz.UTypeTuple)
	const nParList, nDotsType = self._parMaker({}, false)
	for i, nParType in ipairs(nParList) do
		if not nParType then
			error("param type is required here, order="..tostring(i))
		end
	end
	local nTuple = self._manager:Tuple(table.unpack(nParList @ List(clazz.UAllType)))
	if self._isvararg then
		if not nDotsType then
			error("dots type is required here")
		end
		return nTuple:Dots(nDotsType)
	else
		return nTuple
	end
end

function FunctionBuilder:_makeParTuple(vContext:clazz.Context, vTypeList:List(clazz.UAllType)):Ret(clazz.UTypeTuple)
	const nParList, nDotsType = self._parMaker(vTypeList, false)
	for i, nParType in ipairs(nParList) do
		if not nParType then
			error("param type is required here, order="..tostring(i))
		end
	end
	local nTuple = self._manager:Tuple(table.unpack(nParList @ List(clazz.UAllType)))
	if self._isvararg then
		if not nDotsType then
			error("dots type is required here")
		end
		return nTuple:Dots(nDotsType)
	else
		return nTuple
	end
end

function FunctionBuilder:checkWhenTemplate(vContext:clazz.Context, vTypeList:List(clazz.UAllType)):Ret(clazz.TypeFunction)
	const nParTuple = self:_makeParTuple(vContext, vTypeList)
	const nRetTuples = self:_makeRetTuples(vContext, vTypeList, false) or self._manager:VoidRetTuples()
	return self._manager:Function(nParTuple, nRetTuples)
end

function FunctionBuilder:_checkWhenDefault():Ret(OrFalse(clazz.UDefaultFunction))
	const nPolyParNum = self._polyParNum
	if not nPolyParNum then
		return false
	end
	const nFnMaker = function(vPolyParList:List(clazz.UAllType), vSelfType:OrFalse(clazz.UAllType)):Ret(clazz.TypeFunction)
		const nNewParList:List(clazz.UAllType) = {}
		const nParList, nDotsType = self._parMaker(vPolyParList, vSelfType)
		for i, nParType in ipairs(nParList) do
			if not nParType then
				if i == 1 then
					nNewParList[1] = self._manager.type.Truth
					assert(self._member, "only trait function's self can be default to Truth")
				else
					error("check default but hint type is not true value, order="..tostring(i))
				end
			else
				nNewParList[i] = nParType
			end
		end
		const nRawTuple = self._manager:Tuple(table.unpack(nNewParList))
		local nParTuple:clazz.UTypeTuple = nRawTuple
		if self._isvararg then
			if not nDotsType then
				error("dots type is required here")
			end
			nParTuple = nRawTuple:Dots(nDotsType)
		end
		const nRetTuples = self:_makeRetTuples(self._context, vPolyParList, vSelfType) or self._manager:VoidRetTuples()
		return self._manager:Function(nParTuple, nRetTuples)
	end
	if not self._member then
		if nPolyParNum <= 0 then
			return nFnMaker({}, false)
		else
			return self._manager:PolyFunction(self._node, function(...)
				return nFnMaker({...}, false)
			end, nPolyParNum)
		end
	else
		const nPolyFn = self._manager:PolyFunction(self._node, function(self, ...)
			return nFnMaker({...}, self)
		end, nPolyParNum + 1)
		return self._manager:MemberFunction(self._node, nPolyFn)
	end
end

function FunctionBuilder:isFullHint():Ret(Boolean)
	return self._polyParNum and true
end

function FunctionBuilder:_buildOpen():Ret(clazz.OpenFunction)
	const nSuffixHint = self._retMaker({}, false)
	local nOpenFn:OrFalse(clazz.OpenFunction) = false
	const ok, err = pcall(nSuffixHint.caller, {
		impl=function(vHint, _)
			return vHint
		end,
		Ret=function(vHint, ...)
			return vHint
		end,
		isguard=function(vHint, vType)
			assert(not nOpenFn, "isguard can only use once here")
			nOpenFn = self._manager:OpenFunction():lateInitFromGuard(vType)
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	return nOpenFn or self._manager:OpenFunction():lateInitFromGenFunc(self._genFunc)
end

function FunctionBuilder:_buildClass():Ret(clazz.TypeFunction)
	const nPrefixHint = self._prefixHint
	local nReferOrNil:OrNil(clazz.Reference) = nil
	const ok, err = pcall(nPrefixHint.caller, {
		class=function(vHint, vRefer)
			assert(vRefer and Reference.is(vRefer), Exception.new("impl's first arg must be a Reference"))
			nReferOrNil = vRefer
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	const nSuffixHint = self._retMaker({}, false)
	local nStruct:OrNil(clazz.UAllType) = nil
	const ok, err = pcall(nSuffixHint.caller, {
		impl=function(vHint, vStruct)
			nStruct = vStruct
			return vHint
		end,
		Ret=function(vHint, ...)
			error("TODO : clazz use Ret not impl")
			return vHint
		end,
		isguard=function(vHint, vType)
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	const nRefer = assert(nReferOrNil, "reference not setted when function:class")
	const nParTuple = self:_checkParTupleByDefault()
	const nRetTuples = self._manager:SingleRetTuples(self._manager:Tuple(nRefer))
	const nTypeFn = self._manager:Function(nParTuple, nRetTuples)
	nRefer:setClassAsync(self._node, function()
		local nImplType = nStruct
		if Reference.is(nImplType) then
			nImplType = nImplType:waitTypeCom():getTypeAwait()
			assert(not nImplType:isUnion(), "interface can't be union")
		end
		local nInterface = self._manager.type.AnyObject
		if nImplType then
			assert(MetaObject.is(nImplType), "implement type must be MetaObject")
			nInterface = nImplType
		end
		return nInterface
	end, self._context, function(vLuaTable)
		const nContext = self._context:newSealContext(self._node)
		nContext:setClassTable(vLuaTable)
		self._genFunc(nTypeFn, nContext, nParTuple:makeTermTuple(), {}, false)
	end)
	return nTypeFn
end

function FunctionBuilder:build():Ret(clazz.LuaFunction)
	const nAttrSet = self._prefixHint.attrSet
	if nAttrSet.open then
		self._luaFunc:lateInit(self._context, self._node, self, false, self:_buildOpen())
	elseif nAttrSet.class then
		self._luaFunc:lateInit(self._context, self._node, self, false, self:_buildClass())
	else
		if nAttrSet.member then
			self._luaFunc:setMember()
			self._member = true
		end
		local nDefaultFn:OrFalse(clazz.UDefaultFunction) = self:_checkWhenDefault()
		const nLateFnCom = LateFnCom.new(self._manager, self._luaFunc, nDefaultFn, nAttrSet.pass and true or false)
		self._context:recordLateLuaFunction(nLateFnCom)
		self._luaFunc:lateInit(self._context, self._node, self, nLateFnCom, nDefaultFn)
	end
	return self._luaFunc
end

function FunctionBuilder:getGenFunc():Ret(clazz.GenFunc)
	return self._genFunc
end

return FunctionBuilder
