
const AutoFlag = require "thlua.auto.AutoFlag"
const AutoFunction = require "thlua.refer.AutoFunction"
const Reference = require "thlua.refer.Reference"
const Exception = require "thlua.Exception"
const Enum = require "thlua.Enum"
const MetaObject = require "thlua.object.MetaObject"
const AutoTuple = require "thlua.auto.AutoTuple"
const AutoHolder = require "thlua.auto.AutoHolder"
const ClassFactory = require "thlua.refer.ClassFactory"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node

	clazz.AutoFlag = $AutoFlag
	clazz.ULuaInnerFn = Union(clazz.ClassFactory, clazz.AutoFunction, clazz.OpenFunction, clazz.PolyFunction, clazz.MemberFunction)

	clazz.FnPrefixHint = Struct {
		class=Fn(clazz.FnPrefixHint, Any):Ret(clazz.FnPrefixHint),
	}

	clazz.FnSuffixHint = Struct {
		impl=Fn(clazz.FnSuffixHint, clazz.UAllType):Ret(clazz.FnSuffixHint),
		Ret=Fn(clazz.FnSuffixHint):Dots(clazz.UAllType):Ret(clazz.FnSuffixHint),
		RetDots=Fn(clazz.FnSuffixHint, clazz.UAllType):Dots(clazz.UAllType):Ret(clazz.FnSuffixHint),
		isguard=Fn(clazz.FnSuffixHint, clazz.UAllType):Ret(clazz.FnSuffixHint),
	}

	clazz.ParHintStruct = Struct ({
		[Integer]=Union(clazz.AutoFlag, clazz.UAllType),
		dots=OrNil(Union(clazz.AutoFlag, clazz.UAllType)),
	}, {
		__next=Integer,
		__len=Integer,
	})

	clazz.FuncNewInfo = Struct ({
		_prefixHint=clazz.TLongHintInfo(clazz.FnPrefixHint),
		_isvararg=Boolean,
		_hasRetSome=Boolean,
		_hasSuffixHint=Boolean,
		_polyParNum=Integer,
		_parNum=Integer,
		_parFullHint=Boolean,
		_member=Boolean,
	}, {
		__next=KeyOf(clazz.FuncNewInfo)
	})
end)

const FunctionBuilder = {}
FunctionBuilder.__index=FunctionBuilder

function:class(clazz.FunctionBuilder) FunctionBuilder.new(
	vManager:clazz.TypeManager,
	vContext:clazz.Context,
	vNode:clazz.IAstNode,
	vUpValueCase:OrFalse(clazz.VariableCase),
	vInfo:clazz.FuncNewInfo,
	vParRetMaker:Fn(OrFalse(clazz.VariableCase), clazz.Context, List(clazz.UAllType), Union(clazz.AutoFlag, clazz.UAllType)):Ret(clazz.ParHintStruct, clazz.TLongHintInfo(clazz.FnSuffixHint), clazz.GenFunc)
)
	const self = {.class
		_manager=vManager,
		_context=vContext,
		_node=vNode,
		_uvCase=vUpValueCase,
		_pass=vInfo._prefixHint.attrSet.pass and true or false,
		_parRetMaker=vParRetMaker,
	}
	for k,v in pairs(vInfo) do
		self[k] = v
	end
	setmetatable(self, FunctionBuilder)
	return self
end

function FunctionBuilder:error(...:Truth)
	if not self._pass then
		self._context:getRuntime():nodeError(self._node, ...)
	end
end

function FunctionBuilder:checkWhenCast(vContext:clazz.Context, vCastTypeFn:clazz.TypeFunction)
	const nAutoFn = self._manager:Reference(false):setAutoFunction(self._node, function()
		-- 1. check par
		const nNewContext, nParTuple, nSuffixHint, nGenFunc = self:_makeParTupleByCast(self._context, vCastTypeFn:getParTuple())
		-- 2. check ret
		const nHintRetTuples = self:_makeRetTuples(nSuffixHint, {}, false)
		local nFinalRetTuples = vCastTypeFn:getRetTuples()
		if nHintRetTuples then
			if not nFinalRetTuples:containTuples(nHintRetTuples) then
				self:error("interface-fn ret and hint ret notmatch")
			end
			nFinalRetTuples = nHintRetTuples
		end
		const nTypeFn = self._manager:TypeFunction(self._node, nParTuple, nFinalRetTuples)
		return nTypeFn, function(vAutoFn)
			if not self._pass then
				nGenFunc(vAutoFn, nParTuple:makeTermTuple(nNewContext), false)
			end
			return false
		end
	end)
	self._context:recordAutoFunction(nAutoFn)
end

function FunctionBuilder:_makeRetTuples(
	vSuffixHint:clazz.TLongHintInfo(clazz.FnSuffixHint),
	vTypeList:List(clazz.UAllType),
	vSelfType:OrFalse(clazz.UAllType)
):Ret(OrFalse(clazz.RetTuples))
	local nFakeFn:OrFalse(clazz.TypeFunction) = false
	const ok, err = pcall(vSuffixHint.caller, {
		impl=function(vHint, _)
			error("impl can only be used with function:class")
			return vHint
		end,
		RetDots=function(vHint, vFirst, ...)
			const nFn = nFakeFn or self._manager:buildFn(self._node)
			nFn:RetDots(vFirst, ...)
			nFakeFn = nFn
			return vHint
		end,
		Ret=function(vHint, ...)
			const nFn = nFakeFn or self._manager:buildFn(self._node)
			nFn:Ret(...)
			nFakeFn = nFn
			return vHint
		end,
		isguard=function(vHint, vType)
			error("isguard can only be used with function.open")
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	const nRetTuples = nFakeFn and nFakeFn:getRetTuples()
	if not self._hasRetSome then
		if nRetTuples and not self._pass then
			local hasVoid = false
			local hasSome = false
			nRetTuples:foreachWithFirst(function(vTypeTuple, _)
				if #vTypeTuple > 0 then
					hasSome = true
				else
					hasVoid = true
				end
			end)
			if hasSome and not hasVoid then
				self:error("hint return something but block has no RetStat")
			end
		end
	end
	return nRetTuples
end

function FunctionBuilder:_makeParTupleByCast(vContext:clazz.Context, vTypeTuple:clazz.UTypeTuple):Ret(clazz.Context, clazz.UTypeTuple, clazz.TLongHintInfo(clazz.FnSuffixHint), clazz.GenFunc)
	const nNewContext = vContext:newSealContext(self._node)
	const nParHintStruct, nSuffixHint, nGenFunc = self._parRetMaker(self._uvCase, nNewContext, {}, AutoFlag)
	local nNewList:List(clazz.UAllType) = {}
	if #vTypeTuple ~= self._parNum then
		self:error("arguments num not match when specification")
	end
	for i, nPar in ipairs(nParHintStruct) do
		local nInputType = vTypeTuple:get(i)
		if nPar == AutoFlag then
			nNewList[i] = nInputType
		else
			nNewList[i] = nPar
			if not nPar:containAll(nInputType) then
				self:error("arguments type not match when checkout")
			end
		end
	end
	local nTuple = self._manager:TypeTuple(self._node, table.unpack(nNewList))
	const nRepeatType = vTypeTuple:getRepeatType()
	const nDots = nParHintStruct.dots
	if nDots then
		if not nRepeatType then
			self:error("arguments type not match for not dots")
		end
		if nDots == AutoFlag then
			return nNewContext, nTuple:Dots(nRepeatType or self._manager.type.Truth), nSuffixHint, nGenFunc
		else
			if nRepeatType and not nDots:containAll(nRepeatType) then
				self:error("arguments type not match for wrong dots")
			end
			return nNewContext, nTuple:Dots(nDots), nSuffixHint, nGenFunc
		end
	else
		if nRepeatType then
			self:error("arguments type not match for dots")
		end
		return nNewContext, nTuple, nSuffixHint, nGenFunc
	end
end

function FunctionBuilder:_makeParTupleByPoly(
	vPolyParList:List(clazz.UAllType),
	vSelfType:OrFalse(clazz.UAllType)
):Ret(clazz.Context, Union(clazz.AutoTuple, clazz.UTypeTuple), clazz.TLongHintInfo(clazz.FnSuffixHint), clazz.GenFunc)
	const nNewContext = self._context:newSealContext(self._node)
	const nParList:List(Union(clazz.UAllType, clazz.AutoHolder)) = {}
	const nParHintStruct, nSuffixHint, nGenFunc = self._parRetMaker(self._uvCase, nNewContext, vPolyParList, vSelfType or AutoFlag)
	local nHasAuto = false
	for i, nParType in ipairs(nParHintStruct) do
		if nParType == AutoFlag then
			nHasAuto = true
			nParList[i] = AutoHolder.new()
		else
			nParList[i] = nParType
		end
	end
	const nDots = nParHintStruct.dots
	nHasAuto = nHasAuto or nDots == AutoFlag
	if nHasAuto then
		return nNewContext, AutoTuple.new(self._manager, self._node, nParList, nDots or false), nSuffixHint, nGenFunc
	else
		const nTuple = self._manager:TypeTuple(self._node, table.unpack(nParList))
		if nDots then
			return nNewContext, nTuple:Dots(nDots), nSuffixHint, nGenFunc
		else
			return nNewContext, nTuple, nSuffixHint, nGenFunc
		end
	end
end

function FunctionBuilder:_buildInnerFn():Ret(OrFalse(clazz.AutoFunction, clazz.MemberFunction, clazz.PolyFunction))
	const nPolyParNum = self._polyParNum
	if not self._parFullHint and self._pass then
		return false
	end
	if self._hasRetSome and not self._hasSuffixHint then
		-- return not full hint
		return false
	end
	const nFnMaker = function(vPolyParList:List(clazz.UAllType), vSelfType:OrFalse(clazz.UAllType)):Ret(clazz.AutoFunction)
		const nAutoFn = self._manager:Reference(false):setAutoFunction(self._node, function()
			const nNewContext, nParTuple, nSuffixHint, nGenFunc = self:_makeParTupleByPoly(vPolyParList, vSelfType)
			const nRetTuples = self:_makeRetTuples(nSuffixHint, vPolyParList, vSelfType) or self._manager:VoidRetTuples()
			const nIsAuto = AutoTuple.is(nParTuple)
			const nPreTypeFn = (not nIsAuto) and self._manager:TypeFunction(self._node, nParTuple, nRetTuples) or false
			return nPreTypeFn, function(vAutoFn)
				if not self._pass then
					nGenFunc(vAutoFn, nParTuple:makeTermTuple(nNewContext), false)
				end
				if nIsAuto then
					const nTypeTuple = nParTuple:finishTypeTuple(nNewContext)
					return self._manager:TypeFunction(self._node, nTypeTuple, nRetTuples)
				else
					return false
				end
			end
		end)
		if self._parFullHint then
			self._context:recordAutoFunction(nAutoFn)
		else
			if self._pass then
				error("pass function must be full hint")
			end
		end
		return nAutoFn
	end
	if not self._member then
		if nPolyParNum <= 0 then
			return nFnMaker({}, false)
		else
			return self._manager:PolyFunction(self._node, function(...)
				return nFnMaker({...}, false)
			end, nPolyParNum)
		end
	else
		const nPolyFn = self._manager:PolyFunction(self._node, function(self, ...)
			return nFnMaker({...}, self)
		end, nPolyParNum + 1)
		return self._manager:MemberFunction(self._node, nPolyFn)
	end
end

function FunctionBuilder:_buildOpen():Ret(clazz.OpenFunction)
	const nMakerContext = self._context:newOpenContext(self._node)
	if self._hasSuffixHint then
		const nParHintStruct, nSuffixHint, nGenFunc = self._parRetMaker(self._uvCase, nMakerContext, {}, AutoFlag)
		local nGuardFn:OrFalse(clazz.OpenFunction) = false
		const ok, err = pcall(nSuffixHint.caller, {
			impl=function(vHint, _)
				return vHint
			end,
			RetDots=function(vHint, vFirst, ...)
				error("open table can't take RetDots")
				return vHint
			end,
			Ret=function(vHint, ...)
				error("open table can't take Ret")
				return vHint
			end,
			isguard=function(vHint, vType)
				assert(not nGuardFn, "isguard can only use once here")
				nGuardFn = self._manager:OpenFunction():lateInitFromGuard(vType)
				return vHint
			end,
		})
		if not ok then
			error(Exception.new(tostring(err), self._node))
		end
		return (assert(nGuardFn, "open function with suffix hint only can be guard function"..tostring(self._node)))
	else
		return self._manager:OpenFunction():lateInitFromBuilder(function(vOpenFn, vContext, vTermTuple)
			const nParHintStruct, nSuffixHint, nGenFunc = self._parRetMaker(self._uvCase, vContext, {}, AutoFlag)
			return nGenFunc(vOpenFn, vTermTuple, nParHintStruct)
		end)
	end
end

function FunctionBuilder:_buildClass():Ret(Union(clazz.ClassFactory, clazz.PolyFunction))
	const nPrefixHint = self._prefixHint
	local nReferOrNil:OrNil(clazz.Reference) = nil
	const ok, err = pcall(nPrefixHint.caller, {
		class=function(vHint, vRefer)
			assert(vRefer and Reference.is(vRefer), Exception.new("impl's first arg must be a Reference"))
			nReferOrNil = vRefer
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	const nRefer = assert(nReferOrNil, "reference not setted when function:class")
	const nPolyParNum = self._polyParNum
	const nFnMaker = function(vPolyParList:List(clazz.UAllType)):Ret(clazz.ClassFactory)
		const nClassRefer = self._manager:Reference(false)
		const nInterfaceGetter = function(vSuffixHint:clazz.TLongHintInfo(clazz.FnSuffixHint)):Ret(clazz.MetaObject)
			local nStruct:OrNil(clazz.UAllType) = nil
			const ok, err = pcall(vSuffixHint.caller, {
				impl=function(vHint, vStruct)
					nStruct = vStruct
					return vHint
				end,
				Ret=function(vHint, ...)
					error("class function can't take Ret")
					return vHint
				end,
				RetDots=function(vHint, vFirst, ...)
					error("class function can't take Ret")
					return vHint
				end,
				isguard=function(vHint, vType)
					return vHint
				end,
			})
			if not ok then
				error(Exception.new(tostring(err), self._node))
			end
			local nImplType = nStruct
			if Reference.is(nImplType) then
				nImplType = nImplType:waitTypeCom():getTypeAwait()
				assert(not nImplType:isUnion(), "interface can't be union")
			end
			local nInterface = self._manager.type.AnyObject
			if nImplType then
				assert(MetaObject.is(nImplType), "implement type must be MetaObject")
				nInterface = nImplType
			end
			return nInterface
		end
		const nFactory = nClassRefer:setClassFactory(self._node, function()
			const nNewContext, nParTuple, nSuffixHint, nGenFunc = self:_makeParTupleByPoly(vPolyParList, false)
			const nRetTuples = self._manager:SingleRetTuples(self._manager:TypeTuple(self._node, nClassRefer))
			const nIsAuto = AutoTuple.is(nParTuple)
			const nPreTypeFn = (not nIsAuto) and self._manager:TypeFunction(self._node, nParTuple, nRetTuples) or false
			return nInterfaceGetter(nSuffixHint), nPreTypeFn, function(vFactory, vLuaTable)
				nNewContext:setClassTable(vLuaTable)
				nGenFunc(vFactory, nParTuple:makeTermTuple(nNewContext), false)
				if nIsAuto then
					return self._manager:TypeFunction(self._node, nParTuple:finishTypeTuple(nNewContext), nRetTuples)
				else
					return false
				end
			end
		end)
		self._context:recordClassFactory(nFactory)
		return nFactory
	end
	if nPolyParNum <= 0 then
		const nFactory = nFnMaker({})
		nRefer:setAssignAsync(self._node, function()
			return nFactory:getTypeAwait()
		end)
		return nFactory
	else
		const nPolyFn = self._manager:PolyFunction(self._node, function(...)
			return nFnMaker({...}, false)
		end, nPolyParNum)
		nRefer:setTemplateAsync(self._node, function(...)
			const nFactory = nPolyFn:noCtxCastPoly({...})
			assert(ClassFactory.is(nFactory), "class factory's poly must return factory type")
			return nFactory:getTypeAwait()
		end, nPolyParNum)
		return nPolyFn
	end
end

function FunctionBuilder:build():Ret(clazz.LuaFunction)
	const nLuaFunc = self._manager:LuaFunction()
	const nAttrSet = self._prefixHint.attrSet
	if nAttrSet.open then
		nLuaFunc:lateInit(self._node, self, self:_buildOpen())
	elseif nAttrSet.class then
		if self._member then
			error(Exception.new("class factory can't be member-function-like", self._node))
		end
		nLuaFunc:lateInit(self._node, self, self:_buildClass())
	else
		if self._member then
			nLuaFunc:setMember()
		end
		nLuaFunc:lateInit(self._node, self, self:_buildInnerFn())
	end
	return nLuaFunc
end

return FunctionBuilder
