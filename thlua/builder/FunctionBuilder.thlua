
const Reference = require "thlua.refer.Reference"
const LuaFunction = require "thlua.func.LuaFunction"
const Variable = require "thlua.func.Variable"
const TermCase = require "thlua.term.TermCase"

const Exception = require "thlua.Exception"
const OpenFnCom = require "thlua.func.OpenFnCom"
const LateFnCom = require "thlua.func.LateFnCom"
const ClassFactory = require "thlua.func.ClassFactory"
const MetaObject = require "thlua.object.MetaObject"

const FunctionBuilder = {}

(@let.class = import("thlua.type.TypeClass").class)

(@do

class.FnLongHint = Struct {
	RetClass=Fn(class.FnLongHint, class.Reference, OrNil(class.UAllType)):Ret(class.FnLongHint),
	Ret=Fn(class.FnLongHint):Dots(class.UAllType):Ret(class.FnLongHint),
	isguard=Fn(class.FnLongHint, class.UAllType):Ret(class.FnLongHint),
}

end)

FunctionBuilder.__index=FunctionBuilder

function.class FunctionBuilder.new(vContext:class.Context,
	vNode:class.IAstNode,
	vPrefixHint:class.TLongHintInfo(Nil),
	vAutoArgs:class.AutoArguments,
	vSuffixHint:class.TLongHintInfo(class.FnLongHint),
	vHasRet:Boolean,
	vRunFunc:class.GenFunc
):RetClass(let.FunctionBuilder)
	const nManager = vContext:getTypeManager()
	const nLuaFunc = nManager:LuaFunction()
	nLuaFunc:init(vContext, vNode, vAutoArgs, vRunFunc)
	return setmetatable({.class
		_node=vNode,
		_context=vContext,
		_prefixHint=vPrefixHint,
		_suffixHint=vSuffixHint,
		_manager=nManager,
		_retTuples=false@Union(False, class.RetTuples),
		_pass=false@Boolean,
		_fnCom=false@Union(False, class.UFnCom),
		_hasRet=vHasRet,
		_luaFunc=nLuaFunc,
		_autoArgs=vAutoArgs,
	}, FunctionBuilder)
end

function FunctionBuilder.makeLongHint(self:let.FunctionBuilder):Ret(class.FnLongHint)
	return {
		--[[member=function(vLongHint:class.FnLongHint):Ret(class.FnLongHint)
			self._autoArgs:setSelf(self._context)
			return vLongHint
		end,]]
		RetClass=function(vLongHint:class.FnLongHint, vRefer:class.Reference, vStruct:OrNil(class.UAllType)):Ret(class.FnLongHint)
			error("TODO")
			if not self._hasRet then
				self._context:getRuntime():nodeError(self._node, "hint return class but block has no RetStat")
			end
			assert(vRefer and Reference.is(vRefer), Exception.new("RetClass's first arg must be a Reference"))
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			assert(not self._retTuples, Exception.new("function builder case conflict"))
			const nFnCom = ClassFactory.new(self._manager, self._luaFunc)
			vRefer:setRawAsync(self._node, function()
				local nImplType = vStruct
				if Reference.is(nImplType) then
					nImplType = nImplType:waitTypeCom():getTypeAwait()
					assert(not nImplType:isUnion(), "interface can't be union")
				end
				self._context:recordDefineLuaFunction(nFnCom)
				local nInterface = self._manager.type.Object
				if nImplType then
					assert(MetaObject.is(nImplType), "implement type must be MetaObject")
					nInterface = nImplType
				end
				const nTable = nFnCom:createLuaTable(self._context, vRefer, nInterface)
				return {nTable}
			end, function(vLuaTable)
				nFnCom:runBuild()
			end)
			self._fnCom = nFnCom
			return vLongHint
		end,
		Ret=function(vLongHint:class.FnLongHint, ...:class.UAllType):Ret(class.FnLongHint)
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			local nRetTuples = self._retTuples
			if not nRetTuples then
				nRetTuples = self._manager:SingleRetTuples(self._manager:Tuple(...))
			else
				nRetTuples = self._manager:retConcat(self._node, nRetTuples, self._manager:Tuple(...))
			end
			self._retTuples = nRetTuples
			return vLongHint
		end,
		isguard=function(vLongHint:class.FnLongHint, vType:class.UAllType):Ret(class.FnLongHint)
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			const nOpenCom = OpenFnCom.new(self._manager, self._luaFunc)
			nOpenCom:initByGuard(self._context, vType)
			self._fnCom = nOpenCom
			return vLongHint
		end,
	}
end

function FunctionBuilder:buildOpen():Ret(class.LuaFunction)
	const nOpenCom = OpenFnCom.new(self._manager, self._luaFunc)
	nOpenCom:initByOpen()
	self._fnCom = nOpenCom
	const ok, err = pcall(self._suffixHint.caller, {
		RetClass=function(vHint, _, _)
			return vHint
		end,
		Ret=function(vHint)
			return vHint
		end,
		isguard=function(vHint, vType)
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	return self._luaFunc
end

function FunctionBuilder:buildClass():Ret(class.LuaFunction)
	const nFactoryCom = ClassFactory.new(self._manager, self._luaFunc)
	const ok, err = pcall(self._suffixHint.caller, {
		RetClass=function(vHint, vRefer, vStruct)
			assert(vRefer and Reference.is(vRefer), Exception.new("RetClass's first arg must be a Reference"))
			vRefer:setRawAsync(self._node, function()
				local nImplType = vStruct
				if Reference.is(nImplType) then
					nImplType = nImplType:waitTypeCom():getTypeAwait()
					assert(not nImplType:isUnion(), "interface can't be union")
				end
				self._context:recordDefineLuaFunction(nFactoryCom)
				local nInterface = self._manager.type.Object
				if nImplType then
					assert(MetaObject.is(nImplType), "implement type must be MetaObject")
					nInterface = nImplType
				end
				const nTable = nFactoryCom:createLuaTable(self._context, vRefer, nInterface)
				return {nTable}
			end, function(vLuaTable)
				nFactoryCom:runBuild()
			end)
			nRefer = vRefer
			return vHint
		end,
		Ret=function(vHint)
			return vHint
		end,
		isguard=function(vHint, vType)
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	return self._luaFunc
end

function FunctionBuilder:build():Ret(class.LuaFunction)
	const nAttrSet = self._prefixHint.attrSet
	if nAttrSet.open then
		return self:buildOpen()
	end
	if nAttrSet.class then
		return self:buildClass()
	end
	local nLongHint = self:makeLongHint()
	local ok, err = pcall(self._suffixHint.caller, nLongHint)
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	if nAttrSet.pass then
		self._pass = true
	end
	local nFnCom = self._fnCom
	if not nFnCom then
		local nRetTuples = self._retTuples
		if not self._hasRet then
			if not nRetTuples then
				nRetTuples = self._manager:VoidRetTuples()
			elseif not self._pass then
				local hasVoid = false
				local hasSome = false
				nRetTuples:foreachWithFirst(function(vTypeTuple, _)
					if #vTypeTuple > 0 then
						hasSome = true
					else
						hasVoid = true
					end
				end)
				if hasSome and not hasVoid then
					self._context:getRuntime():nodeError(self._node, "hint return something but block has no RetStat")
				end
			end
		end
		const nLateFnCom = LateFnCom.new(self._manager, self._luaFunc)
		nLateFnCom:init(nRetTuples, self._pass)
		self._context:recordLateLuaFunction(nLateFnCom)
	end

	return self._luaFunc
end

return FunctionBuilder
