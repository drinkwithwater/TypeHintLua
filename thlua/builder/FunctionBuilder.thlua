
local Reference = require "thlua.type.Reference"
local LuaFunction = require "thlua.func.LuaFunction"
local Variable = require "thlua.func.Variable"
local TermCase = require "thlua.term.TermCase"
local FunctionBuilder = {}

(@do
	var.class = import("thlua.type.TypeClass").class
	class.ArgsBuilder = Struct ({
		[Number] = Union(class.Variable, class.IValueType),
		Dots = Union(class.Variable, class.IValueType, Nil)
	}, {
		next=true,
	})
end)

function FunctionBuilder.Begin(vContext, vNode, vAutoArgs, vRunFunc)
	local nManager = vContext._manager
	local nLuaFunc = nManager:LuaFunction()
	nLuaFunc:init(vContext, vNode)
	local nData = {
		context=vContext,
		node=vNode,
		autoArgs=vAutoArgs,
		retTuples=false,
		runFunc=vRunFunc,
		guardFunc=false,
		isGuard=false,
		tag=LuaFunction.DEFAULT,
		newTypeRefer=false,
		luaFunc=nLuaFunc,
	}
	local function setTag(vTag)
		if nData.tag == vTag then
			error(nData.tag.."-fn can only be set once")
		end
		assert(nData.tag == LuaFunction.DEFAULT, nData.tag.."-fn can't set "..vTag)
		nData.tag = vTag
	end
	local nHintMethod = {
		NewTable=function(self, vRefer, vStruct)
			vRefer:setTypeAsync(function()
				if Reference.is(vStruct) then
					vStruct = vStruct:getTypeAwait()
				end
				local nTable = nManager:LuaTable()
				nTable:setCtor(nLuaFunc, vStruct)
				nTable.name = tostring(vRefer)
				return nTable
			end)
			setTag(LuaFunction.DEFINE)
			nData.newTypeRefer = vRefer
			assert(not nData.retTuples, "define function can't return other")
			return self
		end,
		Ret=function(self, ...)
			local nRetTuples = nData.retTuples
			if not nRetTuples then
				nRetTuples = nManager:EmptyRetTuples()
			end
			nData.retTuples = nRetTuples:Add(nManager:Tuple(...))
			return self
		end,
		nocheck=function(self)
			setTag(LuaFunction.NOCHECK)
			return self
		end,
		open=function(self)
			setTag(LuaFunction.OPEN)
			return self
		end,
		isguard=function(self, vType)
			setTag(LuaFunction.OPEN)
			local nTrue = nManager.type.True
			local nFalse = nManager.type.False
			nData.guardFunc=function(self, vTermTuple)
				-- TODO isguard add refinement
				local nTerm = vTermTuple:get(1)
				local caseTrue = TermCase.new()
				caseTrue:put_and(nTerm, vType)
				local nTypeCaseList = {
					{nTrue, caseTrue},
					{nFalse, TermCase.new()},
				}
				return nManager:mergeToUnionTerm(nTypeCaseList)
			end
			return self
		end,
	}
	return nData, nHintMethod
end

function FunctionBuilder.End(vData)
	local nContext = vData.context
	local nManager = nContext._manager
	local nLuaFunc = vData.luaFunc
	local nTag = vData.tag
	if nTag == LuaFunction.OPEN then
		assert(not vData.retTuples, "native function can't set ret")
		nLuaFunc:setUnionFn({
			tag=nTag,
			fn=nManager:NativeFunction(vData.guardFunc or vData.runFunc),
			isGuard=vData.guardFunc and true,
		})
	elseif nTag == LuaFunction.NOCHECK then
		if not vData.retTuples then
			error("nocheck-fn must set ret")
		end
		nLuaFunc:setUnionFn({
			tag=nTag,
			fn=nManager:Function(vData.autoArgs:checkWhenNocheck(nContext), vData.retTuples)
		})
	elseif vData.tag == LuaFunction.DEFINE then
		nLuaFunc:setUnionFn({
			tag=nTag,
			fn=false,
			autoArgs=vData.autoArgs,
			runFunc=vData.runFunc,
			newTypeRefer=vData.newTypeRefer,
			once=false,
		})
		nContext:getRuntime():recordDefineLuaFunction(nLuaFunc)
	elseif vData.tag == LuaFunction.DEFAULT then
		local nRetTuples = vData.retTuples
		nLuaFunc:setUnionFn({
			tag=nTag,
			fn=false,
			autoArgs=vData.autoArgs,
			runFunc=vData.runFunc,
			retTuples=nRetTuples,
			once=false,
		})
		if (not vData.autoArgs:hasVariable()) and nRetTuples then
			nContext:getRuntime():recordLateLuaFunction(nLuaFunc)
		end
	end
	return nLuaFunc
end

return FunctionBuilder
