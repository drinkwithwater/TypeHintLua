
local Reference = require "thlua.type.Reference"
local LuaFunction = require "thlua.func.LuaFunction"
local Variable = require "thlua.func.Variable"
local TermCase = require "thlua.term.TermCase"

local OpenFnCom = require "thlua.func.OpenFnCom"
local NocheckFnCom = require "thlua.func.NocheckFnCom"
local NewFnCom = require "thlua.func.NewFnCom"
local DefaultFnCom = require "thlua.func.DefaultFnCom"

local FunctionBuilder = {}

(@var.class = import("thlua.type.TypeClass").class)

FunctionBuilder.__index=FunctionBuilder

function FunctionBuilder.new(vContext:class.Context,
	vNode:class.AstNode, vAutoArgs:class.AutoArguments, vRunFunc:class.GenFunc)::RetNew(class.FunctionBuilder)
	local nManager = vContext._manager
	local nLuaFunc = nManager:LuaFunction()
	nLuaFunc:init(vContext, vNode, vRunFunc)
	return setmetatable({::New()
		_context=vContext,
		_manager=nManager,
		_retTuples=false,
		_fnCom=false,
		_runFunc=vRunFunc,
		_luaFunc=nLuaFunc,
		_autoArgs=vAutoArgs,
		_tag=LuaFunction.DEFAULT,
	}, FunctionBuilder)
end

function FunctionBuilder.newLongHint(self)
	return {
		RetNew=function(vLongHint, vRefer, vStruct)
			assert(not self._fnCom, "function builder case conflict")
			local nInfo = NewFnCom.new(self._manager, self._luaFunc)
			vRefer:setTypeCtor(nInfo)
			self._fnCom = nInfo
			nInfo:initByRetNew(vRefer, vStruct)
			return vLongHint
		end,
		Ret=function(vLongHint, ...)
			local nRetTuples = self._retTuples
			if not nRetTuples then
				nRetTuples = self._manager:EmptyRetTuples()
			end
			self._retTuples = nRetTuples:Add(self._manager:Tuple(...))
			return vLongHint
		end,
		nocheck=function(vLongHint)
			assert(not self._fnCom, "function builder case conflict")
			local nInfo = NocheckFnCom.new(self._manager, self._luaFunc)
			self._fnCom = nInfo
			return vLongHint
		end,
		open=function(vLongHint)
			assert(not self._fnCom, "function builder case conflict")
			local nOpenInfo = OpenFnCom.new(self._manager, self._luaFunc)
			nOpenInfo:initByOpen(self._runFunc)
			self._fnCom = nOpenInfo
			return vLongHint
		end,
		isguard=function(vLongHint, vType)
			assert(not self._fnCom, "function builder case conflict")
			local nOpenInfo = OpenFnCom.new(self._manager, self._luaFunc)
			nOpenInfo:initByGuard(vType)
			self._fnCom = nOpenInfo
			return vLongHint
		end,
	}
end

function FunctionBuilder:build()
	local nFnCom = self._fnCom
	if nFnCom then
		local nTag = nFnCom.tag
		if nTag == LuaFunction.NOCHECK then
			if not self._retTuples then
				error("nocheck-fn must set ret")
			end
			local nTypeFn = self._manager:Function(self._autoArgs:checkWhenNocheck(self._context), self._retTuples)
			self._fnCom:setTypeFn(nTypeFn)
		elseif nTag == LuaFunction.NEW then
			local nTypeTuple = self._autoArgs:checkWhenLate(self._context)
			self._fnCom:setArgTuple(nTypeTuple)
			self._context:getRuntime():recordDefineLuaFunction(self._fnCom)
		elseif nTag == LuaFunction.OPEN then
		else
			error("invalid tag:"..tostring(nTag))
		end
	else
		local nFnCom = DefaultFnCom.new(self._manager, self._luaFunc)
		nFnCom:setArgRet(self._autoArgs, self._retTuples)
		self._context:getRuntime():recordLateLuaFunction(nFnCom)
	end
	return self._luaFunc
end


return FunctionBuilder
