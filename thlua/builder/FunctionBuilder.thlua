
const Reference = require "thlua.refer.Reference"
const Exception = require "thlua.Exception"
const Enum = require "thlua.Enum"
const MetaObject = require "thlua.object.MetaObject"

const OpenFnCom = require "thlua.func.OpenFnCom"
const LateFnCom = require "thlua.func.LateFnCom"
const ClassFactory = require "thlua.func.ClassFactory"

(@do
	let.class = import("thlua.type.TypeClass").class
	let.node = import("thlua.code.Node").node

	class.FnLongHint = Struct {
		RetClass=Fn(class.FnLongHint, class.Reference, OrNil(class.UAllType)):Ret(class.FnLongHint),
		Ret=Fn(class.FnLongHint):Dots(class.UAllType):Ret(class.FnLongHint),
		RetIs=Fn(class.FnLongHint, class.UAllType):Ret(class.FnLongHint),
	}

	class.FuncNewInfo = Struct ({
		_prefixHint=class.TLongHintInfo(Nil),
		_parNum=Integer,
		_isvararg=Boolean,
		_hasRet=Boolean,
		_polyParNum=OrFalse(Integer), -- if not full typed, _polyParNum is false
		_hintFullKind=OrFalse(node.HintFullKindEnum),
		_parMaker=Fn(List(class.UAllType)):Ret(List(OrFalse(class.UAllType)), OrFalse(class.UAllType)),
		_retMaker=Fn(List(class.UAllType)):Ret(class.TLongHintInfo(class.FnLongHint)),
		_genFunc=class.GenFunc,
	}, {
		__next=KeyOf(class.FuncNewInfo)
	})
end)

const FunctionBuilder = {}
FunctionBuilder.__index=FunctionBuilder

function.class FunctionBuilder.new(
	vManager:class.TypeManager,
	vContext:class.Context,
	vNode:class.IAstNode,
	vInfo:class.FuncNewInfo
):RetClass(class.FunctionBuilder)
	const self = {.class
		_manager=vManager,
		_context=vContext,
		_node=vNode,
		_luaFunc=vManager:LuaFunction(),
		_pass=vInfo._prefixHint.attrSet.pass and true or false,
	}
	for k,v in pairs(vInfo) do
		self[k] = v
	end
	setmetatable(self, FunctionBuilder)
	return self
end

function FunctionBuilder:error(...:Truth)
	if not self._pass then
		self._context:getRuntime():nodeError(self._node, ...)
	end
end

function FunctionBuilder:checkWhenCast(vContext:class.Context, vCastTypeFn:class.TypeFunction):Ret(class.TypeFunction)
	-- 1. check par
	const nParTuple = self:_makeParTupleByCast(vContext, vCastTypeFn:getParTuple())
	-- 2. check ret
	const nHintRetTuples = self:_makeRetTuples(vContext, {})
	const nCastRetTuples = vCastTypeFn:getRetTuples()
	if nHintRetTuples then
		if not nCastRetTuples:containTuples(nHintRetTuples) then
			self:error("interface-fn ret and hint ret notmatch")
		end
		return self._manager:Function(nParTuple, nHintRetTuples)
	else
		return self._manager:Function(nParTuple, nCastRetTuples)
	end
end

function FunctionBuilder:_makeRetTuples(
	vContext:class.Context,
	vTypeList:List(class.UAllType)
):Ret(OrFalse(class.RetTuples))
	const nSuffixHint = self._retMaker(vTypeList)
	local nRetTuples:OrFalse(class.RetTuples) = false
	const ok, err = pcall(nSuffixHint.caller, {
		RetClass=function(vHint, _, _)
			error("RetClass can not be used here")
			return vHint
		end,
		Ret=function(vHint, ...:class.UAllType)
			if not nRetTuples then
				nRetTuples = self._manager:SingleRetTuples(self._manager:Tuple(...))
			else
				nRetTuples = self._manager:retConcat(self._luaFunc:getNode(), nRetTuples, self._manager:Tuple(...))
			end
			return vHint
		end,
		RetIs=function(vHint, vType)
			error("ret cannot used here")
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._luaFunc:getNode()))
	end
	if not self._hasRet then
		if nRetTuples and not self._pass then
			local hasVoid = false
			local hasSome = false
			nRetTuples:foreachWithFirst(function(vTypeTuple, _)
				if #vTypeTuple > 0 then
					hasSome = true
				else
					hasVoid = true
				end
			end)
			if hasSome and not hasVoid then
				self:error("hint return something but block has no RetStat")
			end
		end
	end
	return nRetTuples
end

function FunctionBuilder:_makeParTupleByCast(vContext:class.Context, vTypeTuple:class.UTypeTuple):Ret(class.UTypeTuple)
	const nParList, nDotsType = self._parMaker({})
	local nNewList:List(class.UAllType) = {}
	if #vTypeTuple ~= self._parNum then
		self:error("arguments num not match when specification")
	end
	for i, nPar in ipairs(nParList) do
		local nInputType = vTypeTuple:get(i)
		if not nPar then
			nNewList[i] = nInputType
		else
			nNewList[i] = nPar
			if not nPar:containAll(nInputType) then
				self:error("arguments type not match when checkout")
			end
		end
	end
	local nTuple = self._manager:Tuple(table.unpack(nNewList))
	const nRepeatType = vTypeTuple:getRepeatType()
	if self._isvararg then
		if not nRepeatType then
			self:error("arguments type not match for not dots")
		end
		if not nDotsType then
			return nTuple:Dots(nRepeatType or self._manager.type.Truth)
		else
			if nRepeatType and not nDotsType:containAll(nRepeatType) then
				self:error("arguments type not match for wrong dots")
			end
			return nTuple:Dots(nDotsType)
		end
	else
		if nRepeatType then
			self:error("arguments type not match for dots")
		end
		return nTuple
	end
end

function FunctionBuilder:_checkWhenMember(vContext:class.Context):Ret(class.MemberFunction)
	const nParTuple = self:_makeParTupleByFirst(vContext, self._manager.type.Truth)
	const nRetTuples = self:_makeRetTuples(vContext, {}) or self._manager:VoidRetTuples()
	const nFn = self._manager:Function(nParTuple, nRetTuples)
	return self._manager:MemberFunction(self._node, nFn)
end

function FunctionBuilder:_makeParTupleByFirst(vContext:class.Context, vFirst:class.UAllType):Ret(class.UTypeTuple)
	const nParList, nDotsType = self._parMaker({})
	const nNewList:List(class.UAllType) = {}
	const nFirstPar = nParList[1]
	if self._parNum == 0 then
		self:error("one argument maybe required here?")
		nNewList[1] = vFirst
	else
		if not nFirstPar then
			nNewList[1] = vFirst
		else
			nNewList[1] = nFirstPar
			if not nFirstPar:containAll(vFirst) then
				self:error("first argument not match when cast")
			end
		end
	end
	for i=2,#nParList do
		const nPar = nParList[i]!
		if not nPar then
			nNewList[i] = self._manager.type.Truth
		else
			nNewList[i] = nPar
		end
	end
	const nTuple = self._manager:Tuple(table.unpack(nNewList))
	if self._isvararg then
		if not nDotsType then
			return nTuple:Dots(self._manager.type.Truth)
		else
			return nTuple:Dots(nDotsType)
		end
	else
		return nTuple
	end
end

function FunctionBuilder:_checkParTupleByDefault():Ret(class.UTypeTuple)
	const nParList, nDotsType = self._parMaker({})
	for i, nParType in ipairs(nParList) do
		if not nParType then
			error("param type is required here, order="..tostring(i))
		end
	end
	local nTuple = self._manager:Tuple(table.unpack(nParList @ List(class.UAllType)))
	if self._isvararg then
		if not nDotsType then
			error("dots type is required here")
		end
		return nTuple:Dots(nDotsType)
	else
		return nTuple
	end
end

function FunctionBuilder:_makeParTuple(vContext:class.Context, vTypeList:List(class.UAllType)):Ret(class.UTypeTuple)
	const nParList, nDotsType = self._parMaker(vTypeList)
	for i, nParType in ipairs(nParList) do
		if not nParType then
			error("param type is required here, order="..tostring(i))
		end
	end
	local nTuple = self._manager:Tuple(table.unpack(nParList @ List(class.UAllType)))
	if self._isvararg then
		if not nDotsType then
			error("dots type is required here")
		end
		return nTuple:Dots(nDotsType)
	else
		return nTuple
	end
end

function FunctionBuilder:checkWhenGeneric(vContext:class.Context, vTypeList:List(class.UAllType)):Ret(class.TypeFunction)
	const nParTuple = self:_makeParTuple(vContext, vTypeList)
	const nRetTuples = self:_makeRetTuples(vContext, vTypeList) or self._manager:VoidRetTuples()
	return self._manager:Function(nParTuple, nRetTuples)
end

function FunctionBuilder:_checkWhenDefault():Ret(class.TypeFunction)
	const nParTuple = self:_checkParTupleByDefault()
	const nRetTuples = self:_makeRetTuples(self._context, {}) or self._manager:VoidRetTuples()
	return self._manager:Function(nParTuple, nRetTuples)
end

function FunctionBuilder:getHintFullKind():Ret(OrFalse(node.HintFullKindEnum))
	return self._hintFullKind
end

function FunctionBuilder:_buildOpen():Ret(class.OpenFnCom)
	const nSuffixHint = self._retMaker({})
	const nOpenCom = OpenFnCom.new(self._manager, self._luaFunc)
	local nSetReturn = false
	const ok, err = pcall(nSuffixHint.caller, {
		RetClass=function(vHint, _, _)
			return vHint
		end,
		Ret=function(vHint, ...)
			return vHint
		end,
		RetIs=function(vHint, vType)
			assert(not nSetReturn, "RetIs can only use once here")
			nOpenCom:initByGuard(self._context, vType)
			nSetReturn = true
			return vHint
		end,
	})
	if not nSetReturn then
		nOpenCom:initByOpen()
	end
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	return nOpenCom
end

function FunctionBuilder:_buildClass():Ret(class.ClassFactory)
	const nSuffixHint = self._retMaker({})
	const nFactoryCom = ClassFactory.new(self._manager, self._luaFunc)
	const ok, err = pcall(nSuffixHint.caller, {
		RetClass=function(vHint, vRefer, vStruct)
			assert(vRefer and Reference.is(vRefer), Exception.new("RetClass's first arg must be a Reference"))
			vRefer:setRawAsync(self._node, function()
				local nImplType = vStruct
				if Reference.is(nImplType) then
					nImplType = nImplType:waitTypeCom():getTypeAwait()
					assert(not nImplType:isUnion(), "interface can't be union")
				end
				self._context:recordDefineLuaFunction(nFactoryCom)
				local nInterface = self._manager.type.AnyObject
				if nImplType then
					assert(MetaObject.is(nImplType), "implement type must be MetaObject")
					nInterface = nImplType
				end
				const nParTuple = self:_checkParTupleByDefault()
				const nTable = nFactoryCom:createLuaTable(self._context, nParTuple, vRefer, nInterface)
				return {nTable}
			end, function(vLuaTable)
				nFactoryCom:runBuild()
			end)
			nRefer = vRefer
			return vHint
		end,
		Ret=function(vHint, ...)
			error("TODO : class use Ret not RetClass")
			return vHint
		end,
		RetIs=function(vHint, vType)
			return vHint
		end,
	})
	if not ok then
		error(Exception.new(tostring(err), self._node))
	end
	return nFactoryCom
end

function FunctionBuilder:build():Ret(class.LuaFunction)
	local nFnCom:OrNil(class.UFnCom) = nil
	const nAttrSet = self._prefixHint.attrSet
	if nAttrSet.open then
		nFnCom = self:_buildOpen()
	elseif nAttrSet.class then
		nFnCom = self:_buildClass()
	else
		if nAttrSet.self then
			self._luaFunc:setMethod()
		end
		local nDefaultTypeFn:OrFalse(class.TypeFunction) = false
		if self:getHintFullKind() == Enum.HintFullKind_FULL then
			nDefaultTypeFn = self:_checkWhenDefault()
		end
		local nMemberFn:OrFalse(class.MemberFunction) = false
		if self:getHintFullKind() == Enum.HintFullKind_SELF then
			nMemberFn = self:_checkWhenMember(self._context)
		end
		const nLateFnCom = LateFnCom.new(self._manager, self._luaFunc, nDefaultTypeFn, nMemberFn, nAttrSet.pass and true or false)
		self._context:recordLateLuaFunction(nLateFnCom)
		nFnCom = nLateFnCom
	end
	self._luaFunc:lateInit(self._context, self._node, self, nFnCom)
	return self._luaFunc
end

function FunctionBuilder:getGenFunc():Ret(class.GenFunc)
	return self._genFunc
end

return FunctionBuilder
