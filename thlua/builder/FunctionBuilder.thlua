
local Reference = require "thlua.type.Reference"
local LuaFunction = require "thlua.func.LuaFunction"
local Variable = require "thlua.func.Variable"
local TermCase = require "thlua.term.TermCase"

local Exception = require "thlua.Exception"
local OpenFnCom = require "thlua.func.OpenFnCom"
local LateFnCom = require "thlua.func.LateFnCom"
local ClassFnCom = require "thlua.func.ClassFnCom"

local FunctionBuilder = {}

(@let.class = import("thlua.type.TypeClass").class)

FunctionBuilder.__index=FunctionBuilder

function FunctionBuilder.new(vContext:class.Context,
	vNode:class.AstNode, vAutoArgs:class.AutoArguments, vHasRet:Boolean, vRunFunc:class.GenFunc)::RetClass(class.FunctionBuilder)
	local nManager = vContext._manager
	local nLuaFunc = nManager:LuaFunction()
	nLuaFunc:init(vContext, vNode, vAutoArgs, vRunFunc)
	return setmetatable({::Self()
		_node=vNode,
		_context=vContext,
		_manager=nManager,
		_retTuples=false@Union(False, class.RetTuples),
		_nocheck=false@Boolean,
		_fnCom=false@Union(False, class.UFnCom),
		_hasRet=vHasRet,
		_luaFunc=nLuaFunc,
		_autoArgs=vAutoArgs,
	}, FunctionBuilder)
end

function FunctionBuilder.newLongHint(self:class.FunctionBuilder)::RetClass(class.FnLongHint)
	return {::Self()
		member=function(vLongHint:class.FnLongHint)::Ret(class.FnLongHint)
			self._autoArgs:setSelf(self._context)
			return vLongHint
		end,
		RetClass=function(vLongHint:class.FnLongHint, vRefer, vStruct)::Ret(class.FnLongHint)
			if not self._hasRet then
				self._context:getRuntime():nodeError(self._node, "hint return class but block has no RetStat")
			end
			assert(vRefer and Reference.is(vRefer), Exception.new("RetClass's first arg must be a Reference"))
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			assert(not self._retTuples, Exception.new("function builder case conflict"))
			local nCom = ClassFnCom.new(self._manager, self._luaFunc)
			vRefer:setTypeAsync(function()
				local nImplType = vStruct
				if Reference.is(vStruct) then
					nImplType = vStruct:getTypeAwait()
				end
				local nTable = self._manager:LuaTable()
				nTable:initByClass(nCom, false, nImplType)
				return nTable
			end)
			self._fnCom = nCom
			nCom:initByRetClass(self._context, vRefer)
			return vLongHint
		end,
		Ret=function(vLongHint:class.FnLongHint, ...)::Ret(class.FnLongHint)
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			local nRetTuples = self._retTuples
			if not nRetTuples then
				nRetTuples = self._manager:SingleRetTuples(self._manager:Tuple(...))
			else
				nRetTuples = nRetTuples:Add(self._manager:Tuple(...))
			end
			self._retTuples = nRetTuples
			return vLongHint
		end,
		nocheck=function(vLongHint:class.FnLongHint)::Ret(class.FnLongHint)
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			self._nocheck=true
			return vLongHint
		end,
		open=function(vLongHint:class.FnLongHint)::Ret(class.FnLongHint)
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			assert(not self._retTuples, Exception.new("function builder case conflict"))
			local nOpenCom = OpenFnCom.new(self._manager, self._luaFunc)
			nOpenCom:initByOpen()
			self._fnCom = nOpenCom
			return vLongHint
		end,
		isguard=function(vLongHint:class.FnLongHint, vType)::Ret(class.FnLongHint)
			assert(not self._fnCom, Exception.new("function builder case conflict"))
			local nOpenCom = OpenFnCom.new(self._manager, self._luaFunc)
			nOpenCom:initByGuard(self._context, vType)
			self._fnCom = nOpenCom
			return vLongHint
		end,
	}
end

function FunctionBuilder:build()::Ret(class.LuaFunction)
	local nFnCom = self._fnCom
	if not nFnCom then
		local nRetTuples = self._retTuples
		if not self._hasRet then
			if not nRetTuples then
				nRetTuples = self._manager:VoidRetTuples()
			elseif not self._nocheck then
				local hasVoid = false
				local hasSome = false
				nRetTuples:foreach(function(vTypeTuple)
					if #vTypeTuple > 0 then
						hasSome = true
					else
						hasVoid = true
					end
				end)
				if hasSome and not hasVoid then
					self._context:getRuntime():nodeError(self._node, "hint return something but block has no RetStat")
				end
			end
		end
		local nLateFnCom = LateFnCom.new(self._manager, self._luaFunc)
		nLateFnCom:init(nRetTuples, self._nocheck)
		self._context:recordLateLuaFunction(nLateFnCom)
	else
		if ClassFnCom.is(nFnCom) then
			self._context:recordDefineLuaFunction(nFnCom)
		end
	end
	return self._luaFunc
end

return FunctionBuilder
