
local Reference = require "thlua.type.Reference"
local LuaFunction = require "thlua.func.LuaFunction"
local Variable = require "thlua.func.Variable"
local TermCase = require "thlua.term.TermCase"

local OpenFnInfo = require "thlua.func.OpenFnInfo"
local NocheckFnInfo = require "thlua.func.NocheckFnInfo"
local NewFnInfo = require "thlua.func.NewFnInfo"
local DefaultFnInfo = require "thlua.func.DefaultFnInfo"

local FunctionBuilder = {}

(@var.class = import("thlua.type.TypeClass").class)

FunctionBuilder.__index=FunctionBuilder

function FunctionBuilder.new(vContext:class.Context,
	vNode:class.AstNode, vAutoArgs:class.AutoArguments, vRunFunc:class.GenFunc)::RetNew(class.FunctionBuilder)
	local nManager = vContext._manager
	local nLuaFunc = nManager:LuaFunction()
	nLuaFunc:init(vContext, vNode, vRunFunc)
	return setmetatable({::New()
		_context=vContext,
		_manager=nManager,
		_retTuples=false,
		_fnInfo=false,
		_runFunc=vRunFunc,
		_luaFunc=nLuaFunc,
		_autoArgs=vAutoArgs,
		_tag=LuaFunction.DEFAULT,
	}, FunctionBuilder)
end

function FunctionBuilder.newLongHint(self)
	return {
		RetNew=function(vLongHint, vRefer, vStruct)
			assert(not self._fnInfo, "function builder case conflict")
			local nInfo = NewFnInfo.new(self._manager, self._luaFunc)
			vRefer:setTypeCtor(nInfo)
			self._fnInfo = nInfo
			nInfo:initByRetNew(vRefer, vStruct)
			return vLongHint
		end,
		Ret=function(vLongHint, ...)
			local nRetTuples = self._retTuples
			if not nRetTuples then
				nRetTuples = self._manager:EmptyRetTuples()
			end
			self._retTuples = nRetTuples:Add(self._manager:Tuple(...))
			return vLongHint
		end,
		nocheck=function(vLongHint)
			assert(not self._fnInfo, "function builder case conflict")
			local nInfo = NocheckFnInfo.new(self._manager, self._luaFunc)
			self._fnInfo = nInfo
			return vLongHint
		end,
		open=function(vLongHint)
			assert(not self._fnInfo, "function builder case conflict")
			local nOpenInfo = OpenFnInfo.new(self._manager, self._luaFunc)
			nOpenInfo:initByOpen(self._runFunc)
			self._fnInfo = nOpenInfo
			return vLongHint
		end,
		isguard=function(vLongHint, vType)
			assert(not self._fnInfo, "function builder case conflict")
			local nOpenInfo = OpenFnInfo.new(self._manager, self._luaFunc)
			nOpenInfo:initByGuard(vType)
			self._fnInfo = nOpenInfo
			return vLongHint
		end,
	}
end

function FunctionBuilder:build()
	local nFnInfo = self._fnInfo
	if nFnInfo then
		local nTag = nFnInfo.tag
		if nTag == LuaFunction.NOCHECK then
			if not self._retTuples then
				error("nocheck-fn must set ret")
			end
			local nTypeFn = self._manager:Function(self._autoArgs:checkWhenNocheck(self._context), self._retTuples)
			self._fnInfo:setTypeFn(nTypeFn)
		elseif nTag == LuaFunction.DEFINE then
			local nTypeTuple = self._autoArgs:checkWhenLate(self._context)
			self._fnInfo:setArgTuple(nTypeTuple)
			self._context:getRuntime():recordDefineLuaFunction(self._fnInfo)
		elseif nTag == LuaFunction.OPEN then
		else
			error("invalid tag:"..tostring(nTag))
		end
	else
		local nFnInfo = DefaultFnInfo.new(self._manager, self._luaFunc)
		nFnInfo:setArgRet(self._autoArgs, self._retTuples)
		self._context:getRuntime():recordLateLuaFunction(nFnInfo)
	end
	return self._luaFunc
end


return FunctionBuilder
