
const ParseEnv = require "thlua.code.ParseEnv"
const Node = require "thlua.code.Node"
const Exception = require "thlua.Exception"
const VisitorExtend = require "thlua.code.VisitorExtend"
const SymbolVisitor = require "thlua.code.SymbolVisitor"
const HintGener = require "thlua.code.HintGener"
const SplitCode = require "thlua.code.SplitCode"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
	let.TypingFn = Fn(List(clazz.IAstNode), clazz.BaseStack, clazz.RefineTerm):Ret(clazz.OpenFunction)
	let.InjectFn = Fn(clazz.BaseStack, Fn(node.Ident_use):Ret(clazz.RefineTerm)):Ret(Any)
	let.LookupPair = Struct {
		pos = Integer,
		posEnd = Integer,
		node.Expr, node.Expr,
	}
end)

const CodeEnv = {}
CodeEnv.__index=CodeEnv

function:class(clazz.CodeEnv) CodeEnv.new(vCode:Union(String, clazz.SplitCode), vChunkName:String, vChunkWithInject:OrNil(node.Chunk))
	const nSplitCode = SplitCode.is(vCode) and vCode or SplitCode.new(vCode)
	const self = setmetatable({.class
		_code = nSplitCode,
		_chunkName = vChunkName,
		_nodeList = {}@List(node.IAstNode),
		_identList = {}@List(node.Ident),
		_lookupPairList = {}@List(LookupPair),
		_hintLookupPairList = {}@List(LookupPair),
		_typingCode = false@OrFalse(String),
		_astTree = nil@!node.Chunk,
		_typingFn = nil@!TypingFn,
	}, CodeEnv)
	if not vChunkWithInject then
		const nAst, nErr = ParseEnv.parse(nSplitCode:getContent())
		if not nAst then
			self:_prepareNode(nErr, false)
			error(Exception.new(nErr[1], nErr))
		end
		self._astTree = nAst
	else
		self._astTree = vChunkWithInject
	end
	self._typingFn = self:_buildTypingFn() @> TypingFn
	return self
end

function.pass CodeEnv:_prepareNode(vNode:node.IAstNode, vParent:OrFalse(node.IAstNode))
	const nNodeList = self._nodeList
	const nIndex = #nNodeList + 1
	nNodeList[nIndex] = vNode
	vNode.index = nIndex
	vNode.parent = vParent
	vNode.path = self._chunkName
	vNode.l, vNode.c = self._code:fixupPos(vNode.pos, vNode)
	Node.bind(vNode)
end

function CodeEnv:prepare()
	assert(#self._nodeList == 0, "node list has been setted")
	-- 1. set line & column, parent
	const nStack:List(node.IAstNode) = {}
	local nInHint = false
	self:visit(function(visitor, vNode)
		-- 1. prepare
		self:_prepareNode(vNode, nStack[#nStack] or false)
		-- 2. recurive visit
		nStack[#nStack + 1] = vNode
		if vNode.tag == "HintEval" then
			nInHint = false
			visitor:rawVisit(vNode)
			nInHint = true
		elseif vNode.tag == "HintSpace" then
			nInHint = true
			visitor:rawVisit(vNode)
			nInHint = false
		else
			visitor:rawVisit(vNode)
		end
		nStack[#nStack] = nil
		const nExprNode = vNode @> node.Expr
		-- 3. save some node
		if nExprNode.tag == "Ident" then
			table.insert(self._identList, nExprNode)
			if nExprNode.kind == "use" then
				const nPair:LookupPair = {
					pos=nExprNode.pos,posEnd=nExprNode.posEnd,
					nExprNode, nExprNode
				}
				table.insert(nInHint and self._hintLookupPairList or self._lookupPairList, nPair)
			end
		elseif nExprNode.tag == "Index" or nExprNode.tag == "Invoke" then
			const nSuffixExpr = nExprNode[2]
			if nSuffixExpr.tag == "String" or nSuffixExpr.tag == "Number" then
				const nPair:LookupPair = {
					pos=nSuffixExpr.pos, posEnd=nSuffixExpr.posEnd,
					nExprNode, nSuffixExpr
				}
				table.insert(nInHint and self._hintLookupPairList or self._lookupPairList, nPair)
			end
		elseif nExprNode.tag == "Call" then
			const nFirstArg = nExprNode[2][1]
			if nFirstArg and nFirstArg.tag == "String" then
				const nPair:LookupPair = {
					pos=nFirstArg.pos, posEnd=nFirstArg.posEnd,
					nExprNode, nFirstArg
				}
				table.insert(nInHint and self._hintLookupPairList or self._lookupPairList, nPair)
			end
		end
	end)
	table.sort(self._identList, function(a:node.Ident, b:node.Ident)
		return a.pos < b.pos
	end)
	table.sort(self._lookupPairList, function(a:LookupPair, b:LookupPair)
		return a.pos < b.pos
	end)
	table.sort(self._hintLookupPairList, function(a:LookupPair, b:LookupPair)
		return a.pos < b.pos
	end)
end

function CodeEnv:visit(vFunc:Fn(node.IVisitor, node.IAstNode)):Ret()
	const visitor = VisitorExtend(vFunc)
	visitor:realVisit(self._astTree)
end

function.pass CodeEnv:_buildTypingFn():Ret(AnyFunction)
	const nAst = self._astTree
	self:prepare()
	const nSymbolVisitor = SymbolVisitor.new()
	nSymbolVisitor:realVisit(nAst)
	const gener = HintGener.new(nAst)
	const nTypingCode = gener:genCode()
	self._typingCode = nTypingCode
	local nFunc, nInfo = load(nTypingCode, self._chunkName, "t", setmetatable({}, {
		__index=function(t,k)
			-- TODO, give node pos
			error("indexing global is fatal error, name="..k)
		end
	}))
	if not nFunc then
		error(Exception.new(tostring(nInfo), self._astTree))
	end
	assert(type(nFunc) == "function", Exception.new("typing code must return function", self._astTree))
	if not nFunc then
		-- TODO, give node pos
		error(Exception.new(tostring(nInfo), self._astTree))
	end
	return nFunc
end

function CodeEnv:getNodeList():Ret(List(clazz.IAstNode))
	return self._nodeList
end

function CodeEnv:getAstTree()
	return self._astTree
end

function CodeEnv:getTypingCode()
	return self._typingCode
end

function CodeEnv:getTypingFn():Ret(TypingFn)
	return self._typingFn
end

function CodeEnv:makeFocusList(vNode:node.IAstNode):Ret(List(node.Function))
	local nCurNode:OrNil(node.IAstNode) = vNode
	const nFocusList:List(node.Function) = {}
	while nCurNode do
		if nCurNode.tag == "Function" then
			const nFunc = nCurNode @> node.Function
			if nFunc.letNode then
				nFocusList[#nFocusList + 1] = nFunc
			end
		end
		nCurNode = nCurNode.parent
	end
	return nFocusList
end

function CodeEnv:traceBlockRegion(vTraceList:List(Integer)):Ret(node.Block, List(node.Function))
	local nRetBlock:node.Block = self._astTree[3]
	for i=1,#vTraceList-1 do
		const nTrace = vTraceList[i]!
		const nNextBlock = nRetBlock.subBlockList[nTrace]!
		if not nNextBlock then
			break
		else
			nRetBlock = nNextBlock
		end
	end
	return nRetBlock, self:makeFocusList(nRetBlock)
end

function CodeEnv:searchHintExprBySuffix(vPos:Integer):Ret(False):Ret(node.Expr, node.Block, List(node.Function))
	const nIndex, nPair = self._code:binSearch@<LookupPair>(self._hintLookupPairList, vPos)
	if not nIndex then
		return false
	end
	if vPos < nPair.pos or vPos >= nPair.posEnd then
		return false
	end
	local nRetBlock:OrNil(node.Block) = nil
	const nPrefixNode = nPair[1]
	-- lookup a non-hint block
	local nCurNode:OrNil(node.IAstNode) = nPrefixNode
	local nInHint = true
	while nCurNode do
		if nCurNode.tag == "HintSpace" then
			nInHint = false
		elseif nCurNode.tag == "Block" then
			if not nInHint then
				nRetBlock = nCurNode @> node.Block
				break
			end
		end
		nCurNode = nCurNode.parent
	end
	if not nRetBlock then
		return false
	end
	return nPrefixNode, nRetBlock, self:makeFocusList(nPrefixNode)
end

function CodeEnv:searchExprBySuffix(vPos:Integer):Ret(False):Ret(node.Expr, List(node.Function))
	const nIndex, nPair = self._code:binSearch@<LookupPair>(self._lookupPairList, vPos)
	if not nIndex then
		return false
	end
	if vPos < nPair.pos or vPos >= nPair.posEnd then
		return false
	end
	const nPrefixNode = nPair[1]
	return nPrefixNode, self:makeFocusList(nPrefixNode)
end

function CodeEnv:searchIdent(vPos:Integer):Ret(OrNil(node.Ident))
	const nIndex, nNode = self._code:binSearch@<node.Ident>(self._identList, vPos)
	if not nIndex then
		return nil
	end
	if vPos >= nNode.pos + #nNode[1] or vPos > nNode.posEnd then
		return nil
	end
	return nNode
end

function CodeEnv:getChunkName():Ret(String)
	return self._chunkName
end

function CodeEnv:getSplitCode()
	return self._code
end

function.open CodeEnv.is(v):isguard(clazz.CodeEnv)
	return getmetatable(v) == CodeEnv
end

function CodeEnv.genInjectFnByError(vSplitCode:clazz.SplitCode, vFileUri:String, vWrongContent:String):Ret(False):Ret(InjectFn, node.InjectTrace)
	const nRightAst, nErrNode = ParseEnv.parse(vWrongContent)
	if nRightAst then
		return false
	end
	const nInjectTrace = nErrNode[2]
	if not nInjectTrace then
		return false
	end
	const nChunk = nInjectTrace.capture
	const nOkay, nInjectFn = pcall(function():Ret(InjectFn)
		assert(nChunk.injectNode)
		const nFocusEnv = CodeEnv.new(vSplitCode, vFileUri, nChunk)
		(@do
			let.RawInjectFn = Fn(List(clazz.IAstNode), clazz.BaseStack, Fn(node.Ident_use):Ret(clazz.RefineTerm)):Ret(Any)
		end)
		const nRawInjectFn = nFocusEnv:getTypingFn() @? RawInjectFn
		return function(vStack, vGetter)
			return nRawInjectFn(nFocusEnv:getNodeList(), vStack, vGetter)
		end
	end)
	if nOkay then
		return nInjectFn, nInjectTrace
	else
		return false
	end
end

return CodeEnv
