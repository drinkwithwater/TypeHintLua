
const ParseEnv = require "thlua.code.ParseEnv"
const Node = require "thlua.code.Node"
const Exception = require "thlua.Exception"
const VisitorExtend = require "thlua.code.VisitorExtend"
const SymbolVisitor = require "thlua.code.SymbolVisitor"
const HintGener = require "thlua.code.HintGener"
const SplitCode = require "thlua.code.SplitCode"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
	let.TypingFn = Fn(List(clazz.IAstNode), clazz.BaseStack, clazz.RefineTerm):Ret(clazz.OpenFunction)
end)

const CodeEnv = class@<clazz.CodeEnv, false>(SplitCode)

function.open CodeEnv:ctor(vContent:String, vChunkName:String, vVersion:Integer)
	self._subject = vContent
	self._chunkName = vChunkName
	self._astTree = nil@!node.Chunk
	self._nodeList = {}@List(node.IAstNode)
	self._identList = {}@List(node.Ident_def)
	self._blockList = {}@List(node.Block)
	self._funcList = {}@List(node.Function)
	self._version = vVersion or -1
	self._typingCode = false@OrFalse(String)
	self._typingFn = nil@!TypingFn
end

function CodeEnv:lateInit()
	const nAst, nErr = ParseEnv.parse(self._subject)
	if not nAst then
		self:_prepareNode(nErr, false)
		error(Exception.new(nErr[1], nErr))
	end
	self._astTree = nAst
	self._typingFn = self:_buildTypingFn() @> TypingFn
end

function.pass CodeEnv:_prepareNode(vNode:node.IAstNode, vParent:OrFalse(node.IAstNode))
	const nNodeList = self._nodeList
	const nIndex = #nNodeList + 1
	nNodeList[nIndex] = vNode
	vNode.index = nIndex
	vNode.parent = vParent
	vNode.path = self._chunkName
	vNode.l, vNode.c = self:fixupPos(vNode.pos, vNode)
	Node.bind(vNode)
end

function CodeEnv:prepare()
	assert(#self._nodeList == 0, "node list has been setted")
	-- 1. set line & column, parent
	const nStack:List(node.IAstNode) = {}
	self:visit(function(visitor, vNode)
		-- 1. prepare
		self:_prepareNode(vNode, nStack[#nStack] or false)
		nStack[#nStack + 1] = vNode
		visitor:rawVisit(vNode)
		nStack[#nStack] = nil
		-- 2. put record ident
		if vNode.tag == "Ident" then
			table.insert(self._identList, vNode)
		end
		if vNode.tag == "Block" then
			table.insert(self._blockList, vNode)
		end
		if vNode.tag == "Function" then
			table.insert(self._funcList, vNode)
		end
	end)
	table.sort(self._identList, function(a:node.Ident, b:node.Ident)
		return a.pos < b.pos
	end)
	table.sort(self._blockList, function(a:node.Block, b:node.Block)
		return a.pos < b.pos
	end)
	table.sort(self._funcList, function(a:node.Function, b:node.Block)
		return a.pos < b.pos
	end)
end

function.pass CodeEnv:visit(vFunc:Fn(node.IVisitor, node.IAstNode))
	const visitor = VisitorExtend(vFunc)
	visitor:realVisit(self._astTree)
end

function.pass CodeEnv:_buildTypingFn():Ret(AnyFunction)
	const nAst = self._astTree
	self:prepare()
	const nSymbolVisitor = SymbolVisitor.new()
	nSymbolVisitor:realVisit(nAst)
	const gener = HintGener.new(nAst)
	const nTypingCode = gener:genCode()
	self._typingCode = nTypingCode
	local nFunc, nInfo = load(nTypingCode, self._chunkName, "t", setmetatable({}, {
		__index=function(t,k)
			-- TODO, give node pos
			error("indexing global is fatal error, name="..k)
		end
	}))
	if not nFunc then
		error(Exception.new(tostring(nInfo), self._astTree))
	end
	assert(type(nFunc) == "function", Exception.new("typing code must return function", self._astTree))
	if not nFunc then
		-- TODO, give node pos
		error(Exception.new(tostring(nInfo), self._astTree))
	end
	return nFunc
end

function CodeEnv:getNodeList():Ret(List(clazz.IAstNode))
	return self._nodeList
end

function CodeEnv:getAstTree()
	return self._astTree
end

function CodeEnv:getTypingCode()
	return self._typingCode
end

function CodeEnv:getTypingFn():Ret(TypingFn)
	return self._typingFn
end

function CodeEnv:searchNameByError(vErrorNode:node.Error):Ret(OrNil(node.Ident_def))
	local nErrExpr = vErrorNode[2]
	if not nErrExpr or nErrExpr.tag ~= "Ident" then
		-- other typp TODO
		return nil
	end
	return nil
	--[[
	local nTraceList = vErrorNode[3]!
	local nPos = nErrExpr.pos
	local nScope = self:searchScopeByTrace(nTraceList)
	local nName = nErrExpr[1]
	local nIdent = nScope.symbolTable[nName]
	while nIdent and nIdent.pos > nPos do
		nIdent = nIdent.lookupIdent
	end
	return nIdent]]
end

function CodeEnv:traceBlock(vPos:Integer):Ret(False):Ret(node.Block, List(node.Function))
	local nRetBlock:OrFalse(node.Block) = false
	for _, nBlock in ipairs(self._blockList) do
		if nBlock.pos <= vPos and vPos <= nBlock.posEnd then
			nRetBlock = nBlock
			break
		end
	end
	if not nRetBlock then
		return false
	else
		const nList:List(node.Function) = {}
		local nCurFunc:OrNil(node.IAstNode) = nRetBlock
		while nCurFunc do
			if nCurFunc.tag == "Function" and vPos < nCurFunc.posEnd then
				nList[#nList + 1] = nCurFunc @> node.Function
			end
			nCurFunc = nCurFunc.parent
		end
		return nRetBlock, nList
	end
end

function CodeEnv:searchBlock(vPos:Integer):Ret(OrNil(node.Block))
	for _, block in ipairs(self._blockList) do
		if block.pos <= vPos and vPos <= block.posEnd then
			return block
		end
	end
	return nil
end

function CodeEnv:lookupDefineIdent(vPos:Integer, vName:String):Ret(OrNil(node.Ident_def))
	const nIndex, nBlock = self:binSearch@<node.Block>(self._blockList, vPos)
	if not nIndex then
		return nil
	else
		local nIdent = nBlock.symbolTable[vName]
		while nIdent and nIdent.pos > vPos do
			nIdent = nIdent.lookupIdent
		end
		return nIdent
	end
end

function CodeEnv:searchIdent(vPos:Integer):Ret(OrNil(node.Ident))
	const nIndex, nNode = self:binSearch@<node.Ident_def>(self._identList, vPos)
	if not nIndex then
		return nil
	end
	if vPos >= nNode.pos + #nNode[1] or vPos > nNode.posEnd then
		return nil
	end
	return nNode
end

function CodeEnv:getVersion():Ret(Integer)
	return self._version
end

function CodeEnv:getChunkName():Ret(String)
	return self._chunkName
end

return CodeEnv
