
const ParseEnv = require "thlua.code.ParseEnv"
const Node = require "thlua.code.Node"
const Exception = require "thlua.Exception"
const VisitorExtend = require "thlua.code.VisitorExtend"
const SymbolVisitor = require "thlua.code.SymbolVisitor"
const HintGener = require "thlua.code.HintGener"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
	node.LinePos = Struct{
		pos=Integer,
		posEnd=Integer
	}
end)

local CodeEnv = {}
CodeEnv.__index=CodeEnv

function:class(clazz.CodeEnv) CodeEnv.new(vSubject:String, vChunkName:String, vVersion:Integer)
	local self = setmetatable({.class
		_linePosList = {}@List(node.LinePos),
		_subject = vSubject,
		_chunkName = vChunkName,
		_astOrErr = nil@!Union(node.Error, node.Chunk),
		_nodeList = {}@List(node.IAstNode),
		_identList = {}@List(node.Ident_def),
		_blockList = {}@List(node.Block),
		_funcList = {}@List(node.Function),
		_rootScope = false@OrFalse(node.Block),
		_version = vVersion or -1,
		_typingFn = "typing code not execute",
		_injectFn = false,
		_typingCode = false@OrFalse(String),
	}, CodeEnv)

	self:_init()
	self:_buildTypingFn()
	return self
end

function.pass CodeEnv:makeErrNode(vPos:Integer, vErr:String):Ret(node.Error)
	local nLine, nColumn = self:fixupPos(vPos)
	return setmetatable({
		tag="Error",
		path=self._chunkName,
		pos=vPos,
		l=nLine,
		c=nColumn,
		index=0,
		vErr
	}, Node)
end

function.pass CodeEnv:_prepareNode(vNode:node.IAstNode, vParent:OrFalse(node.IAstNode))
	const nNodeList = self._nodeList
	const nIndex = #nNodeList + 1
	nNodeList[nIndex] = vNode
	vNode.index = nIndex
	vNode.parent = vParent
	vNode.path = self._chunkName
	vNode.l, vNode.c = self:fixupPos(vNode.pos, vNode)
	Node.bind(vNode)
end

function CodeEnv:prepare()
	assert(#self._nodeList == 0, "node list has been setted")
	-- 1. set line & column, parent
	const nStack:List(node.IAstNode) = {}
	self:visit(function(visitor, vNode)
		-- 1. prepare
		self:_prepareNode(vNode, nStack[#nStack] or false)
		nStack[#nStack + 1] = vNode
		visitor:rawVisit(vNode)
		nStack[#nStack] = nil
		-- 2. put record ident
		if vNode.tag == "Ident" then
			table.insert(self._identList, vNode)
		end
		if vNode.tag == "Block" then
			table.insert(self._blockList, vNode)
		end
		if vNode.tag == "Function" then
			table.insert(self._funcList, vNode)
		end
	end)
	table.sort(self._identList, function(a:node.Ident, b:node.Ident)
		return a.pos < b.pos
	end)
	table.sort(self._blockList, function(a:node.Block, b:node.Block)
		return a.pos < b.pos
	end)
	table.sort(self._funcList, function(a:node.Function, b:node.Block)
		return a.pos < b.pos
	end)
end

function.pass CodeEnv:visit(vFunc:Fn(node.IVisitor, node.IAstNode))
	const visitor = VisitorExtend(vFunc)
	visitor:realVisit(self._astOrErr)
end

function CodeEnv:binSearch@<TValue>(vList:List(TValue), vPos:Integer):Ret(False):Ret(Integer, TValue)
	if #vList <= 0 then
		return false
	end
	if vPos < vList[1]!.pos then
		return false
	end
	local nLeft = 1
	local nRight = #vList
	local count = 0
	while nRight > nLeft do
		count = count + 1
		local nMiddle = (nLeft + nRight) // 2
		local nMiddle1 = nMiddle + 1
		if vPos < vList[nMiddle]!.pos then
			nRight = nMiddle - 1
		elseif vPos >= vList[nMiddle1]!.pos then
			nLeft = nMiddle1
		else
			nLeft = nMiddle
			nRight = nMiddle
		end
	end
	return nLeft, vList[nLeft]!
end

-- pos to line & column
function CodeEnv:fixupPos(vPos:Integer, vNode:OrNil(node.IAstNode)):Ret(Integer, Integer)
	local line, lineInfo = self:binSearch@<Struct {pos=Integer, posEnd=Integer}>(self._linePosList, vPos)
	if not line or not lineInfo then
		print("warning pos out of range, pos="..vPos) --, vNode and vNode.tag)
		return 1, 1
	else
		return line, vPos - lineInfo.pos + 1
	end
end

function CodeEnv:_init()
	const nSubject = self._subject
	const nList = self._linePosList
	-- 1. calc line pos
	local nStartPos = 1
	local nFinishPos:OrNil(Integer) = 0
	local nLineCount = 0
	while true do
		nLineCount = nLineCount + 1
		nFinishPos = nSubject:find("\n", nStartPos)
		if nFinishPos then
			nList[#nList + 1] = {
				pos=nStartPos,
				posEnd=nFinishPos
			}
			nStartPos = nFinishPos + 1
		else
			if nStartPos <= #nSubject then
				nList[#nList + 1] = {
					pos=nStartPos,
					posEnd=#nSubject
				}
			end
			break
		end
	end
	const nAst, nErr = ParseEnv.parse(self._subject)
	if not nAst then
		self._astOrErr = nErr
	else
		self._astOrErr = nAst
	end
end

function.pass CodeEnv:_genTypingCode():Ret(String)
	local nAstOrErr = self._astOrErr
	if nAstOrErr.tag == "Error" then
		nAstOrErr.l, nAstOrErr.c = self:fixupPos(nAstOrErr.pos, nAstOrErr)
		nAstOrErr.path = self._chunkName
		Node.bind(nAstOrErr)
		error(Exception.new(nAstOrErr[1], nAstOrErr))
		nAstOrErr = nAstOrErr[2]
		self._astOrErr = nAstOrErr
	end
	self:prepare()
	const nSymbolVisitor = SymbolVisitor.new(self)
	nSymbolVisitor:realVisit(self:getAstTree())
	const gener = HintGener.new(nAstOrErr)
	return gener:genCode()
end

function.pass CodeEnv:_buildTypingFn()
	local ok, fnOrErr = pcall(function ()
		local nTypingCode = self:_genTypingCode()
		self._typingCode = nTypingCode
		local nFunc, nInfo = load(nTypingCode, self._chunkName, "t", setmetatable({}, {
			__index=function(t,k)
				-- TODO, give node pos
				error("indexing global is fatal error, name="..k)
			end
		}))
		if not nFunc then
			error(nInfo)
		end
		assert(type(nFunc) == "function", "typing code must return function")
		if not nFunc then
			-- TODO, give node pos
			error(nInfo)
		end
		return nFunc
	end)
	if ok then
		self._typingFn = fnOrErr
	else
		if Exception.is(fnOrErr) then
			self._typingFn = fnOrErr
		else
			self._typingFn = tostring(fnOrErr)
		end
	end
end

function.pass CodeEnv:checkOkay():Ret(True):Ret(False, clazz.Exception)
	if self._astOrErr.tag == "Error" then
		return false, Exception.new(self._astOrErr[1], self._astOrErr)
	elseif type(self._typingFn) == "string" then
		return false, Exception.new(self._typingFn, self:makeErrNode(1, ""))
	elseif Exception.is(self._typingFn) then
		return false, self._typingFn
	else
		return true
	end
end

function CodeEnv:getNodeList():Ret(List(clazz.IAstNode))
	return self._nodeList
end

function CodeEnv:getAstTree()
	return self._astOrErr
end

function CodeEnv:getTypingCode()
	return self._typingCode
end

function.pass CodeEnv:getTypingFn():Ret(Fn(List(clazz.IAstNode), clazz.BaseStack, clazz.RefineTerm):Ret(clazz.OpenFunction))
	return self._typingFn
end

function CodeEnv:searchScopeByTrace(vList:List(Integer)):Ret(node.Block)
	local nScope = self._rootScope
	assert(nScope, "scope not setted")
	for i=1,#vList-1 do
		const nTrace = vList[i]!
		nScope = nScope.scope_children[nTrace]!
	end
	return nScope
end

function CodeEnv:searchNameByError(vErrorNode:node.Error):Ret(OrNil(node.Ident_def))
	local nErrExpr = vErrorNode[2]
	if not nErrExpr or nErrExpr.tag ~= "Ident" then
		-- other typp TODO
		return nil
	end
	return nil
	--[[
	local nTraceList = vErrorNode[3]!
	local nPos = nErrExpr.pos
	local nScope = self:searchScopeByTrace(nTraceList)
	local nName = nErrExpr[1]
	local nIdent = nScope.symbolTable[nName]
	while nIdent and nIdent.pos > nPos do
		nIdent = nIdent.lookupIdent
	end
	return nIdent]]
end

function CodeEnv:traceBlock(vPos:Integer):Ret(False):Ret(node.Block, List(node.Function))
	local nRetBlock:OrFalse(node.Block) = false
	for _, nBlock in ipairs(self._blockList) do
		if nBlock.pos <= vPos and vPos <= nBlock.posEnd then
			nRetBlock = nBlock
			break
		end
	end
	if not nRetBlock then
		return false
	else
		const nList:List(node.Function) = {}
		local nCurFunc:OrNil(node.IAstNode) = nRetBlock
		while nCurFunc do
			if nCurFunc.tag == "Function" and vPos < nCurFunc.posEnd then
				nList[#nList + 1] = nCurFunc @> node.Function
			end
			nCurFunc = nCurFunc.parent
		end
		return nRetBlock, nList
	end
end

function CodeEnv:searchBlock(vPos:Integer):Ret(OrNil(node.Block))
	for _, block in ipairs(self._blockList) do
		if block.pos <= vPos and vPos <= block.posEnd then
			return block
		end
	end
	return nil
end

function CodeEnv:lookupDefineIdent(vPos:Integer, vName:String):Ret(OrNil(node.Ident_def))
	const nIndex, nBlock = self:binSearch@<node.Block>(self._blockList, vPos)
	if not nIndex then
		return nil
	else
		local nIdent = nBlock.symbolTable[vName]
		while nIdent and nIdent.pos > vPos do
			nIdent = nIdent.lookupIdent
		end
		return nIdent
	end
end

function CodeEnv:searchIdent(vPos:Integer):Ret(OrNil(node.Ident))
	const nIndex, nNode = self:binSearch@<node.Ident_def>(self._identList, vPos)
	if not nIndex then
		return nil
	end
	if vPos >= nNode.pos + #nNode[1] or vPos > nNode.posEnd then
		return nil
	end
	return nNode
end

function CodeEnv:getContent():Ret(String)
	return self._subject
end

function CodeEnv:getVersion():Ret(Integer)
	return self._version
end

function CodeEnv:getChunkName():Ret(String)
	return self._chunkName
end

function.open CodeEnv.is(v):isguard(clazz.CodeEnv)
	return getmetatable(v) == CodeEnv
end

return CodeEnv
