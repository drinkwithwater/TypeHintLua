
(@do

let.node = import("thlua.code.Node").node
let.class = import("thlua.type.TypeClass").class

let.GenResult = Struct {
	node = OrNil(node.IAstNode),
	[Integer] = let.UGenResult,
}

let.UGenResult = Union(String, Integer, let.GenResult)

let.RealTraverser = Struct((function()
	local t = {}
	foreachPair(node.TagToNodeType, function(vTag, vNodeType)
		t[vTag] = OrNil(Fn(let.HintGener, vNodeType):Ret(let.UGenResult))
	end)
	return t
end)())

end)

local TagToVisiting:RealTraverser = {
	Chunk=function(self, node)
		const nParPrint = self:formatParListInFuncHead(node[2])
		return {
			"local ____ctx, ____nodes=... ",
			"local ____s__ENV"..node[1].index, "=____ctx:makeSymbol_ENV(", self:codeNode(node[1]),") ",

			"local ____fn,____uv ____fn,____uv=____ctx:FUNC_NEW(", self:codeNode(node), ",", self:visitLongHint(nil), ",", nParPrint, ",", tostring(node.retFlag), ", function(____newCtx, vArgTuple) ",
			"local ____ctx,____rgn,let,_ENV=____newCtx,____newCtx:BEGIN(____ctx,", self:codeNode(node), ", ____fn,____uv) ",
			"local vDOTS=____ctx:TUPLE_UNPACK(", self:codeNode(node),",vArgTuple,0,true)",
			self:visit(node[3]),
			"end) return ____fn",
		}
	end,
	Block=function(self, node)
		const nParentTag = node.parent!.tag
		const nAppendReturn = nParentTag == "Function" or nParentTag == "Chunk"
		return {
			self:forList(node, function(i, vStatNode)
				return self:visit(vStatNode)
			end, " "),
			nAppendReturn and "return "..self:codeRgn(node, "END")..") " or nil,
		}
	end,
	Do=function(self, node)
		return {
			node=node,
			" do ", self:visit(node[1]), " end "
		}
	end,
	Set=function(self, node)
		return {
			node=node,
			" local ", self:forList(node[1], function(i,v)
				return "set_a"..i
			end),
		}
	end,
	While=function(self, node)
		return {
			"local while_a=", self:visit(node[1]), " ",
			self:codeRgn(node, "WHILE"), ",while_a, function() ",
			self:visit(node[2]),
			"end) "
		}
	end,
	Repeat=function(self, node)
		print("RepeatStat TODO")
		return {}
	end,
	If=function(self, node)
		const function put(exprNode:node.Expr, blockNode:node.Block, nextIndex:Integer, level:Integer)::Ret(let.UGenResult)
			const nCondition:let.GenResult = {
				"local if_a"..level.."=",
				self:visit(exprNode), " ",
				self:codeRgn(node, "IF"), ",if_a"..level..", function() ",
				self:visit(blockNode),
				" end",
			}
			const nNext1Node, nNext2Node = node[nextIndex], node[nextIndex + 1]
			if nNext1Node then
				if nNext2Node then
					assert(nNext1Node.tag ~= "Block" and nNext2Node.tag == "Block", "if statement error")
					return {
						nCondition, ",function()",
						put(nNext1Node, nNext2Node, nextIndex + 2, level + 1),
						")"
					}
				else
					assert(nNext1Node.tag == "Block")
					return {
						nCondition, ",function()",
						self:visit(nNext1Node),
						") "
					}
				end
			else
				return {nCondition, ")"}
			end
		end
		const nExpr, nBlock = node[1]!, node[2]!
		assert(nExpr.tag ~= "Block" and nBlock.tag == "Block", "if statement error")
		return put(nExpr, nBlock, 3, 1)
	end,
	Fornum=function(self, node)
		const nHasStep = node[5] and true or false
		const nBlockNode = node[5] or node[4]
		assert(nBlockNode.tag == "Block", "4th or 5th node must be block")
		return {
			"local fornum_r1, fornum_r2, fornum_r3 = ",
			self:visit(node[2]), ",", self:visit(node[3]), ",", nHasStep and self:visit(node[4]) or "nil", " ",
			self:codeRgn(node, "FOR_NUM"), ",function(fornum_i) ",
			self:visitSymbolNew(node[1], "fornum_i"),
			self:visit(nBlockNode),
			"end, fornum_r1, fornum_r2, fornum_r3) "
		}
	end,
	Forin=function(self, node)
		return {
			"local forin_next, forin_self, forin_init = ",
			self:codeCtx(node, "EXPLIST_UNPACK"), ",3,", self:visit(node[2]), ") ",
			self:codeRgn(node, "FOR_IN"), ",function(vIterTuple) ",
			"\tlocal ", self:forList(node[1], function(i, vNode)
				return "forin_gen"..i
			end),
			"=", self:codeCtx(node, "TUPLE_UNPACK"), ",vIterTuple,", #node[1], ",false) ",
			self:forList(node[1], function(i, vNode)
				const nIdent = vNode @ node.Ident_def
				return self:visitSymbolNew(nIdent, "forin_gen"..i)
			end),
			self:visit(node[3]),
			"end, forin_next, forin_self, forin_init) "
		}
	end,
	Local=function(self, node)
		return {
			"local ", self:forList(node[1], function(i, vNode)
				return "local_a"..i
			end),
			"=", self:codeCtx(node, "EXPLIST_UNPACK"), ","..#node[1]..",",
			#node[2] > 0 and self:visit(node[2]) or "nil",
			") ",
			self:forList(node[1], function(i, vNode)
				const nIdent = vNode @ node.Ident_def
				return self:visitSymbolNew(nIdent, "local_a"..i)
			end)
		}
	end,
	Localrec=function(self, node)
		return self:visitSymbolNew(node[1], node[2])
	end,
	Goto=function()
		print("--goto TODO")
		return {}
	end,
	Label=function()
		print("--label TODO")
		return {}
	end,
	Return=function(self, node)
		return {
			self:codeRgn(node, "RETURN"), ",", self:codeCtx(node, "EXPLIST_PACK"), ",false, {",
				self:visit(node[1]),
			"}))"
		}
	end,
	Break=function(self, node)
		return {
			" ", self:codeRgn(node, "BREAK"), ") "
		}
	end,
	Call=function(self, node)
		return self:ctxAutoUnpack(node, {
			self:codeCtx(node, "META_CALL"), ",",
			self:visit(node[1]), ",",
			self:codeCtx(node, "EXPLIST_PACK"), ",true, {",
				#node[2] > 0 and self:visit(node[2]) or "",
			"}))",
		})
	end,
	Invoke=function(self, node)
		return self:ctxAutoUnpack(node, {
			self:codeCtx(node, "META_INVOKE"), ",",
			self:visit(node[1]), ",",
			"\""..node[2][1].."\"", ",",
			self:codeCtx(node, "EXPLIST_PACK"), ",false, {",
				#node[3] > 0 and self:visit(node[3]) or "",
			"}))",
		})
	end,
	HintStat=function(self, node)
		-- self:print("local block = function(self) ", node[1], " end block(self)\n")
		return {
			" ", node[1].script, " "
		}
	end,
	Nil=function(self, node)
		return "____ctx:NilTerm()"
	end,
	Dots=function(self, node)
		return self:ctxAutoUnpack(node, "vDOTS")
	end,
	True=function(self, node)
		return "____ctx:BooleanTerm(true)"
	end,
	False=function(self, node)
		return "____ctx:BooleanTerm(false)"
	end,
	Number=function(self, node)
		return {
			"____ctx:LiteralTerm(", tostring(node[1]), ")"
		}
	end,
	String=function(self, node)
		const s = node[1]
		return {
			"____ctx:LiteralTerm",
			node.isLong and '([[' .. s .. ']])' or '(' .. string.format("%q", s),
			')'
		}
	end,
	Function=function(self, node)
		-- TODO
		return {}
	end,
	Table=function(self, node)
		local count = 0
		local tailDots:OrNil(node.UTupleExpr) = nil
		for i, nItem in ipairs(node) do
			if nItem.tag ~= "Pair" then
				count = count + 1
				const nExprTag = nItem.tag
				if i==#node and (nExprTag == "Dots" or nExprTag == "Invoke" or nExprTag == "Call") then
					tailDots = nItem
				end
			end
		end
		return {
			"____ctx:RefineTerm(____ctx:TABLE_NEW(", self:codeNode(node), ",",
			self:visitLongHint(node.hintLong), ", function() return {",
			self:forList(node, function(i, vNode)
				const nTableItem = vNode @ Union(node.Pair, node.Expr)
				if nTableItem.tag == "Pair" then
					return {
						"{", self:visit(nTableItem[1]), ",", self:visit(nTableItem[2]), "}"
					}
				else
					if i==#node and tailDots then
						return "nil"
					else
						return {
							"{",
								"____ctx:LiteralTerm("..count..")",
								",",
								self:visit(nTableItem),
							"}"
						}
					end
				end
			end, ","),
			"},", count, ",", tailDots and self:visit(tailDots) or "nil", ", end)) "
		}
	end,
	Op=function(self, node)
		const nLogicOpSet:Dict(String, Integer) = {["or"]=1,["not"]=1,["and"]=1}
		const nOper = node[1]
		if nLogicOpSet[nOper] then
			if nOper == "not" then
				return {
					self:codeRgn(node, "LOGIC_NOT"), ",",
					self:visit(node[2]), ")"
				}
			else
				return {
					self:codeRgn(node, "LOGIC_"..node[1]:upper()), ",",
					self:visit(node[2]), ",",
					"function() return ", self:visit(node[3]!), " end)"
				}
			end
		else
			const nRight = node[3]
			if not nRight then
				return {
					self:codeCtx(node, "META_UOP"), ",\"", node[1], "\",",
					self:visit(node[2]), ")"
				}
			elseif node[1] == "==" then
				return {
					self:codeCtx(node, "META_EQ_NE"), ",true,",
					self:visit(node[2]), ",",
					self:visit(nRight), ")"
				}
			elseif node[1] == "~=" then
				return {
					self:codeCtx(node, "META_EQ_NE"), ",false,",
					self:visit(node[2]), ",",
					self:visit(nRight), ")"
				}
			else
				return {
					self:codeCtx(node, "META_BOP_SOME"), ",\"", node[1], "\",",
					self:visit(node[2]), ",",
					self:visit(nRight), ")"
				}
			end
		end
	end,
	Paren=function(self, node)
		local nHintShort = node.hintShort
		if nHintShort then
			return {
				"____ctx:HINT(", self:codeNode(node), ",",
				"(", self:visit(node[1]), ")",
				",", self:fixShort(nHintShort), ")"
			}
		else
			return {"(", self:visit(node[1]), ")"}
		end
	end,
	Ident=function(self, node)
		assert(node.kind ~= "def")
		const nDefineId = node.defineIdent
		const symbol = "____s_"..nDefineId[1]..nDefineId.index
		if node.isSet then
			return symbol
		else
			const nParent = node.parent!
			const nParentTag = nParent.tag
			const nParentParentTag = nParent.parent!.tag
			const nLazyEval = nParentTag == "ExprList" and (nParentParentTag == "Invoke" or nParentParentTag == "Call")
			return {
				nLazyEval and " function() return " or "",
				self:codeRgn(node, "SYMBOL_GET"), ",", symbol, ")",
				nLazyEval and " end " or "",
			}
		end
	end,
	Index=function(self, node)
		return {
			self:codeCtx(node, "META_GET"), ",",
			self:visit(node[1]), ",",
			self:visit(node[2]), ",",
			tostring(node.notnil or false),
			")"
		}
	end,
	ExprList=function(self, node)
		return self:forList(node, function(i, expr)
			return self:visit(expr)
		end, ",")
	end,
	ParList=function(self, node)
		return self:forList(node, function(i, vNode)
			const nParNode = vNode @ Union(node.Ident_use, node.Dots)
			return nParNode.tag == "Ident" and "v_"..nParNode[1]..nParNode.index or "vDOTS"
		end, ",")
	end,
	VarList=function(self, node)
		return self:forList(node, function(i, varNode)
			return self:visit(varNode)
		end, ",")
	end,
	IdentList=function(self, node)
		return self:forList(node, function(i, identNode)
			return self:visit(identNode)
		end, ",")
	end,
}

const HintGener = {}
HintGener.__index = HintGener

function HintGener:visit(vNode:node.IAstNode)::Ret(let.UGenResult)
	const nUnionNode = vNode @ node.UNodeType
	const fn = TagToVisiting[nUnionNode.tag]
	if fn then
		return fn(self, nUnionNode)
	else
		return ""
	end
end

function HintGener:fixShort(vHintInfo:node.IHintInfo)::Ret(String)
	return (vHintInfo.script:gsub("\n", " "))
end

(@do
	let.UFormatList = List(Union(Integer, String, node.IAstNode, Fn():Ret(let.UFormatList)))
end)

function HintGener:codeNode(vNode:node.IAstNode)::Ret(String)
	return "____nodes["..vNode.index.."]"
end

function HintGener:codeRgn(vNode:node.IAstNode, vName:String)::Ret(String)
	return "____rgn:"..vName.."("..self:codeNode(vNode)
end

function HintGener:formatIdentDef(vIdentNode:node.Ident_def)::Ret(String)
	return "____s_"..vIdentNode[1]..vIdentNode.index
end

function HintGener:visitSymbolNew(vIdentNode:node.Ident_def, vValue:Union(String, node.Function), vNoHint:OrNil(True))::Ret(let.UGenResult)
	if type(vValue) == "string" then
		const nHintShort = vIdentNode.hintShort
		return {
			" local ", self:formatIdentDef(vIdentNode), "=____rgn:SYMBOL_NEW(",
				self:codeNode(vIdentNode), ",",
				string.format("%q", vIdentNode.symbolKind), ",",
				vValue, ",",
				vNoHint and "nil" or (nHintShort and nHintShort.script or "nil"),
			")"
		}
	else
		const nIdentFormat = self:formatIdentDef(vIdentNode)
		return {
			" local ", nIdentFormat, " ", nIdentFormat, "=____rgn:SYMBOL_NEW(",
				self:codeNode(vIdentNode), ",",
				string.format("%q", vIdentNode.symbolKind), ",",
				self:visit(vValue),
			")"
		}
	end
end

function HintGener:codeCtx(vNode:node.IAstNode, vName:String)::Ret(String)
	return "____ctx:"..vName.."("..self:codeNode(vNode)
end

function HintGener:ctxAutoUnpack(vNode:node.UTupleExpr, vInner:let.UGenResult)::Ret(let.UGenResult)
	const nParent = vNode.parent!
	local nAutoUnpack = true
	if nParent.tag == "ExprList" or nParent.tag == "ParList" or nParent.tag == "Block" then
		nAutoUnpack = false
	elseif nParent.tag == "Table" and nParent[#nParent] == vNode then
		-- table tail not autoUnpack
		nAutoUnpack = false
	end
	if nAutoUnpack then
		return {
			self:codeCtx(vNode, "EXPLIST_UNPACK"), ",1,", vInner, ")"
		}
	else
		return vInner
	end
end

function HintGener:formatParListInFuncHead(vParList:node.ParList)::Ret(String)
	const nParHintList:List(String) = {}
	local nDotsHintScript:OrFalse(String) = false
	for i=1, #vParList do
		local nParNode = vParList[i]!
		const nHintShort = nParNode.hintShort
		if nParNode.tag == "Dots" then
			if nHintShort then
				nDotsHintScript = self:fixShort(nHintShort)
			else
				nDotsHintScript = "____ctx:Variable(false)"
			end
		else
			if nHintShort then
				nParHintList[#nParHintList + 1] = self:fixShort(nHintShort)
			elseif nParNode.isSelf then
				nParHintList[#nParHintList + 1] = "____ctx:Variable(true)"
			else
				nParHintList[#nParHintList + 1] = "____ctx:Variable(false)"
			end
		end
	end
	local nParPrint = "____ctx:AutoArguments("..self:codeNode(vParList)..",{" .. table.concat(nParHintList, ",")
	if not nDotsHintScript then
		nParPrint = nParPrint .. "})"
	else
		nParPrint = nParPrint .. "},"..nDotsHintScript..") "
	end
	--[[if #vParList > 0 then
		const l:List(String) = {}
		for i=1, #vParList do
			const nParNode = vParList[i]!
			if nParNode.tag == "Ident" then
				l[#l+1] = "v_"..nParNode[1]..nParNode.index
			else
				l[#l+1] = "vDOTS"
			end
		end
		const nHasDots = vParList[#vParList]!.tag == "Dots"
		const l = {
			" local ", table.concat(l), "=", self:codeCtx(vParList, "TUPLE_UNPACK"), ", vArgTuple, ",
			nHasDots and tostring(#vParList-1) or tostring(#vParList),
			nHasDots and ", true)" or ", false)",
		}
	end]]
	return nParPrint
end

function HintGener:visitLongHint(vHintInfo:OrNil(node.IHintInfo))::Ret(let.UGenResult)
	return {
		" function(____longHint) return ____longHint",
			(vHintInfo and vHintInfo.script or "") ,
		" end "
	}
end

function HintGener:FUNC_NEW(vNode:Union(node.Function, node.Chunk),
	vLongHint:OrNil(node.IHintInfo), vParList:node.ParList, vRetFlag:Boolean,
	vBlockNode:node.Block)::Ret(let.UGenResult)
	const nParList = vNode.tag == "Chunk" and vNode[2] or vNode[1]
	local nDotsHintScript:OrFalse(String) = false
	const nParInHead = self:forList(vParList, function(i, vNode)
		const nParNode = vNode @ Union(node.Dots, node.Ident_def)
		const nHintShort = nParNode.hintShort
		if nParNode.tag == "Dots" then
			nDotsHintScript = nHintShort and self:fixShort(nHintShort) or "____ctx:Variable(false)"
			return "nil"
		else
			return nHintShort and self:fixShort(nHintShort)
				or (nParNode.isSelf and "____ctx:Variable(true)" or "____ctx:Variable(false)")
		end
	end, ", ")
	const nParInBody = self:forList(vParList, function(i, vNode)
		const nParNode = vNode @ Union(node.Dots, node.Ident_def)
		if nParNode.tag ~= "Dots" then
			return self:visitSymbolNew(nParNode, "v_"..nParNode[1]..nParNode.index, true)
		end
	end)
	return {
			"local ____fn,____uv ",
			"____fn,____uv=____ctx:FUNC_NEW(",
				self:codeNode(vNode), ",",
				self:visitLongHint(vLongHint), ",",
				"___ctx:AutoArguments("..self:codeNode(vParList)..",{",
					nParInHead,
				"},", tostring(nDotsHintScript), ")",
				tostring(vRetFlag), ",
				function(____newCtx, vArgTuple) ",
					"local ____ctx,____rgn,let,_ENV=____newCtx,____newCtx:BEGIN(____ctx,", self:codeNode(vNode), ", ____fn,____uv) ",
					"local vDOTS=____ctx:TUPLE_UNPACK(", self:codeNode(vNode),",vArgTuple,0,true)",
					self:visit(vBlockNode),
				"end) ",
			"return ____fn",
	}
end

function HintGener:forList(
	vList:IList(node.IAstNode),
	vFunc:Fn(Integer, node.IAstNode):Ret(let.UGenResult),
	vSep:OrNil(String)
	)::Ret(let.GenResult)
	const nResult:let.GenResult = {}
	const nLen = #vList
	for i=1,nLen do
		nResult[#nResult + 1] = vFunc(i, vList[i]!)
		nResult[#nResult + 1] = i~=nLen and vSep or nil
	end
	return nResult
end

function HintGener.new()::RetClass(let.HintGener)
	const self = setmetatable({::Self()
		buffer_list = {} @List(String),
		indent_count = 0 @Integer,
		line = 1 @ Integer,
	}, HintGener)
	return self
end

function HintGener:genCode(vNode:node.IAstNode)::Ret(String)
	const l:List(String) = {}
	const function recurAppend(vResult:let.UGenResult)
		if type(vResult) == "table" then
			for _, v in ipairs(vResult) do
				recurAppend(v)
			end
		else
			l[#l+1] = tostring(vResult)
		end
	end
	recurAppend(self:visit(vNode))
	return table.concat(l)
end

return HintGener
