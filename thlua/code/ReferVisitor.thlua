
const VisitorExtend = require "thlua.code.VisitorExtend"

const Exception = require "thlua.Exception"
const CodeEnv = require "thlua.code.CodeEnv"

(@do

let.node = import("thlua.code.Node").node
let.class = import("thlua.type.TypeClass").class

let.RealTraverser = Struct((function()
	local t = {}
	foreachPair(node.AllNodeType, function(vTag, vNodeType)
		if not vNodeType:getResultType():isUnion() then
			t[vTag] = OrNil(Fn(let.ReferVisitor, vNodeType))
		end
	end)
	return t
end)())

end)

local TagToVisiting:let.RealTraverser = {
	Do=function(self, stm)
		self:scopeBegin(stm[1])
		self:rawVisit(stm)
		self:scopeEnd()
	end,
	While=function(self, stm)
		self:scopeBegin(stm[2])
		self:rawVisit(stm)
		self:scopeEnd()
	end,
	Repeat=function(self, stm)
		self:scopeBegin(stm[1])
		self:rawVisit(stm)
		self:scopeEnd()
	end,
	-- some complicate node
	Fornum=function(self, stm)
		local nBlockNode:OrNil(node.Block) = nil
		self:realVisit(stm[2])
		self:realVisit(stm[3])
		if stm[5] then
			self:realVisit(stm[4])
			nBlockNode = stm[5]!
		else
			const nChild4 = stm[4]
			assert(nChild4.tag == "Block", "node must be block here")
			nBlockNode = nChild4
		end
		self:scopeBegin(nBlockNode)
		self.define_pos = true
		self:realVisit(stm[1])
		self.define_pos = false
		self:realVisit(nBlockNode)
		self:scopeEnd()
	end,
	Forin=function(self, stm)
		local block_node = stm[3]
		self:realVisit(stm[2])
		self:scopeBegin(block_node)
		self.define_pos = true
		self:realVisit(stm[1])
		self.define_pos = false
		self:realVisit(block_node)
		self:scopeEnd()
	end,
	Function=function(self, func)
		local block_node = func[2]
		self:scopeBegin(block_node, func)
		self.define_pos = true
		self:realVisit(func[1])
		self.define_pos = false
		self:realVisit(block_node)
		self:scopeEnd()
	end,
	If=function(self, node)
		for i, subNode in ipairs(node) do
			if subNode.tag == "Block" then
				self:scopeBegin(subNode)
				self:realVisit(subNode)
				self:scopeEnd()
			else
				self:realVisit(subNode)
			end
		end
	end,
	Block=function(self, stm)
		local nCurScope = self.scope_stack[#self.scope_stack]!
		stm.scope_refer = nCurScope.scope_refer
		self:rawVisit(stm)
	end,
	Local=function(self, stm)
		local nNameList = stm[1]
		if stm.isConst then
			for i, name in ipairs(nNameList) do
				name.isConst = true
			end
		end
		self:realVisit(stm[2])
		self.define_pos = true
		self:realVisit(nNameList)
		self.define_pos = false
	end,
	Set=function(self, stm)
		local nVarList = stm[1]
		for i=1, #nVarList do
			local var = nVarList[i]!
			if var.tag == "Id" then
				var.isSet = true
			end
		end
		self:rawVisit(stm)
	end,
	Localrec=function(self, stm)
		if stm.isConst then
			stm[1].isConst = true
		end
		self.define_pos = true
		self:realVisit(stm[1])
		self.define_pos = false
		self:realVisit(stm[2])
	end,
	Dots=function(self, node)
		if self.define_pos then
			self:dotsDefine(node)
		else
			self:dotsUse(node)
		end
	end,
	Id=function(self, node)
		if self.define_pos then
			self:symbolDefine(node)
		else
			self:symbolUse(node)
		end
	end,
	Chunk=function(self, chunk)
		self:record_ENV(chunk[1])
		const nBlockNode = chunk[3]
		self:scopeBegin(nBlockNode, chunk)
		self.define_pos = true
		self:realVisit(chunk[2])
		self.define_pos = false
		self:realVisit(nBlockNode)
		self:scopeEnd()
	end,
}

const ReferVisitor = VisitorExtend(TagToVisiting)

function ReferVisitor:scopeBegin(vBlockNode:node.Block, vFuncOrChunk:OrNil(node.URegionNode))
	local nCurScope = self.scope_stack[#self.scope_stack]
	assert(vBlockNode.tag == "Block", "node tag must be Block but get "..tostring(vBlockNode.tag))
	self:recordScope(nCurScope, vBlockNode)
	table.insert(self.scope_stack, vBlockNode)
	if vFuncOrChunk then
		vBlockNode.is_region = true
		table.insert(self.region_stack, vFuncOrChunk)
		vBlockNode.region_node = vFuncOrChunk
		self:recordRegion(vFuncOrChunk)
	else
		vBlockNode.region_node = self.region_stack[#self.region_stack]!
	end
end

function ReferVisitor:scopeEnd()
	const nScope = table.remove(self.scope_stack)
	assert(nScope, "scope can't be nil here")
	if nScope.is_region then
		table.remove(self.region_stack)
	end
end

function ReferVisitor:symbolDefine(vIdentNode:node.Id)
	-- create and set ident_refer
	local nCurScopeOrNil = self.scope_stack[#self.scope_stack]!
	self:recordSymbol(nCurScopeOrNil, vIdentNode)
end

function ReferVisitor:dotsDefine(vDotsNode:node.Dots)
	local nCurRegion = self.region_stack[#self.region_stack]!
	nCurRegion.symbol_dots = vDotsNode
end

function ReferVisitor:dotsUse(vDotsNode)
	assert(vDotsNode.tag == "Dots")
	local nCurRegion = self.region_stack[#self.region_stack]!
	local nDotsDefine = nCurRegion.symbol_dots
	if not nDotsDefine then
		local nErrNode = self._env:makeErrNode(vDotsNode.pos, "cannot use '...' outside a vararg function")
		error(Exception.new(nErrNode[1], nErrNode))
	end
end

function ReferVisitor:idToIndex(vIdentNode)
	const e1 = {tag="Id", pos=vIdentNode.pos, posEnd=vIdentNode.pos, "_ENV"}
	e1.ident_refer = 1
	const e2 = {tag="String", pos=vIdentNode.pos, posEnd=vIdentNode.posEnd, vIdentNode[1]}
	vIdentNode.tag = "Index"
	vIdentNode[1] = e1
	vIdentNode[2] = e2
end

function ReferVisitor:symbolUse(vIdentNode:node.Id)
	assert(not vIdentNode.ident_refer, "ident_refer has been setted")
	local nCurScope = self.scope_stack[#self.scope_stack]!
	assert(vIdentNode.tag == "Id")
	local nName = vIdentNode[1]
	local nDefineNode = nCurScope.symbol_ident_dict[nName]
	if nDefineNode then
		const nDefineScope = self._scopeList[nDefineNode.scope_refer]!
		vIdentNode.ident_refer = nDefineNode.ident_refer
		if vIdentNode.isSet then
			if nDefineNode.isConst then
				local nErrNode = self._env:makeErrNode(vIdentNode.pos, "cannot assign to const variable '"..vIdentNode[1].."'")
				error(Exception.new(nErrNode[1], nErrNode))
			end
			nDefineNode.isMutable = true
		end
		local nStackLen = #self.region_stack
		if nDefineScope.region_node ~= self.region_stack[nStackLen] then
			vIdentNode.isUpValue = true
			for i=nStackLen,1,-1 do
				const nDownRegion = self.region_stack[i]!
				if nDefineScope.region_node == nDownRegion then
					break
				else
					table.insert(nDownRegion.uv_list, vIdentNode)
				end
			end
		end
	else
		self:idToIndex(vIdentNode)
	end
end

function ReferVisitor.new(vFileEnv:class.CodeEnv)::RetClass(let.ReferVisitor)
	local self = setmetatable({::Self()
		_env = vFileEnv,
		scope_stack={}@List(node.Block),
		region_stack={}@List(node.URegionNode),
		define_pos=false@Boolean,
		_identList={}@List(node.Id),
		_scopeList={}@List(node.Block),
		_regionList={}@List(node.URegionNode),
		_rootScope=false@OrFalse(node.Block),
	}, ReferVisitor)
	return self
end

function ReferVisitor:record_ENV(vIdentNode:node.Id)
	assert(#self._identList == 0, "_ENV must be first identity")
	assert(vIdentNode[1] == "_ENV", "only _ENV can be used in this function")
	self._identList[1] = vIdentNode
	vIdentNode.ident_refer = 1
	vIdentNode.scope_refer = 0
	vIdentNode.is_define = true
end

function ReferVisitor:recordSymbol(vCurScope:node.Block, vIdentNode:node.Id)
	assert(vIdentNode.tag == "Id")
	local nNewIndex = #self._identList + 1
	vIdentNode.ident_refer = nNewIndex
	vIdentNode.scope_refer = vCurScope.scope_refer
	vIdentNode.is_define = true
	self._identList[nNewIndex] = vIdentNode
	local nName = vIdentNode[1]
	local nLookupNode = vCurScope.symbol_ident_dict[nName]
	vCurScope.symbol_ident_dict[nName] = vIdentNode
	vIdentNode.lookup_ident = nLookupNode
end

function ReferVisitor:recordScope(vCurScopeOrNil:OrNil(node.Block), vNode:node.Block)
	local nNewIndex = #self._scopeList + 1
	vNode.scope_refer = nNewIndex
	if vCurScopeOrNil then
		vNode.symbol_ident_dict = setmetatable({}, {
			__index=vCurScopeOrNil.symbol_ident_dict,
		})
		table.insert(vCurScopeOrNil.scope_children, vNode)
	else
		vNode.symbol_ident_dict = setmetatable({}, {
			__index={_ENV=self._identList[1]}
		})
		self._rootScope = vNode
	end
	vNode.scope_children = {}
	self._scopeList[nNewIndex] = vNode
end

function ReferVisitor:recordRegion(vNode:node.URegionNode)
	local nNewIndex = #self._regionList + 1
	vNode.region_refer = nNewIndex
	self._regionList[nNewIndex] = vNode
	vNode.uv_list = {}
end


return ReferVisitor
