
const VisitorExtend = require "thlua.code.VisitorExtend"
const Exception = require "thlua.Exception"
const Enum = require "thlua.Enum"

(@do

let.node = import("thlua.code.Node").node
let.clazz = import("thlua.type.TypeClass").clazz

let.RealTraverser = Struct((function()
	local t = {}
	foreachPair(node.TagToNodeType, function(vTag, vNodeType)
		t[vTag] = OrNil(Fn(let.SymbolVisitor, vNodeType))
	end)
	return t
end)())

end)

local TagToVisiting:let.RealTraverser = {
	Do=function(self, stm)
		const nHintLong = stm.hintLong
		if nHintLong then
			self:realVisit(nHintLong)
		end
		self:withScope(stm[1], nil, function()
			self:rawVisit(stm)
		end)
	end,
	Table=function(self, node)
		const nHintLong = node.hintLong
		if nHintLong then
			self:realVisit(nHintLong)
		end
		for i=1, #node do
			self:realVisit(node[i]!)
		end
	end,
	While=function(self, stm)
		self:withScope(stm[2], nil, function()
			self:rawVisit(stm)
		end)
	end,
	Repeat=function(self, stm)
		self:withScope(stm[1], nil, function()
			self:rawVisit(stm)
		end)
	end,
	-- some complicate node
	Fornum=function(self, stm)
		local nBlockNode = stm[5]
		self:realVisit(stm[2])
		self:realVisit(stm[3])
		if nBlockNode then
			self:realVisit(stm[4])
		else
			const nSubNode = stm[4]
			assert(nSubNode.tag == "Block", "node must be block here")
			nBlockNode = nSubNode
		end
		self:withScope(nBlockNode, nil, function()
			self:symbolDefine(stm[1], Enum.SymbolKind_ITER)
			-- self:realVisit(stm[1])
			-- TODO can't get block node's right type here, so assert this
			self:realVisit(assert(nBlockNode))
		end)
	end,
	Forin=function(self, stm)
		const nBlockNode = stm[3]
		self:realVisit(stm[2])
		self:withScope(nBlockNode, nil, function()
			for i, name in ipairs(stm[1]) do
				self:symbolDefine(name, Enum.SymbolKind_ITER)
			end
			self:realVisit(nBlockNode)
		end)
	end,
	Return=function(self, stm)
		local nFuncOrChunk = stm.parent
		while nFuncOrChunk and not (nFuncOrChunk.tag == "Function" or nFuncOrChunk.tag == "Chunk") do
			nFuncOrChunk = nFuncOrChunk.parent
		end
		if #stm[1] > 0 then
			assert (nFuncOrChunk and (nFuncOrChunk.tag == "Function" or nFuncOrChunk.tag == "Chunk"), "function or chunk must be here")
			const nFuncOrChunk = nFuncOrChunk @> Union(node.Function, node.Chunk)
			nFuncOrChunk.retFlag = true
		end
		self:rawVisit(stm)
	end,
	Function=function(self, func)
		const nHintLong = func.hintPrefix
		if nHintLong then
			self:realVisit(nHintLong)
		end
		const nBlockNode = func[2]
		self:withScope(nBlockNode, func, function()
			local nParFullHint = true
			for i, par in ipairs(func[1]) do
				if par.tag == "Ident" then
					self:symbolDefine(par, Enum.SymbolKind_PARAM)
					if not par.isSelf and not par.hintShort then
						nParFullHint = false
					end
				else
					self:dotsDefine(par)
					if not par.hintShort then
						nParFullHint = false
					end
				end
			end
			const nHintLong = func.hintSuffix
			if nHintLong then
				self:realVisit(nHintLong)
			end
			-- self:realVisit(func[1])
			self:realVisit(nBlockNode)
			const nPolyParList = func.hintPolyParList
			func.parFullHint = nParFullHint
			if not nParFullHint then
				if nPolyParList and #nPolyParList > 0 then
					-- const nErrNode = self._env:makeErrNode(func[1].pos, "poly function must be full-hint or self:full-hint")
					-- error(Exception.new(nErrNode[1], nErrNode))
				end
			else
				if not func.hintPolyParList then
					func.hintPolyParList = {}
				end
			end
		end)
	end,
	If=function(self, node)
		for i, subNode in ipairs(node) do
			if subNode.tag == "Block" then
				self:withScope(subNode, nil, function()
					self:realVisit(subNode)
				end)
			else
				self:realVisit(subNode)
			end
		end
	end,
	Block=function(self, stm)
		self:rawVisit(stm)
	end,
	Local=function(self, stm)
		local nIdentList = stm[1]
		self:realVisit(stm[2])
		-- self:realVisit(nIdentList)
		for i, name in ipairs(nIdentList) do
			self:symbolDefine(name, stm.isConst and Enum.SymbolKind_CONST or Enum.SymbolKind_LOCAL)
		end
	end,
	Set=function(self, stm)
		local nVarList = stm[1]
		for i=1, #nVarList do
			local var = nVarList[i]!
			if var.tag == "Ident" then
				self:symbolUse(var, true)
			end
		end
		self:rawVisit(stm)
	end,
	Localrec=function(self, stm)
		self:symbolDefine(stm[1], stm.isConst and Enum.SymbolKind_CONST or Enum.SymbolKind_LOCAL)
		self:realVisit(stm[2])
	end,
	Dots=function(self, node)
		self:dotsUse(node)
	end,
	Ident=function(self, node)
		assert(node.kind == "use")
		if node.isGetFrom ~= nil then -- not nil means this Ident has been setted by symbolUse
		else
			self:symbolUse(node, false)
		end
	end,
	Chunk=function(self, chunk)
		const nBlockNode = chunk[3]
		self:withScope(nBlockNode, chunk, function()
			self:symbolDefine(chunk[1], Enum.SymbolKind_LOCAL)
			for k, name in ipairs(chunk[2]) do
				if name.tag == "dots" then
					self:dotsDefine(name)
				end
			end
			self:realVisit(nBlockNode)
		end)
	end,
}

const SymbolVisitor = VisitorExtend(TagToVisiting)

function SymbolVisitor:withScope(vBlockNode:node.Block, vFuncOrChunk:OrNil(node.URegionNode), vFunc:Fn())
	assert(vBlockNode.tag == "Block", "node tag must be Block but get "..tostring(vBlockNode.tag))
	vBlockNode.scope_children = {}
	const nScopeStack = self._scopeStack
	const nStackLen = #nScopeStack
	if nStackLen > 0 then
		const nCurScope = nScopeStack[nStackLen]!
		vBlockNode.symbolTable = setmetatable({}, {
			__index=nCurScope.symbolTable,
		})
		table.insert(nCurScope.scope_children, vBlockNode)
	else
		vBlockNode.symbolTable = {}
	end
	table.insert(self._scopeStack, vBlockNode)
	if vFuncOrChunk then
		table.insert(self._regionStack, vFuncOrChunk)
		vFunc()
		table.remove(self._regionStack)
	else
		vFunc()
	end
	table.remove(self._scopeStack)
end

function SymbolVisitor:symbolDefine(vIdentNode:node.Ident_def, vImmutKind:node.SymbolKindEnum)
	const nHintShort = vIdentNode.hintShort
	if nHintShort then
		self:realVisit(nHintShort)
	end
	local nScope = self._scopeStack[#self._scopeStack]!
	vIdentNode.symbolKind = vImmutKind
	vIdentNode.symbolModify = false
	local nName = vIdentNode[1]
	local nLookupNode = nScope.symbolTable[nName]
	nScope.symbolTable[nName] = vIdentNode
	vIdentNode.lookupIdent = nLookupNode
end

function SymbolVisitor:dotsDefine(vDotsNode:node.Dots)
	local nCurRegion = self._regionStack[#self._regionStack]!
	nCurRegion.symbol_dots = vDotsNode
end

function SymbolVisitor:dotsUse(vDotsNode:node.Dots)
	const nCurRegion = self._regionStack[#self._regionStack]!
	const nDotsDefine = nCurRegion.symbol_dots
	if not nDotsDefine then
		error(Exception.new("cannot use '...' outside a vararg function", vDotsNode))
	end
end

function SymbolVisitor:symbolUse(vIdentNode:node.Ident_use, vIsAssign:Boolean)
	const nScope = self._scopeStack[#self._scopeStack]!
	const nDefineNode = nScope.symbolTable[vIdentNode[1]]
	if not nDefineNode then
		const nEnvIdent = nScope.symbolTable._ENV!
		vIdentNode.isGetFrom = nEnvIdent
		vIdentNode.defineIdent = false
		return
	end
	if vIsAssign then
		if nDefineNode.symbolKind == Enum.SymbolKind_CONST then
			error(Exception.new("cannot assign to const variable '"..vIdentNode[1].."'", vIdentNode))
		else
			nDefineNode.symbolModify = true
		end
		vIdentNode.isGetFrom = false
		vIdentNode.defineIdent = nDefineNode
	else
		vIdentNode.isGetFrom = true
		vIdentNode.defineIdent = nDefineNode
	end
end

function:class(let.SymbolVisitor) SymbolVisitor.new()
	const self = setmetatable({.class
		_scopeStack={}@List(node.Block),
		_regionStack={}@List(node.URegionNode),
	}, SymbolVisitor)
	return self
end

return SymbolVisitor
