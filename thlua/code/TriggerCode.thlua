
const ParseEnv = require "thlua.code.ParseEnv"
const CodeEnv = require "thlua.code.CodeEnv"

const class = require "thlua.class"

(@do
	let.clazz=import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
	let.InjectFn = Fn(clazz.BaseStack, Fn(node.Ident_use):Ret(clazz.RefineTerm)):Ret(Any)
end)

const TriggerCode = class@<clazz.TriggerCode, false>(CodeEnv)

function TriggerCode:lateInit()
	error("trigger code can't call late init")
end

function TriggerCode:tryGenInjectChunkFn():Ret(False, String):Ret(Union(node.Expr, node.ShortHintSpace), InjectFn, List(Integer))
	const nInjectTrace, nErr = ParseEnv.parse(self._content)
	if nInjectTrace then
		return false, "trigger by completion but not get any syntax error???"
	end
	const nInjectTrace = nErr[2]
	if not nInjectTrace then
		return false, "trigger by completion but get wrong error..."
	end
	const nCapture = nInjectTrace.capture
	self._astTree = nCapture
	const ok, err = pcall(function():Ret(InjectFn)
		(@do
			let.RawInjectFn = Fn(List(clazz.IAstNode), clazz.BaseStack, Fn(node.Ident_use):Ret(clazz.RefineTerm)):Ret(Any)
		end)
		const nRawInjectFn = self:_buildTypingFn() @> RawInjectFn
		return function(vStack, vGetter)
			return nRawInjectFn(self._nodeList, vStack, vGetter)
		end
	end)
	if ok then
		return assert(nCapture.injectNode), err, nInjectTrace.traceList
	else
		return false, tostring(err)
	end
end

return TriggerCode
