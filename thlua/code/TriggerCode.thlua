
const ParseEnv = require "thlua.code.ParseEnv"
const CodeEnv = require "thlua.code.CodeEnv"

const class = require "thlua.class"

(@do
	let.clazz=import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
	let.NonHintInjectFn = Fn(clazz.BaseStack, Fn(node.Ident_use):Ret(clazz.RefineTerm)):Ret(clazz.RefineTerm)
	let.HintInjectFn = Fn(clazz.SpaceTable, clazz.SpaceTable):Ret(clazz.Truth)
end)

const TriggerCode = class@<clazz.TriggerCode, false>(CodeEnv)

function TriggerCode:lateInit()
	error("trigger code can't call late init")
end

function TriggerCode:tryGenInjectChunkFn():Ret(False, String):Ret(node.Chunk, NonHintInjectFn, List(Integer))
	const nInjectTrace, nErr = ParseEnv.parse(self._content)
	if nInjectTrace then
		return false, "trigger by completion but not get any syntax error???"
	end
	const nInjectTrace = nErr[2]
	if not nInjectTrace then
		return false, "trigger by completion but get wrong error..."
	end
	const nCapture = nInjectTrace.capture
	if nCapture.tag == "Chunk" then
		self._astTree = nCapture
		const ok, err = pcall(function():Ret(NonHintInjectFn)
			(@do
				let.RawInjectFn = Fn(List(clazz.IAstNode), clazz.BaseStack, Fn(node.Ident_use):Ret(clazz.RefineTerm)):Ret(clazz.RefineTerm)
			end)
			const nRawInjectFn = self:_buildTypingFn() @> RawInjectFn
			return function(vStack, vGetter)
				return nRawInjectFn(self._nodeList, vStack, vGetter)
			end
		end)
		if ok then
			return nCapture, err, nInjectTrace.traceList
		else
			return false, tostring(err)
		end
	else
		return false, "TODO"
		--[[
		const fn, err = load("local _ENV, let = ... return " .. nCapture, "inject", "t", nil)
		if not fn then
			return false, err
		else
			return nInjectTrace, fn
		end
		]]
	end
end

return TriggerCode
