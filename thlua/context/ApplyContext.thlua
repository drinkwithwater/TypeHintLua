
const class = require "thlua.class"
const OpenFunction = require "thlua.func.OpenFunction"
const AssignContext = require "thlua.context.AssignContext"
const VariableCase = require "thlua.term.VariableCase"
const Exception = require "thlua.Exception"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ApplyContext = class@<clazz.ApplyContext, false>(AssignContext)

function.open ApplyContext:ctor(...)
	self._curSelfChain = false @ OrFalse(Dict(clazz.IAtomType, clazz.IAtomType))
	self._curCase = false @ OrFalse(clazz.VariableCase)
	self._once = false@Boolean
end

function ApplyContext:testAndSetRecursiveChain(vSelfType:clazz.IAtomType, vTriggerType:clazz.IAtomType):Ret(Boolean)
	const nChain = assert(self._curSelfChain)
	if nChain[vSelfType] then
		return true
	else
		nChain[vSelfType] = vTriggerType
		return false
	end
end

function ApplyContext:withCase(vCase:clazz.VariableCase, vFunc:Fn())
	assert(not self._curCase, "apply context case in case error")
	self._curCase = vCase
	vFunc()
	self._curCase = false
	self._once = true
end

function ApplyContext:withSelfCase(vSelfType:clazz.IAtomType, vCase:clazz.VariableCase, vFunc:Fn())
	self:withSelf(vSelfType, function()
		self:withCase(vCase, vFunc)
	end)
end

function ApplyContext:withSelf(vSelfType:clazz.IAtomType, vFunc:Fn())
	assert(not self._curSelfChain)
	const nCurSelfChain:Dict(clazz.IAtomType, clazz.IAtomType) = {}
	self._curSelfChain = nCurSelfChain
	vFunc()
	self._curSelfChain = false
	self._once = true
end

function ApplyContext:pushNothing()
	error("push nothing not implement in ApplyContext")
end

function ApplyContext:openPushReturn(vTermTuple:clazz.UOpenReturn)
	error("push return not implement in ApplyContext")
end

function ApplyContext:pushFirstAndTuple(vFirstType:clazz.UAtomUnion, vTuple:OrNil(clazz.UTypeTuple))
	error("push return not implement in ApplyContext")
end

function ApplyContext:pushRetTuples(vRetTuples:clazz.RetTuples)
	error("push return not implement in ApplyContext")
end

return ApplyContext
