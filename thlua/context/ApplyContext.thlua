
const class = require "thlua.class"
const OpenFunction = require "thlua.func.OpenFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const AssignContext = require "thlua.context.AssignContext"
const VariableCase = require "thlua.term.VariableCase"
const Exception = require "thlua.Exception"
const RecurChain = require "thlua.context.RecurChain"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ApplyContext = class@<clazz.ApplyContext, false>(AssignContext)

function.open ApplyContext:ctor(vNode, ...)
	self._curCase = false @ OrFalse(clazz.VariableCase)
	self._once = false@Boolean
	self._recurChain = false @ OrFalse(clazz.RecurChain)
	self._openReturn = false@OrFalse(clazz.UOpenReturn)
	self._lookupNodeSet = {} @ Dict(clazz.IAstNode, True)
	self._stack:getRuntime():recordApplyContext(vNode, self)
end

function ApplyContext:getLookupNodeSet()
	return self._lookupNodeSet
end

function ApplyContext:addLookupNode(vNode:clazz.IAstNode, vType:clazz.UAtomUnion)
	if BaseFunction.is(vType) then
		const nIfLua, nNode = vType:getIfLuaNode()
		if nIfLua then
			vNode = nNode
		end
	end
	self._lookupNodeSet[vNode] = true
end

function ApplyContext:recursiveChainTestAndRun(vSelfType:clazz.IAtomType, vFunc:Fn():Ret(Boolean)):Ret(False):Ret(True, Boolean)
	local nRecurChain = self._recurChain
	if not nRecurChain then
		nRecurChain = RecurChain.new()
		self._recurChain = nRecurChain
	end
	return nRecurChain:testAndRun(vSelfType, vFunc)
end

function ApplyContext:withCase(vCase:clazz.VariableCase, vFunc:Fn())
	assert(not self._curCase, "apply context case in case error")
	self._curCase = vCase
	vFunc()
	self._curCase = false
	self._once = true
end

function ApplyContext:pushNothing()
	if self._openReturn then
		error(Exception.new("can't mix use open function or open table", self._node))
	end
	self._once = true
end

function ApplyContext:openAssign(vType:clazz.UAtomUnion)
	if self._once or self._openReturn then
		error(Exception.new("table assign new field can't be mixed actions", self._node))
	end
	vType:setAssigned(self)
	self._openReturn = self:RefineTerm(vType)
	self._once = true
end

function ApplyContext:openPushReturn(vTermTuple:clazz.UOpenReturn)
	if self._once or self._openReturn then
		error(Exception.new("can't mix use open function or open table", self._node))
	end
	self._openReturn = vTermTuple
	self._once = true
end

function ApplyContext:pushFirstAndTuple(vFirstType:clazz.UAtomUnion, vTuple:OrNil(clazz.UTypeTuple))
	error("push return not implement in ApplyContext")
end

function ApplyContext:pushRetTuples(vRetTuples:clazz.RetTuples)
	error("push return not implement in ApplyContext")
end

return ApplyContext
