
const class = require "thlua.class"
const OpenFunction = require "thlua.func.OpenFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const AssignContext = require "thlua.context.AssignContext"
const VariableCase = require "thlua.term.VariableCase"
const Exception = require "thlua.Exception"
const RecurChain = require "thlua.context.RecurChain"
const RefineTerm = require "thlua.term.RefineTerm"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ApplyContext = class@<clazz.ApplyContext, false>(AssignContext)

function.open ApplyContext:ctor(vNode, ...)
	self._curCase = false @ OrFalse(clazz.VariableCase)
	self._once = false@Boolean
	self._recurChain = false @ OrFalse(clazz.RecurChain)
	self._lookupNodeSet = {} @ Dict(clazz.IAstNode, True)
	self._stack:getRuntime():recordApplyContext(vNode, self)
	self._finalReturn = false @OrFalse(clazz.UOpenReturn)
end

function ApplyContext:getLookupNodeSet()
	return self._lookupNodeSet
end

function ApplyContext:addLookupNode(vLookupNode:clazz.IAstNode, vType:clazz.UAtomUnion)
	self._stack:getRuntime():recordLookdownNode(vLookupNode, self._node)
	if BaseFunction.is(vType) then
		const nIfLua, nNode = vType:getIfLuaNode()
		if nIfLua then
			vLookupNode = nNode
		end
	end
	self._lookupNodeSet[vLookupNode] = true
end

function ApplyContext:recursiveChainTestAndRun(vSelfType:clazz.IAtomType, vFunc:Fn():Ret(Boolean)):Ret(False):Ret(True, Boolean)
	local nRecurChain = self._recurChain
	if not nRecurChain then
		nRecurChain = RecurChain.new()
		self._recurChain = nRecurChain
	end
	return nRecurChain:testAndRun(vSelfType, vFunc)
end

function ApplyContext:withCase(vCase:clazz.VariableCase, vFunc:Fn())
	assert(not self._curCase, "apply context case in case error")
	self._curCase = vCase
	vFunc()
	self._curCase = false
	self._once = true
end

function ApplyContext:pushNothing()
	self._once = true
end

function ApplyContext:openAssign(vType:clazz.UAtomUnion)
	if self._once then
		error(Exception.new("table assign new field can't be mixed actions", self._node))
	end
	vType:setAssigned(self)
	self._once = true
end

-- TODO: refactor later
function ApplyContext:nativeOpenReturn(vTermTuple:clazz.UOpenReturn)
	assert(not self._curCase)
	self._curCase = VariableCase.new()
	self:pushOpenReturn(vTermTuple)
	self._curCase = false
end

function ApplyContext:pushOpenReturn(vTermTuple:clazz.UOpenReturn)
	if RefineTerm.is(vTermTuple) then
		const nFirst = vTermTuple:getType()
		vTermTuple:foreach(function(vType, vCase)
			self:pushFirstAndTuple(vType, nil, vCase)
		end)
	else
		self:unfoldTermTuple(vTermTuple, function(vFirstType, vTypeTuple, vCase)
			self:pushFirstAndTuple(vFirstType, vTypeTuple, vCase)
		end)
	end
	self._once = true
end

function ApplyContext:pushFirstAndTuple(vFirstType:clazz.UAtomUnion, vTuple:OrNil(clazz.UTypeTuple), vCase:OrNil(clazz.VariableCase))
	error("push return not implement in ApplyContext")
end

function ApplyContext:pushRetTuples(vRetTuples:clazz.RetTuples)
	error("push return not implement in ApplyContext")
end

function ApplyContext:raiseError(vErrType:clazz.UAtomUnion)
	self._stack:RAISE_ERROR(self, vErrType)
end

function ApplyContext:getFinalReturn():Ret(OrFalse(clazz.UOpenReturn))
	return self._finalReturn
end

return ApplyContext
