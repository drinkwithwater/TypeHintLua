
const class = require "thlua.class"
const OpenFunction = require "thlua.func.OpenFunction"
const AssignContext = require "thlua.context.AssignContext"
const VariableCase = require "thlua.term.VariableCase"
const Exception = require "thlua.Exception"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ApplyContext = class@<clazz.ApplyContext, false>(AssignContext)

function.open ApplyContext:ctor(...)
	self._curSelfChain = false @ OrFalse(Dict(clazz.IAtomType, True))
	self._curCase = false @ OrFalse(clazz.VariableCase)
	self._once = false@Boolean
	self._curPushChain = {} @ List(clazz.IAtomType)
	self._openReturn = false@clazz.UOpenReturn
end

function ApplyContext:recursiveChainTestAndRun(vSelfType:clazz.IAtomType, vFunc:Fn():Ret(Boolean)):Ret(False):Ret(True, Boolean)
	const nChain = self._curPushChain
	for i=1, #nChain do
		if nChain[i] == vSelfType then
			return false
		end
	end
	nChain[#nChain + 1] = vSelfType
	const nRet = vFunc()
	nChain[#nChain] = nil
	return true, nRet
end

function ApplyContext:withCase(vCase:clazz.VariableCase, vFunc:Fn())
	assert(not self._curCase, "apply context case in case error")
	self._curCase = vCase
	vFunc()
	self._curCase = false
	self._once = true
end

function ApplyContext:pushNothing()
	if self._openReturn then
		error(Exception.new("can't mix use open function or open table", self._node))
	end
	self._once = true
end

function ApplyContext:openPushReturn(vTermTuple:clazz.UOpenReturn)
	if self._once or self._openReturn then
		error(Exception.new("can't mix use open function or open table", self._node))
	end
	self._openReturn = vTermTuple
	self._once = true
end

function ApplyContext:pushFirstAndTuple(vFirstType:clazz.UAtomUnion, vTuple:OrNil(clazz.UTypeTuple))
	error("push return not implement in ApplyContext")
end

function ApplyContext:pushRetTuples(vRetTuples:clazz.RetTuples)
	error("push return not implement in ApplyContext")
end

return ApplyContext
