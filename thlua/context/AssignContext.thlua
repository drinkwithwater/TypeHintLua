
const class = require "thlua.class"

const RefineTerm = require "thlua.term.RefineTerm"
const VariableCase = require "thlua.term.VariableCase"
const AutoHolder = require "thlua.auto.AutoHolder"
const TypedFunction = require "thlua.func.TypedFunction"
const AutoTable = require "thlua.object.AutoTable"
const AutoFunction = require "thlua.func.AutoFunction"

const TermTuple = require "thlua.tuple.TermTuple"
const AutoFlag = require "thlua.auto.AutoFlag"
const AutoHolder = require "thlua.auto.AutoHolder"
const DotsTail = require "thlua.tuple.DotsTail"
const AutoTail = require "thlua.auto.AutoTail"

const OperContext = require "thlua.context.OperContext"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
end)

const AssignContext = class@<clazz.AssignContext, false>(OperContext)

function.open AssignContext:ctor(...)
	self._finish = false @ Boolean
end

function AssignContext:matchArgsToTypeDots(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer,
	vHintDots:clazz.UAllType
):Ret(clazz.UTermTuple)
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		const nTerm = vTermTuple:get(self, i)
		nTailTermList[#nTailTermList + 1] = self:assignTermToType(nTerm, vHintDots)
	end
	const nTermTail = vTermTuple:getTail()
	if AutoTail.is(nTermTail) then
		const nMore = vParNum - #vTermTuple
		if nMore <= 0 then
			nTermTail:sealTailFrom(self, 1, vHintDots)
		else
			nTermTail:sealTailFrom(self, nMore + 1, vHintDots)
		end
	end
	return self:UTermTupleByTail({}, DotsTail.new(self, vHintDots))
end

function AssignContext:matchArgsToAutoDots(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer
):Ret(clazz.UTermTuple)
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		nTailTermList[#nTailTermList + 1] = vTermTuple:get(self, i)
	end
	const nTermTail = vTermTuple:getTail()
	if not AutoTail.is(nTermTail) then
		if nTermTail then
			return self:UTermTupleByTail(nTailTermList, DotsTail.new(self, nTermTail:getRepeatType()))
		else
			return self:UTermTupleByTail(nTailTermList)
		end
	else
		const nMore = vParNum - #vTermTuple
		if nMore <= 0 then
			return self:UTermTupleByTail(nTailTermList, nTermTail)
		else
			return self:UTermTupleByTail(nTailTermList, nTermTail:openTailFrom(self, nMore + 1))
		end
	end
end

function AssignContext:matchArgsToNoDots(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer
)
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		nTailTermList[#nTailTermList + 1] = vTermTuple:get(self, i)
	end
	const nTermTail = vTermTuple:getTail()
	if AutoTail.is(nTermTail) then
		const nMore = vParNum - #vTermTuple
		if nMore <= 0 then
			nTermTail:sealTailFrom(self, 1, true)
		else
			nTermTail:sealTailFrom(self, nMore + 1, true)
		end
	end
end

function AssignContext:matchArgsToTypeTuple(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vTypeTuple:clazz.UTypeTuple
)
	const nParNum = #vTypeTuple
	for i=1, #vTermTuple do
		const nAutoTerm = vTermTuple:get(self, i)
		const nHintType = vTypeTuple:get(i)
		self:assignTermToType(nAutoTerm, nHintType)
	end
	for i=#vTermTuple + 1, nParNum do
		const nAutoTerm = vTermTuple:get(self, i)
		const nHintType = vTypeTuple:get(i)
		self:assignTermToType(nAutoTerm, nHintType)
	end
	const nDotsType = vTypeTuple:getRepeatType()
	if nDotsType then
		self:matchArgsToTypeDots(vNode, vTermTuple, nParNum, nDotsType)
	else
		self:matchArgsToNoDots(vNode, vTermTuple, nParNum)
	end
end

function AssignContext:tryIncludeCast(
	vFnCastDict:Dict(clazz.AutoFunction, List(clazz.UAtomUnion)),
	vDstType:clazz.UAtomUnion,
	vSrcType:clazz.UAtomUnion
):Ret(OrFalse(clazz.UAtomUnion))
	const nCollection = self._manager:TypeCollection()
	const nDstFnPart = vDstType:partTypedFunction()
	const nDstObjPart = vDstType:partTypedObject()
	local nInclude = true
	local nPutFnPart = false
	local nPutObjPart = false
	vSrcType:foreach(function(vSubType)
		if AutoTable.is(vSubType) and vSubType:isCastable() and not nDstObjPart:isNever() then
			nPutObjPart = true
			vSubType:tryCast(self, vFnCastDict, nDstObjPart)
		elseif AutoFunction.is(vSubType) and vSubType:isCastable() and not nDstFnPart:isNever() then
			local nList = vFnCastDict[vSubType]
			if not nList then
				nList = {}
				vFnCastDict[vSubType] = nList
			end
			nList[#nList + 1] = nDstFnPart
			nPutFnPart = true
		elseif vDstType:includeAtom(vSubType) then
			nCollection:put(vSubType)
		else
			nInclude = false
		end
	end)
	if not nInclude then
		return false
	else
		if nPutFnPart then
			nCollection:put(nDstFnPart)
		end
		if nPutObjPart then
			nCollection:put(nDstObjPart)
		end
		return nCollection:mergeToAtomUnion()
	end
end

function AssignContext:includeOrCastFrom(vDstType:clazz.UAtomUnion, vSrcType:clazz.UAtomUnion):Ret(OrFalse(clazz.UAtomUnion))
	const nFnLateDict:Dict(clazz.AutoFunction, List(clazz.UAtomUnion)) = {}
	const nRet = self:tryIncludeCast(nFnLateDict, vDstType, vSrcType)
	for nAutoFn, nList in pairs(nFnLateDict) do
		for _, nTypeFn in ipairs(nList) do
			if TypedFunction.is(nTypeFn) then
				nAutoFn:checkWhenCast(self, nTypeFn)
			end
		end
	end
	return nRet
end

function AssignContext:assignTermToType(vAutoTerm:clazz.UAutoTerm, vDstType:clazz.UAllType):Ret(clazz.RefineTerm)
	const nSrcType = vAutoTerm:getType()
	const nDstType = vDstType:checkAtomUnion()
	if not nSrcType then
		vAutoTerm:setAutoCastType(self, nDstType)
	else
		const nIncludeCastType = self:includeOrCastFrom(nDstType, nSrcType)
		if not nIncludeCastType then
		  self:error("assign but type not match")
		end
	end
	-- TODO, maybe add some case here?
	return self:RefineTerm(nDstType)
end

function AssignContext:finish()
	assert(not self._finish, "context finish can only called once")
	self._finish = true
end

return AssignContext
