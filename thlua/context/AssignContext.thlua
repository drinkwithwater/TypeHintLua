
const class = require "thlua.class"

const Struct = require "thlua.object.Struct"
const RefineTerm = require "thlua.term.RefineTerm"
const VariableCase = require "thlua.term.VariableCase"
const AutoHolder = require "thlua.auto.AutoHolder"
const TypedFunction = require "thlua.func.TypedFunction"
const AutoTable = require "thlua.object.AutoTable"
const AutoFunction = require "thlua.func.AutoFunction"

const TermTuple = require "thlua.tuple.TermTuple"
const AutoFlag = require "thlua.auto.AutoFlag"
const AutoHolder = require "thlua.auto.AutoHolder"
const DotsTail = require "thlua.tuple.DotsTail"
const AutoTail = require "thlua.auto.AutoTail"

const AutoFnCastDict = require "thlua.context.AutoFnCastDict"
const OperContext = require "thlua.context.OperContext"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
end)

const AssignContext = class@<clazz.AssignContext, false>(OperContext)

function.open AssignContext:ctor(...)
	self._finish = false @ Boolean
end

function AssignContext:matchArgsToTypeDots(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer,
	vHintDots:clazz.UAllType
):Ret(clazz.UTermTuple)
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		const nTerm = vTermTuple:get(self, i)
		nTailTermList[#nTailTermList + 1] = self:assignTermToType(nTerm, vHintDots)
	end
	const nTermTail = vTermTuple:getTail()
	if AutoTail.is(nTermTail) then
		const nMore = vParNum - #vTermTuple
		if nMore <= 0 then
			nTermTail:sealTailFrom(self, 1, vHintDots)
		else
			nTermTail:sealTailFrom(self, nMore + 1, vHintDots)
		end
	end
	return self:UTermTupleByTail({}, DotsTail.new(self, vHintDots))
end

function AssignContext:matchArgsToAutoDots(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer
):Ret(clazz.UTermTuple)
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		nTailTermList[#nTailTermList + 1] = vTermTuple:get(self, i)
	end
	const nTermTail = vTermTuple:getTail()
	if not AutoTail.is(nTermTail) then
		if nTermTail then
			return self:UTermTupleByTail(nTailTermList, DotsTail.new(self, nTermTail:getRepeatType()))
		else
			return self:UTermTupleByTail(nTailTermList)
		end
	else
		const nMore = vParNum - #vTermTuple
		if nMore <= 0 then
			return self:UTermTupleByTail(nTailTermList, nTermTail)
		else
			return self:UTermTupleByTail(nTailTermList, nTermTail:openTailFrom(self, nMore + 1))
		end
	end
end

function AssignContext:matchArgsToNoDots(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer
)
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		nTailTermList[#nTailTermList + 1] = vTermTuple:get(self, i)
	end
	const nTermTail = vTermTuple:getTail()
	if AutoTail.is(nTermTail) then
		const nMore = vParNum - #vTermTuple
		if nMore <= 0 then
			nTermTail:sealTailFrom(self, 1, true)
		else
			nTermTail:sealTailFrom(self, nMore + 1, true)
		end
	end
end

function AssignContext:matchArgsToTypeTuple(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vTypeTuple:clazz.UTypeTuple
)
	const nParNum = #vTypeTuple
	for i=1, #vTermTuple do
		const nAutoTerm = vTermTuple:get(self, i)
		const nHintType = vTypeTuple:get(i)
		self:assignTermToType(nAutoTerm, nHintType)
	end
	for i=#vTermTuple + 1, nParNum do
		const nAutoTerm = vTermTuple:get(self, i)
		const nHintType = vTypeTuple:get(i)
		self:assignTermToType(nAutoTerm, nHintType)
	end
	const nDotsType = vTypeTuple:getRepeatType()
	if nDotsType then
		self:matchArgsToTypeDots(vNode, vTermTuple, nParNum, nDotsType)
	else
		self:matchArgsToNoDots(vNode, vTermTuple, nParNum)
	end
end

---------------------------------------------------------
-- 1. castable auto-function always cast success -----
-- 2. castable auto-table may cast failed -----
-- 3. castable auto-function is saved for late cast -----
-- 4. if table cast success, then table's field auto-function is saved for late cast ---------
--------------------------------------------------------
function AssignContext:tryIncludeCast(
	vAutoFnCastDict:clazz.AutoFnCastDict,
	vDstType:clazz.UAtomUnion,
	vSrcType:clazz.UAtomUnion
):Ret(False):Ret(clazz.UAtomUnion, Boolean)
	const nCollection = self._manager:TypeCollection()
	const nDstFnPart = vDstType:partTypedFunction()
	const nDstObjPart = vDstType:partTypedObject()
	local nIncludeSucc = true
	local nCastSucc = true
	local nPutFnPart = false
	local nPutObjPart = false
	vSrcType:foreach(function(vSubType)
		if AutoTable.is(vSubType) and vSubType:isCastable() and not nDstObjPart:isNever() then
			nPutObjPart = true
			local nMatchOne = false
			nDstObjPart:foreach(function(vAtomType)
				if Struct.is(vAtomType) then
					const nAutoFnCastDict = vSubType:castMatchOne(self, vAtomType)
					if nAutoFnCastDict then
						vAutoFnCastDict:putAll(nAutoFnCastDict)
						nCollection:put(vAtomType)
						nMatchOne = true
					end
				end
			end)
			if not nMatchOne then
				nCastSucc = false
			end
		elseif AutoFunction.is(vSubType) and vSubType:isCastable() and not nDstFnPart:isNever() then
			vAutoFnCastDict:putOne(vSubType, nDstFnPart)
			nPutFnPart = true
		elseif vDstType:includeAtom(vSubType) then
			nCollection:put(vSubType)
		else
			nIncludeSucc = false
		end
	end)
	if not nIncludeSucc then
		return false
	else
		if nPutFnPart then
			nCollection:put(nDstFnPart)
		end
		if not nCastSucc and nPutObjPart then
			nCollection:put(nDstObjPart)
		end
		return nCollection:mergeToAtomUnion(), nCastSucc
	end
end

function AssignContext:includeAndCast(vDstType:clazz.UAtomUnion, vSrcType:clazz.UAtomUnion):Ret(False):Ret(clazz.UAtomUnion, Boolean)
	const nFnLateDict = AutoFnCastDict.new()
	const nIncludeType, nCastSucc = self:tryIncludeCast(nFnLateDict, vDstType, vSrcType)
	if nIncludeType then
		nFnLateDict:runLateCast(self)
	end
	return nIncludeType, nCastSucc
end

function AssignContext:assignTermToType(vAutoTerm:clazz.UAutoTerm, vDstType:clazz.UAllType):Ret(clazz.RefineTerm)
	const nSrcType = vAutoTerm:getType()
	const nDstType = vDstType:checkAtomUnion()
	if not nSrcType then
		vAutoTerm:setAutoCastType(self, nDstType)
	else
		const nIncludeCastType, nCastSucc = self:includeAndCast(nDstType, nSrcType)
		if not nIncludeCastType then
		  self:error("assign but type not match")
		elseif not nCastSucc then
		  self:error("assign but type cast fail")
		end
	end
	-- TODO, maybe add some case here?
	return self:RefineTerm(nDstType)
end

function AssignContext:finish()
	assert(not self._finish, "context finish can only called once")
	self._finish = true
end

return AssignContext
