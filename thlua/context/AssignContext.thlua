
const class = require "thlua.class"

const Struct = require "thlua.type.object.Struct"
const RefineTerm = require "thlua.term.RefineTerm"
const VariableCase = require "thlua.term.VariableCase"
const AutoHolder = require "thlua.auto.AutoHolder"
const TypedFunction = require "thlua.type.func.TypedFunction"
const AutoTable = require "thlua.type.object.AutoTable"
const AutoFunction = require "thlua.type.func.AutoFunction"

const TermTuple = require "thlua.tuple.TermTuple"
const AutoFlag = require "thlua.auto.AutoFlag"
const AutoHolder = require "thlua.auto.AutoHolder"
const DotsTail = require "thlua.tuple.DotsTail"
const AutoTail = require "thlua.auto.AutoTail"

const ListDict = require "thlua.manager.ListDict"
const OperContext = require "thlua.context.OperContext"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
	clazz.AutoFnCastDict = clazz.ListDict(clazz.AutoFunction, clazz.UAtomUnion)
end)

const AssignContext = class@<clazz.AssignContext, false>(OperContext)

function.open AssignContext:ctor(...)
	self._finish = false @ Boolean
end

function AssignContext:matchArgsToTypeDots(
	vNode:clazz.IBaseNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer,
	vHintDots:clazz.UAllType
):Ret(clazz.UTermTuple)
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		const nTerm = vTermTuple:get(self, i)
		nTailTermList[#nTailTermList + 1] = self:assignTermToType(nTerm, vHintDots)
	end
	const nTermTail = vTermTuple:getTail()
	if AutoTail.is(nTermTail) then
		const nMore = vParNum - #vTermTuple
		if nMore <= 0 then
			nTermTail:sealTailFrom(self, 1, vHintDots)
		else
			nTermTail:sealTailFrom(self, nMore + 1, vHintDots)
		end
	end
	return self:UTermTupleByTail({}, DotsTail.new(self, vHintDots))
end

function AssignContext:matchArgsToAutoDots(
	vNode:clazz.IBaseNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer
):Ret(clazz.UTermTuple)
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		nTailTermList[#nTailTermList + 1] = vTermTuple:get(self, i)
	end
	const nTermTail = vTermTuple:getTail()
	if not AutoTail.is(nTermTail) then
		if nTermTail then
			return self:UTermTupleByTail(nTailTermList, DotsTail.new(self, nTermTail:getRepeatType()))
		else
			return self:UTermTupleByTail(nTailTermList)
		end
	else
		const nMore = vParNum - #vTermTuple
		if nMore <= 0 then
			return self:UTermTupleByTail(nTailTermList, nTermTail)
		else
			return self:UTermTupleByTail(nTailTermList, nTermTail:openTailFrom(self, nMore + 1))
		end
	end
end

function AssignContext:matchArgsToNoDots(
	vNode:clazz.IBaseNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer
)
	for i=vParNum + 1, #vTermTuple do
		vTermTuple:get(self, i)
		self:error("parameters is not enough")
	end
	const nTermTail = vTermTuple:getTail()
	if AutoTail.is(nTermTail) then
		const nMore = vParNum - #vTermTuple
		if nMore <= 0 then
			nTermTail:sealTailFrom(self, 1, true)
		else
			nTermTail:sealTailFrom(self, nMore + 1, true)
		end
	end
end

function AssignContext:matchArgsToTypeTuple(
	vNode:clazz.IBaseNode,
	vTermTuple:clazz.UTermTuple,
	vTypeTuple:clazz.UTypeTuple
)
	const nParNum = #vTypeTuple
	for i=1, #vTermTuple do
		const nAutoTerm = vTermTuple:get(self, i)
		const nHintType = vTypeTuple:get(i)
		self:assignTermToType(nAutoTerm, nHintType)
	end
	for i=#vTermTuple + 1, nParNum do
		const nAutoTerm = vTermTuple:get(self, i)
		const nHintType = vTypeTuple:get(i)
		self:assignTermToType(nAutoTerm, nHintType)
	end
	const nDotsType = vTypeTuple:getRepeatType()
	if nDotsType then
		self:matchArgsToTypeDots(vNode, vTermTuple, nParNum, nDotsType)
	else
		self:matchArgsToNoDots(vNode, vTermTuple, nParNum)
	end
end

---------------------------------------------------------
-- 1. castable auto-function always cast success -----
-- 2. castable auto-table may cast failed -----
-- 3. castable auto-function is saved for late cast -----
-- 4. if table cast success, then table's field auto-function is saved for late cast ---------
--------------------------------------------------------
function AssignContext:tryIncludeCast(
	vAutoFnCastDict:clazz.AutoFnCastDict,
	vDstType:clazz.UAtomUnion,
	vSrcType:clazz.UAtomUnion
):Ret(False):Ret(clazz.UAtomUnion, Boolean)
	const nCollection = self._manager:TypeCollection()
	const nDstFnPart = vDstType:partTypedFunction()
	const nDstObjPart = vDstType:partTypedObject()
	local nIncludeSucc = true
	local nCastSucc = true
	local nPutFnPart = false
	local nPutObjPart = false
	vSrcType:foreach(function(vSubType)
		if AutoTable.is(vSubType) and vSubType:isCastable() and not nDstObjPart:isNever() then
			nPutObjPart = true
			local nMatchOne = false
			nDstObjPart:foreach(function(vAtomType)
				if Struct.is(vAtomType) then
					const nAutoFnCastDict = vSubType:castMatchOne(self, vAtomType)
					if nAutoFnCastDict then
						vAutoFnCastDict:putAll(nAutoFnCastDict)
						nCollection:put(vAtomType)
						nMatchOne = true
					end
				end
			end)
			if not nMatchOne then
				nCastSucc = false
			end
		elseif AutoFunction.is(vSubType) and vSubType:isCastable() and not nDstFnPart:isNever() then
			vAutoFnCastDict:putOne(vSubType, nDstFnPart)
			nPutFnPart = true
		elseif vDstType:includeAtom(vSubType) then
			nCollection:put(vSubType)
		else
			nIncludeSucc = false
		end
	end)
	if not nIncludeSucc then
		return false
	else
		if nPutFnPart then
			nCollection:put(nDstFnPart)
		end
		if not nCastSucc and nPutObjPart then
			nCollection:put(nDstObjPart)
		end
		return nCollection:mergeToAtomUnion(), nCastSucc
	end
end

function AssignContext:includeAndCast(vDstType:clazz.UAtomUnion, vSrcType:clazz.UAtomUnion, vWhen:OrNil(String)):Ret(OrFalse(clazz.UAtomUnion))
	const nFnLateDict = self:newAutoFnCastDict()
	const nIncludeType, nCastSucc = self:tryIncludeCast(nFnLateDict, vDstType, vSrcType)
	if nIncludeType then
		self:runLateCast(nFnLateDict)
		if not nCastSucc then
			if vWhen then
				self:error("type cast fail when "..tostring(vWhen))
			else
				self:error("type cast fail")
			end
		end
	else
		if vWhen then
			self:error("type not match when "..tostring(vWhen))
		else
			self:error("type not match")
		end
	end
	return nIncludeType
end

function AssignContext:assignTermToType(vAutoTerm:clazz.UAutoTerm, vDstType:clazz.UAllType):Ret(clazz.RefineTerm)
	const nSrcType = vAutoTerm:getType()
	const nDstType = vDstType:checkAtomUnion()
	if not nSrcType then
		vAutoTerm:setAutoCastType(self, nDstType)
	else
		self:includeAndCast(nDstType, nSrcType)
	end
	-- TODO, maybe add some case here?
	return self:RefineTerm(nDstType)
end

function AssignContext:finish()
	assert(not self._finish, "context finish can only called once")
	self._finish = true
end

function AssignContext:newAutoFnCastDict()
	return ListDict@<clazz.AutoFunction, clazz.UAtomUnion>()
end

function AssignContext:runLateCast(vDict:clazz.AutoFnCastDict)
	vDict:forKList(function(vAutoFn, vTypeFnList)
		for _, nTypeFn in ipairs(vTypeFnList) do
			if TypedFunction.is(nTypeFn) then
				vAutoFn:checkWhenCast(nTypeFn)
			end
		end
	end)
end

function AssignContext:unfoldTermTuple(vTermTuple:clazz.FixedTermTuple, vFunc:Fn(clazz.UAtomUnion, clazz.UTypeTuple, OrNil(clazz.VariableCase)))
	const nFirstTerm = vTermTuple:get(self, 1)
	if #vTermTuple == 0 then
		vFunc(nFirstTerm:getType(), vTermTuple:checkTypeTuple(), nil)
		return
	end
	const nTail = vTermTuple:getTail()
	const nRepeatType = nTail and nTail:getRepeatType()
	nFirstTerm:foreach(function(vAtomType, vCase)
		const nTypeList:List(clazz.UAllType) = {vAtomType}
		for i=2, #vTermTuple do
			local nTerm = vTermTuple:get(self, i)
			const nType = vCase[nTerm:attachImmutVariable()]
			if not nType then
				nTypeList[i] = nTerm:getType()
			else
				nTypeList[i] = assert(nTerm:getType():safeIntersect(nType), "unexcepted intersect when return")
			end
		end
		const nTypeTuple = self._manager:TypeTuple(self._node, nTypeList)
		const nTypeTuple = nRepeatType and nTypeTuple:Dots(nRepeatType) or nTypeTuple
		vFunc(vAtomType, nTypeTuple, vCase)
	end)
end

return AssignContext
