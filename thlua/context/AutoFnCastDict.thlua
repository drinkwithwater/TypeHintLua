
const TypedFunction = require "thlua.func.TypedFunction"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const AutoFnCastDict = {}
AutoFnCastDict.__index=AutoFnCastDict

function:class(clazz.AutoFnCastDict) AutoFnCastDict.new()
	return setmetatable({.class:Init({
			[clazz.AutoFunction]=List(clazz.UAtomUnion)
		})
	}, AutoFnCastDict)
end

function AutoFnCastDict:putOne(vAutoFn:clazz.AutoFunction, vType:clazz.UAtomUnion)
	local nList = self[vAutoFn]
	if not nList then
		nList = {}
		self[vAutoFn] = nList
	end
	nList[#nList + 1] = vType
end

function AutoFnCastDict:putAll(vDict:clazz.AutoFnCastDict)
	for nAutoFn, nList in pairs(vDict) do
		const nOldList = self[nAutoFn]
		if not nOldList then
			self[nAutoFn] = nList
		else
			for i=1, #nList do
				nOldList[#nOldList + 1] = nList[i]
			end
		end
	end
end

function AutoFnCastDict:runLateCast(vContext:clazz.AssignContext)
	for nAutoFn, nList in pairs(self) do
		for _, nTypeFn in ipairs(nList) do
			if TypedFunction.is(nTypeFn) then
				nAutoFn:checkWhenCast(nTypeFn)
			end
		end
	end
end

return AutoFnCastDict

