
const AutoFlag = require "thlua.auto.AutoFlag"
const AutoTail = require "thlua.auto.AutoTail"
const DotsTail = require "thlua.tuple.DotsTail"
const TermTuple = require "thlua.tuple.TermTuple"
const AutoHolder = require "thlua.auto.AutoHolder"
const RefineTerm = require "thlua.term.RefineTerm"
const Exception = require "thlua.Exception"
const class = require "thlua.class"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const BaseContext = class@<clazz.BaseContext, false>()

function BaseContext:__tostring():Ret(String)
	return "context:"..tostring(self:getNode())
end

function.open BaseContext:ctor(
	vRuntime:clazz.Runtime,
	vApplyNode:clazz.IAstNode,
	vParentContext:OrFalse(clazz.BodyContext)
)
	self._runtime=vRuntime
	self._manager=vRuntime:getTypeManager()
	self._node=vApplyNode
	self._parentContext = vParentContext
end

function BaseContext:RefineTerm(vType:clazz.UAllType):Ret(clazz.RefineTerm)
	return RefineTerm.new(self, vType:checkAtomUnion())
end

function BaseContext:NumberTerm():Ret(clazz.RefineTerm)
	return RefineTerm.new(self, self._manager.type.Number)
end

function BaseContext:NeverTerm():Ret(clazz.RefineTerm)
	return RefineTerm.new(self, self._manager.type.Never)
end

function BaseContext:TruthTerm():Ret(clazz.RefineTerm)
	return RefineTerm.new(self, self._manager.type.Truth)
end

function BaseContext:NilTerm():Ret(clazz.RefineTerm)
	return RefineTerm.new(self, self._manager.type.Nil)
end

function BaseContext:BooleanTerm(vValue:Boolean):Ret(clazz.RefineTerm)
	return RefineTerm.new(self, self._manager:Boolean(vValue))
end

function BaseContext:LiteralTerm(v:Union(String, Number)):Ret(clazz.RefineTerm)
	return RefineTerm.new(self, self:Literal(v))
end

function BaseContext:mergeToRefineTerm(vTypeCasePairList:List(clazz.TypeCasePair)):Ret(clazz.RefineTerm)
	const nKeyUnion, nTypeDict = self._manager:mergePairList@<clazz.VariableCase>(vTypeCasePairList)
	return RefineTerm.new(self, nKeyUnion, nTypeDict)
end

function BaseContext:Literal(vValue:Union(String, Number)):Ret(Union(clazz.StringLiteral, clazz.NumberLiteral))
	return self._manager:Literal(vValue)
end

function BaseContext:error(...:Truth)
	self._runtime:nodeError(self._node, ...)
end

function BaseContext:warn(...:Truth)
	self._runtime:nodeWarn(self._node, ...)
end

function BaseContext:info(...:Truth)
	self._runtime:nodeInfo(self._node, ...)
end

function BaseContext:getNode():Ret(clazz.IAstNode)
	return self._node
end

function BaseContext:getRuntime():Ret(clazz.Runtime)
	return self._runtime
end

function BaseContext:getTypeManager():Ret(clazz.TypeManager)
	return self._manager
end

return BaseContext
