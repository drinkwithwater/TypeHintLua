
const AutoHolder = require "thlua.auto.AutoHolder"
const AutoFlag = require "thlua.auto.AutoFlag"
const TermTuple = require "thlua.tuple.TermTuple"
const Region = require "thlua.runtime.Region"
const RefineTerm = require "thlua.term.RefineTerm"
const VariableCase = require "thlua.term.VariableCase"
const Exception = require "thlua.Exception"
const Reference = require "thlua.refer.Reference"
const Node = require "thlua.code.Node"
const Enum = require "thlua.Enum"

const LuaFunction = require "thlua.func.LuaFunction"
const TypeFunction = require "thlua.func.TypeFunction"
const OpenFunction = require "thlua.func.OpenFunction"
const PolyFunction = require "thlua.func.PolyFunction"
const AnyFunction = require "thlua.func.AnyFunction"
const LuaTable = require "thlua.object.LuaTable"
const MetaObject = require "thlua.object.MetaObject"
const Truth = require "thlua.type.Truth"

const FunctionBuilder = require "thlua.builder.FunctionBuilder"
const TableBuilder = require "thlua.builder.TableBuilder"
const DotsTail = require "thlua.tuple.DotsTail"
const AutoTail = require "thlua.auto.AutoTail"
const class = require "thlua.class"

const BaseContext = require "thlua.context.BaseContext"
const OperContext = require "thlua.context.OperContext"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
end)

const BodyContext = class@<clazz.BodyContext, false>(BaseContext)

function.open BodyContext:ctor(
	vRuntime:clazz.Runtime,
	vApplyNode:clazz.IAstNode,
	vParentContext:OrFalse(clazz.BodyContext)
)
	self._region=false@OrFalse(clazz.Region)
	self._classFnSet={} @ OrFalse(Dict(clazz.ClassFactory, True))
	self._funcMakerSet={} @ OrFalse(Dict(clazz.AutoFunction, True))
	self._sealed=false@Boolean
	self._classTable=false @ OrFalse(clazz.LuaTable)
	self._namespace=false@OrFalse(clazz.Namespace)
	self._sealContext = self
end

function BodyContext:setOpen()
	self._sealContext = assert(self._parentContext, "root context can't be open context"):getSealContext()
end

--[[
function.pass Context:testLine(vNode:clazz.IAstNode, vName:String):Ret(clazz.IAstNode)
	local nInfo = debug.getinfo(2)
	if nInfo.currentline ~= vNode.l then
		print(nInfo.currentline, vNode.l, vName, vNode.tag, vNode.kind)
	end
	return vNode
end]]

function BodyContext:AUTO(vNode:clazz.IAstNode):Ret(clazz.AutoFlag)
	return AutoFlag
end

function BodyContext:setClassTable(vClassTable:clazz.LuaTable)
	self._classTable = vClassTable
end

function BodyContext:getClassTable():Ret(OrFalse(clazz.LuaTable))
	return self._classTable
end

function BodyContext:rootSetNamespace(vRootSpace:clazz.Namespace)
	assert(not self._namespace, "namespace has been setted")
	self._namespace = vRootSpace
end

function BodyContext:BEGIN(vLexContext:clazz.BodyContext, vRegionNode:clazz.IAstNode, vBodyFn:clazz.UBodyFunction, vUpCase:OrFalse(clazz.VariableCase)
):Ret(clazz.Region, clazz.SpaceTable, clazz.SpaceTable)
	assert(not self._region, "context can only begin once")
	const nRegion = Region.new(self, vBodyFn, vUpCase or VariableCase.new())
	self._region = nRegion
	const nSpace = self._runtime:LetNamespace(vLexContext:getNamespace(), vRegionNode)
	self._namespace = nSpace
	return nRegion, nSpace.localExport, nSpace.globalExport
end

-- pack explist to termtuple or lazyfunc
function BodyContext:EXPRLIST_REPACK(
	vNode:clazz.IAstNode,
	vLazy:Boolean,
	l:List(Union(clazz.UTermTuple, clazz.UAutoTerm, Fn():Ret(clazz.UAutoTerm)))
):Ret(clazz.UTermTuple):Ret(Fn():Ret(clazz.UTermTuple))
	local reFunc:OrNil(Fn():Ret(clazz.UTermTuple))
	const nLastIndex = #l
	const nLast = l[nLastIndex]
	if not nLast then
		reFunc = function()
			return self:FixedTermTuple({})
		end
	else
		const repackWithoutLast = function():Ret(List(clazz.UAutoTerm))
			const nTermList:List(clazz.UAutoTerm) = {}
			for i=1, #l-1 do
				const cur = l[i]
				if TermTuple.is(cur) then
					if #cur ~= 1 then
						-- self._runtime:nodeWarn(vNode, "tuple expect 1 value but get "..#cur)
					end
					nTermList[i] = cur:get(self, 1)
				elseif RefineTerm.is(cur) or AutoHolder.is(cur) then
					nTermList[i] = cur
				elseif type(cur) == "function" then
					nTermList[i] = cur()
				else
					error("unexcept branch")
				end
			end
			return nTermList
		end
		-- force cast
		if TermTuple.is(nLast) then
			reFunc = function()
				return self:UTermTupleByAppend(repackWithoutLast(), nLast)
			end
		else
			reFunc = function()
				const nTermList = repackWithoutLast()
				if RefineTerm.is(nLast) or AutoHolder.is(nLast) then
					nTermList[#nTermList + 1] = nLast
				elseif type(nLast) == "function" then
					nTermList[#nTermList + 1] = nLast()
				else
					error("unexcept branch")
				end
				return self:UTermTupleByAppend(nTermList, false)
			end
		end
	end
	if vLazy then
		return reFunc
	else
		return reFunc()
	end
end

-- unpack explist to vNum term | termtuple
function BodyContext:EXPRLIST_UNPACK(
	vNode:clazz.IAstNode,
	vNum:Number,
	...:Union(clazz.RefineTerm, clazz.FixedTermTuple)
):RetDots(clazz.RefineTerm)
	const l:List(Union(clazz.RefineTerm, clazz.FixedTermTuple)) = {...}
	const re:List(clazz.RefineTerm) = {}
	for i=1, vNum do
		if i > #l then
			local last = l[#l]
			if TermTuple.is(last) then
				local value = last:get(self, i - #l + 1)
				if not value then
					self._runtime:nodeError(vNode, "exprlist_unpack but right tuple value not enough")
					re[i] = self:RefineTerm(self._manager.type.Nil)
				else
					re[i] = value
				end
			else
				self._runtime:nodeError(vNode, "exprlist_unpack but right value not enough")
				re[i] = self:RefineTerm(self._manager.type.Nil)
			end
		else
			local cur = l[i]
			if TermTuple.is(cur) then
				if (i < #l and #cur ~= 1) then
					self._runtime:nodeWarn(vNode, "exprlist_unpack except 1 value but has "..#cur)
				end
				re[i] = cur:get(self, 1)
			else
				re[i] = cur
			end
		end
	end
	return table.unpack(re)
end

-- meta items
function BodyContext:META_GET(
	vNode:clazz.IAstNode,
	vSelfTerm:clazz.RefineTerm,
	vKeyTerm:clazz.RefineTerm,
	vNotnil:Boolean
):Ret(clazz.RefineTerm)
	const nGetContext = self:newLocalContext(vNode)
	const nTypeCaseList:List(clazz.TypeCasePair) = {}
	const nOkay = self:nodePcall(vNode, function()
		vSelfTerm:foreach(function(vType, vVariableCase)
			vKeyTerm:foreach(function(vKeyType, vKeyVariableCase)
				local nReType = vType:meta_get(nGetContext, vKeyType)
				if vNotnil then
					nReType = nReType:notnilType()
				end
				nTypeCaseList[#nTypeCaseList + 1] = {nReType, vVariableCase & vKeyVariableCase}
			end)
		end)
	end)
	if nOkay then
		return self._manager:mergeToRefineTerm(nTypeCaseList)
	else
		return self:TruthTerm()
	end
end

function BodyContext:META_SET(
	vNode:clazz.IAstNode,
	vSelfTerm:clazz.RefineTerm,
	vKeyTerm:clazz.RefineTerm,
	vValueTerm:clazz.RefineTerm
)
	const nSetContext = self:newLocalContext(vNode)
	self:nodePcall(vNode, function()
		local nNil = self._manager.type.Nil
		vSelfTerm:foreach(function(vType, _)
			vKeyTerm:foreach(function(vKeyType, _)
				vType:meta_set(nSetContext, vKeyType, vValueTerm:getType())
			end)
		end)
	end)
end

(@let.FuncArgCaseList = List(Struct {clazz.IAtomType, clazz.UTermTuple, clazz.VariableCase, self=OrNil(clazz.IAtomType)}))
(@let.OpenPair = Struct {Union(clazz.OpenFunction, clazz.LuaFunction), clazz.UTermTuple})
function BodyContext:_apply(vNode:clazz.IAstNode, vOpenPair:OrNil(OpenPair), vFuncArgCaseList:FuncArgCaseList, vPolyArgs:OrNil(List(clazz.UAllType))):Ret(clazz.UTermTuple)
	const ok, err = self:nodePcall(vNode, function():Ret(clazz.UTermTuple)
		const nListLen = #vFuncArgCaseList
		const nOpenPair = vOpenPair
		if nOpenPair then
			if nListLen ~= 0 then
				self._runtime:nodeError(vNode, "can't mix call native function & not-native function")
				return self:FixedTermTuple({})
			end
			return nOpenPair[1]:meta_open_call(self:newOpenContext(vNode), nOpenPair[2])
		elseif nListLen >= 1 then
			-- step 1. prepare for return
			const nType1TupleCaseList:List(Struct {clazz.UAtomUnion, clazz.UTypeTuple, clazz.VariableCase}) = {}
			const nNil = self._manager.type.Nil
			local nMaxLength = 0
			const nRepeatCollection = self._manager:TypeCollection()
			-- step 2. call function
			for i, nFuncArgCase in ipairs(vFuncArgCaseList) do
				local f,nArgs,nCase,nSelf = nFuncArgCase[1], nFuncArgCase[2], nFuncArgCase[3], nFuncArgCase.self
				const nNewContext = self:newLocalContext(vNode)
				const nRetTuples = vPolyArgs
					and f:meta_invoke(nNewContext, assert(nSelf, "self must exist here"), vPolyArgs, nArgs)
					or f:meta_call(nNewContext, nArgs)
				nRetTuples:foreachWithFirst(function(vTypeTuple, vFirst)
					local nLength = #vTypeTuple
					if nLength > nMaxLength then
						nMaxLength = nLength
					end
					nType1TupleCaseList[#nType1TupleCaseList + 1] = {
						vFirst:checkAtomUnion(), vTypeTuple, VariableCase.new() & nCase
					}
					const nRepeatType = vTypeTuple:getRepeatType()
					if nRepeatType then
						nRepeatCollection:put(nRepeatType)
					end
				end)
			end
			const nRepeatType:clazz.UAtomUnion = nRepeatCollection:mergeToAtomUnion()
			const nTail = (not nRepeatType:isNever()) and nRepeatType or false
			if nMaxLength <= 0 then
				return self:FixedTermTuple({}, nTail)
			end
			const nTermList:List(clazz.RefineTerm) = {}
			-- step 3. merge 2 ~ nMaxLength
			for i=2,nMaxLength do
				const nCollection = self._manager:TypeCollection()
				for _, nType1TupleCase in pairs(nType1TupleCaseList) do
					nCollection:put(nType1TupleCase[2]:get(i))
				end
				const nTypeI = nCollection:mergeToAtomUnion()
				nTermList[i] = self:RefineTerm(nTypeI)
			end
			-- step 4. merge 1
			const nTypeCaseList:List(clazz.TypeCasePair) = {}
			for _, nType1TupleCase in pairs(nType1TupleCaseList) do
				const nType1 = nType1TupleCase[1]
				const nTypeTuple = nType1TupleCase[2]
				const nCase = nType1TupleCase[3]
				for i=2,nMaxLength do
					nCase:put_and(nTermList[i]!:attachImmutVariable(), nTypeTuple:get(i):checkAtomUnion())
				end
				nTypeCaseList[#nTypeCaseList + 1] = {
					nType1, nCase
				}
			end
			nTermList[1] = self._manager:mergeToRefineTerm(nTypeCaseList)
			return self:FixedTermTuple(nTermList, nTail)
		else
			self._runtime:nodeError(vNode, "meta_call function can't be Never")
			return self:FixedTermTuple({})
		end
	end)
	if ok then
		return err
	else
		return self:FixedTermTuple({})
	end
end

function BodyContext:META_CALL(
	vNode:clazz.IAstNode,
	vFuncTerm:clazz.RefineTerm,
	vLazyFunc:Fn():Ret(clazz.UTermTuple)
):Ret(clazz.UTermTuple)
	const nNewContext = self:newLocalContext(vNode)
	local nOpenPair:OrNil(OpenPair) = nil
	const nFuncArgCaseList:FuncArgCaseList = {}
	const nNil = self._manager.type.Nil
	const nRegion = assert(self._region, "region not setted")
	vFuncTerm:foreach(function(vFuncType, vVariableCase)
		local nArgTermTuple:OrNil(clazz.UTermTuple) = nil
		nRegion:withBranch(vVariableCase, function()
			nArgTermTuple = vLazyFunc()
		end)
		assert(nArgTermTuple, "must be true here")
		if vFuncType == nNil then
			self._runtime:nodeWarn(vNode, "nil as call func")
		elseif Truth.is(vFuncType) or TypeFunction.is(vFuncType) or OpenFunction.is(vFuncType) or LuaFunction.is(vFuncType) or PolyFunction.is(vFuncType) or AnyFunction.is(vFuncType) then
			if vFuncType:isOpen() then
				if not nOpenPair then
					nOpenPair = {vFuncType, nArgTermTuple}
				else
					error("can't mix use native function")
				end
			else
				nFuncArgCaseList[#nFuncArgCaseList + 1] = {
					vFuncType, nArgTermTuple, vVariableCase
				}
			end
		else
			self._runtime:nodeError(vNode, "TODO call by a not-function value, type="..tostring(vFuncType))
		end
	end)
	return self:_apply(vNode, nOpenPair, nFuncArgCaseList)
end

function BodyContext:META_INVOKE(
	vNode:clazz.IAstNode,
	vSelfTerm:clazz.RefineTerm,
	vName:String,
	vPolyArgs:List(clazz.UAllType),
	vArgTuple:clazz.FixedTermTuple
):Ret(clazz.UTermTuple)
	assert(vPolyArgs, "poly args can't be nil here")
	const nGetContext = self:newLocalContext(vNode)
	local nOpenPair:OrNil(OpenPair) = nil
	const nFuncArgCaseList:FuncArgCaseList = {}
	const nNil = self._manager.type.Nil
	vSelfTerm:foreach(function(vSelfType, vVariableCase)
		if vSelfType == nNil then
			self._runtime:nodeWarn(vNode, "nil as invoke self")
		else
			const nNewArgTuple = self:UTermTupleByAppend({self:RefineTerm(vSelfType)}, vArgTuple)
			const nFuncType = vSelfType:meta_get_invoke(nGetContext, self:Literal(vName))
			nFuncType:foreach(function(vSingleFuncType)
				if vSingleFuncType == nNil then
					self._runtime:nodeWarn(vNode, "nil as invoke func")
				elseif Truth.is(vSingleFuncType) or TypeFunction.is(vSingleFuncType) or OpenFunction.is(vSingleFuncType) or LuaFunction.is(vSingleFuncType) or PolyFunction.is(vSingleFuncType) or AnyFunction.is(vSingleFuncType) then
					if vSingleFuncType:isOpen() then
						if not nOpenPair then
							nOpenPair = {vSingleFuncType, nNewArgTuple}
						else
							error("can't mix use native function")
						end
					else
						nFuncArgCaseList[#nFuncArgCaseList + 1] = {
							vSingleFuncType, nNewArgTuple, vVariableCase,
							self=vSelfType,
						}
					end
				else
					self._runtime:nodeError(vNode, "TODO non-function-call TODO"..tostring(vSingleFuncType))
				end
			end)
		end
	end)
	return self:_apply(vNode, nOpenPair, nFuncArgCaseList, vPolyArgs)
end

function BodyContext:META_EQ_NE(
	vNode:clazz.IAstNode,
	vIsEq:Boolean,
	vLeftTerm:clazz.RefineTerm,
	vRightTerm:clazz.RefineTerm
):Ret(clazz.RefineTerm)
	const nTypeCaseList:List(clazz.TypeCasePair) = {}
	vLeftTerm:foreach(function(vLeftType, vLeftVariableCase)
		vRightTerm:foreach(function(vRightType, vRightVariableCase)
			local nReType:OrNil(clazz.UAtomUnion) = nil
			if vLeftType:isSingleton() and vRightType:isSingleton() then
				-- TODO check for named type
				const nTypeIsEq = vLeftType == vRightType
				if vIsEq == nTypeIsEq then
					nReType = self._manager.type.True
				else
					nReType = self._manager.type.False
				end
			elseif not (vLeftType & vRightType):isNever() then
				nReType = self._manager.type.Boolean:checkAtomUnion()
			else
				if vIsEq then
					nReType = self._manager.type.False
				else
					nReType = self._manager.type.True
				end
			end
			nTypeCaseList[#nTypeCaseList + 1] = {nReType, vLeftVariableCase & vRightVariableCase}
		end)
	end)
	return self._manager:mergeToRefineTerm(nTypeCaseList)
end

function BodyContext:META_BOP_SOME(
	vNode:clazz.IAstNode,
	vOper:String,
	vLeftTerm:clazz.RefineTerm,
	vRightTerm:clazz.RefineTerm
):Ret(clazz.RefineTerm)
	const nBopContext = self:newLocalContext(vNode)
	const nCollection = self._manager:TypeCollection()
	vLeftTerm:foreach(function(vLeftType, vLeftVariableCase)
		const nLeftHigh, nLeftFunc = vLeftType:meta_bop_func(nBopContext, vOper)
		if nLeftHigh then
			const nRightType = vRightTerm:getType()
			const nTermTuple = self:FixedTermTuple({vLeftTerm:filter(vLeftType), vRightTerm})
			const nRetTuples = nLeftFunc:meta_call(self:newLocalContext(vNode), nTermTuple)
			nCollection:put(nRetTuples:getFirstType())
		else
			vRightTerm:foreach(function(vRightType, vRightVariableCase)
				const nRightHigh, nRightFunc = vRightType:meta_bop_func(nBopContext, vOper)
				if nRightHigh then
					const nTermTuple = self:FixedTermTuple({vLeftTerm:filter(vLeftType), vRightTerm:filter(vRightType)})
					const nRetTuples = nRightFunc:meta_call(self:newLocalContext(vNode), nTermTuple)
					nCollection:put(nRetTuples:getFirstType())
				else
					if nLeftFunc and nRightFunc and nLeftFunc == nRightFunc then
						const nTermTuple = self:FixedTermTuple({vLeftTerm:filter(vLeftType), vRightTerm:filter(vRightType)})
						const nRetTuples = nLeftFunc:meta_call(self:newLocalContext(vNode), nTermTuple)
						nCollection:put(nRetTuples:getFirstType())
					else
						self._runtime:nodeError(vNode, "invalid bop:"..vOper)
					end
				end
			end)
		end
	end)
	return self._manager:RefineTerm(nCollection:mergeToAtomUnion())
end

function BodyContext:META_UOP(
	vNode:clazz.IAstNode,
	vOper:String,
	vData:clazz.RefineTerm
):Ret(clazz.RefineTerm)
	const nUopContext = self:newLocalContext(vNode)
	const nTypeCaseList:List(clazz.TypeCasePair) = {}
	if vOper == "#" then
		vData:foreach(function(vType, vVariableCase)
			nTypeCaseList[#nTypeCaseList + 1] = {
				vType:meta_len(nUopContext),
				vVariableCase
			}
		end)
	else
		vData:foreach(function(vType, vVariableCase)
			nTypeCaseList[#nTypeCaseList + 1] = {
				vType:meta_uop_some(nUopContext, vOper),
				vVariableCase
			}
		end)
	end
	return self._manager:mergeToRefineTerm(nTypeCaseList)
end

function.open BodyContext:nodePcall(vNode:clazz.IAstNode, vFunc, ...)
	const ok, err = xpcall(vFunc, function(exc:Union(String, clazz.Exception)):Ret(clazz.Exception)
		if Exception.is(exc) then
			return exc
		else
			print("[ERROR] "..tostring(vNode), tostring(exc))
			print(debug.traceback())
			return Exception.new("[FATAL]"..tostring(exc), vNode)
		end
	end, ...)
	if not ok then
		error(err)
	end
	return ok, err
end

function BodyContext:getRegion():Ret(clazz.Region)
	return (assert(self._region, "region not create when context getRegion"))
end

function BodyContext:getParentContext():Ret(OrFalse(clazz.BodyContext))
	return self._parentContext
end

function BodyContext:FUNC_NEW(vNode:clazz.IAstNode,
	vFnNewInfo:clazz.FuncNewInfo,
	vParRetMaker:clazz.GenMaker
):Ret(clazz.LuaFunction)
	const nRegion = self._region
	const nUpValueCase = nRegion and nRegion:topBranch():getCase()
	return FunctionBuilder.new(self._manager, self, vNode, nUpValueCase, vFnNewInfo, vParRetMaker):build()
end

(@let.PairMaker = import("thlua.builder.TableBuilder").PairMaker)
function BodyContext:TABLE_NEW(vNode:clazz.IAstNode, vHintInfo:clazz.TLongHintInfo(clazz.TableLongHint), vPairMaker:PairMaker):Ret(clazz.LuaTable)
	local nBuilder = TableBuilder.new(self, vNode, vHintInfo, vPairMaker)
	return nBuilder:build()
end

function BodyContext:EVAL(vNode:clazz.IAstNode, vTerm:Truth):Ret(clazz.UAtomUnion)
	if RefineTerm.is(vTerm) then
		return vTerm:getType()
	else
		self:getRuntime():nodeError(vNode, "hint eval fail")
		error("hint eval fail")
	end
end

function BodyContext:CAST_HINT(vNode:clazz.IAstNode, vTerm:clazz.RefineTerm, vCastKind:node.CastKindEnum, ...:Any):Ret(clazz.RefineTerm)
	-- TODO check cast valid
	if vCastKind == Enum.CastKind_POLY then
		const nTypeCaseList:List(clazz.TypeCasePair) = {}
		const nTemplateList:List(clazz.UAllType) = self._manager:easyToTypeList(...)
		vTerm:foreach(function(vType, vVariableCase)
			const nAfterType = vType:castPoly(self, nTemplateList)
			if nAfterType then
				nTypeCaseList[#nTypeCaseList + 1] = {nAfterType, vVariableCase}
			else
				nTypeCaseList[#nTypeCaseList + 1] = {vType, vVariableCase}
			end
		end)
		return self._manager:mergeToRefineTerm(nTypeCaseList)
	else
		if not vCastKind then
			vContext:error("unexcepted castkind:"..tostring(vCastKind))
		end
		const nDst = assert(..., "hint type can't be nil")
		const nDstType = self._manager:easyToType(nDst)
		if not nDstType:includeAll(vTerm:getType()) then
			-- self:getRuntime():nodeError(vNode, "@ cast fail")
		end
		return self._manager:RefineTerm(nDstType)
	end
end

function BodyContext:matchParToDots(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer,
	vHintDots:OrFalse(clazz.AutoFlag, clazz.UAllType)
):Ret(OrFalse(clazz.UTermTuple))
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		nTailTermList[#nTailTermList + 1] = vTermTuple:get(self, i)
	end
	const nTermTail = vTermTuple:getTail()
	if not AutoTail.is(nTermTail) then
		if vHintDots == AutoFlag then
			if nTermTail then
				return self:UTermTupleByTail(nTailTermList, DotsTail.new(self, nTermTail:getRepeatType()))
			else
				return self:UTermTupleByTail(nTailTermList)
			end
		elseif vHintDots then
			return self:UTermTupleByTail({}, DotsTail.new(self, vHintDots))
		else
			if nTermTail then
				self:getRuntime():nodeError(vNode, "args dots not match par")
			end
			return false
		end
	else
		const nMore = vParNum - #vTermTuple
		if vHintDots == AutoFlag then
			if nMore <= 0 then
				return self:UTermTupleByTail(nTailTermList, nTermTail)
			else
				return self:UTermTupleByTail(nTailTermList, nTermTail:openTailFrom(self, nMore + 1))
			end
		elseif vHintDots then
			if nMore <= 0 then
				nTermTail:sealTailFrom(self, 1, vHintDots)
			else
				nTermTail:sealTailFrom(self, nMore + 1, vHintDots)
			end
			return self:UTermTupleByTail({}, DotsTail.new(self, vHintDots))
		else
			if nMore <= 0 then
				nTermTail:sealTailFrom(self, 1, true)
			else
				nTermTail:sealTailFrom(self, nMore + 1, true)
			end
			return false
		end
	end
end

function BodyContext:matchToParHintStruct(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParHintStruct:clazz.ParHintStruct
):Ret(List(clazz.UAutoTerm), OrFalse(clazz.UTermTuple))
	const nHintDots = vParHintStruct.dots
	const nNamedTermList:List(clazz.UAutoTerm) = {}
	for i=1, #vTermTuple do
		const nAutoTerm = vTermTuple:get(self, i)
		local nHintType = vParHintStruct[i]
		const nMore = i-#vParHintStruct
		if nMore > 0 then
			if nHintDots then
				if nHintDots ~= AutoFlag then
					nHintType = nHintDots
				end
			else
				nHintType = self._manager.type.Nil
			end
		end
		const nPut = (nHintType and nHintType ~= AutoFlag) and self:assignTermToType(nAutoTerm, nHintType) or nAutoTerm
		if nMore <= 0 then
			nNamedTermList[i] = nPut
		end
	end
	for i=#vTermTuple + 1, #vParHintStruct do
		const nAutoTerm = vTermTuple:get(self, i)
		const nHintType = vParHintStruct[i]!
		nNamedTermList[i] = (nHintType ~= AutoFlag) and self:assignTermToType(nAutoTerm, nHintType) or nAutoTerm
	end
	return nNamedTermList, self:matchParToDots(vNode, vTermTuple, #vParHintStruct, vParHintStruct.dots or false)
end

function BodyContext:assignTermToType(vAutoTerm:clazz.UAutoTerm, vDstType:clazz.UAllType):Ret(clazz.UAutoTerm)
	const nSrcType = vAutoTerm:getType()
	if not nSrcType then
		vAutoTerm:setAutoCastType(self, vDstType)
	else
		if not self:castLuaType(nSrcType, vDstType) and not vDstType:includeAll(nSrcType) then
			self:error("assign but type not match")
		end
	end
	return self:RefineTerm(vDstType)
end

function BodyContext:castLuaType(vRawSrcType:clazz.UAllType, vRawDstType:clazz.UAllType):Ret(OrFalse(clazz.UAtomUnion))
	const nSrcType = vRawSrcType:checkAtomUnion()
	const nDstType = vRawDstType:checkAtomUnion()
	if LuaFunction.is(nSrcType) then
		const nFnPartType = nDstType:fnPartType()
		if TypeFunction.is(nFnPartType) then
			return nSrcType:cast(self, nFnPartType)
		end
	else
		const nSrcTable = nSrcType:objectPartType()
		const nDstObjectPart = nDstType:objectPartType()
		if LuaTable.is(nSrcTable) and not nDstObjectPart:isNever() then
			const nCastResult = nSrcTable:cast(self, nDstType:objectPartType())
			if nCastResult then
				return self._manager:checkedUnion(nSrcTable, nCastResult)
			else
				return false
			end
		end
	end
	return false
end

function BodyContext:newSealContext(vNode:clazz.IAstNode):Ret(clazz.BodyContext)
	return self._runtime:newContext(vNode, self)
end

function BodyContext:newOperContext(vNode:clazz.IAstNode):Ret(clazz.OperContext)
	return OperContext.new(self._runtime, vNode, self)
end

function BodyContext:newLocalContext(vNode:clazz.IAstNode):Ret(clazz.BodyContext)
	return self._runtime:newContext(vNode, self)
end

function BodyContext:newOpenContext(vNode:clazz.IAstNode):Ret(clazz.BodyContext)
	const nContext = self._runtime:newContext(vNode, self)
	nContext:setOpen()
	return nContext
end

function BodyContext:UTermTupleByAppend(vTermList:List(clazz.UAutoTerm), vTermTuple:OrNil(False, clazz.UTermTuple)):Ret(clazz.UTermTuple)
	if vTermTuple then
		for i=1, #vTermTuple do
			const nTerm = (assert(vTermTuple:rawget(i), "term tuple length error"))
			vTermList[#vTermList + 1] = nTerm
		end
		return self:UTermTupleByTail(vTermList, vTermTuple:getTail())
	else
		return self:UTermTupleByTail(vTermList, false)
	end
end

function BodyContext:UTermTupleByTail(vTermList:List(clazz.UAutoTerm), vTail:OrNil(False, clazz.DotsTail, clazz.AutoTail)):Ret(clazz.UTermTuple)
	if AutoTail.is(vTail) then
		vTail = vTail:recurPutTermWithTail(vTermList)
	end
	if AutoTail.is(vTail) then
		return TermTuple.new@<true>(self, true, vTermList, vTail or false, false)
	end
	local nHasAuto = false
	if not nHasAuto then
		for i=1, #vTermList do
			const nAuto = vTermList[i]!
			if AutoHolder.is(nAuto) then
				const nTerm = nAuto:getRefineTerm()
				if not nTerm then
					nHasAuto = true
					break
				else
					vTermList[i] = nAuto
				end
			end
		end
	end
	if nHasAuto then
		return TermTuple.new@<true>(self, true, vTermList, vTail or false, false)
	else
		return TermTuple.new@<false>(self, false, vTermList @ List(clazz.RefineTerm), vTail or false, false)
	end
end

function BodyContext:FixedTermTuple(vTermList:List(clazz.RefineTerm), vDotsType:OrNil(False, clazz.UAllType), vTypeTuple:OrNil(clazz.UTypeTuple)):Ret(clazz.FixedTermTuple)
	if vDotsType then
		const nTail = DotsTail.new(self, vDotsType)
		return TermTuple.new@<false>(self, false, vTermList, nTail, vTypeTuple or false)
	else
		return TermTuple.new@<false>(self, false, vTermList, false, vTypeTuple or false)
	end
end

function BodyContext:getSealContext():Ret(clazz.BodyContext)
	if self._sealContext ~= self then
		return self
	else
		return self._sealContext
	end
end

function BodyContext:recordClassFactory(vFunc:clazz.ClassFactory)
	if self._sealContext ~= self then
		self._sealContext:recordClassFactory(vFunc)
		return
	else
		const nSet = self._classFnSet
		if nSet then
			nSet[vFunc] = true
		else
			vFunc:startBuild()
		end
	end
end

function BodyContext:recordAutoFunction(vFunc:clazz.AutoFunction)
	if self._sealContext ~= self then
		self._sealContext:recordAutoFunction(vFunc)
		return
	else
		const nSet = self._funcMakerSet
		if nSet then
			nSet[vFunc] = true
		else
			vFunc:startBuild()
		end
	end
end

function BodyContext:seal()
	if self._sealContext == self then
		const nClassFnSet = assert(self._classFnSet, "class set must be true here")
		self._classFnSet = false
		for fn, v in pairs(nClassFnSet) do
			fn:startBuild()
		end
		const nFuncMakerSet = assert(self._funcMakerSet, "maker set must be true here")
		self._funcMakerSet = false
		for fn, v in pairs(nFuncMakerSet) do
			fn:startBuild()
		end
	end
end

function BodyContext:getNamespace():Ret(clazz.Namespace)
	local nSpace = self._namespace
	return assert(nSpace, "space is false when get")
end

return BodyContext
