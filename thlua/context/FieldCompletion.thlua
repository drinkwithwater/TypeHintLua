
const class = require "thlua.class"
const CompletionKind = require "thlua.context.CompletionKind"
const MemberFunction = require "thlua.type.func.MemberFunction"
const BaseFunction = require "thlua.type.func.BaseFunction"
const ClassFactory = require "thlua.type.func.ClassFactory"
const Reference = require "thlua.refer.Reference"
const SpaceTable = require "thlua.refer.SpaceTable"
const SpaceBuiltin = require "thlua.refer.SpaceBuiltin"

const TemplateReferCom = require "thlua.refer.TemplateReferCom"
const AsyncUnion = require "thlua.refer.AsyncUnion"

const FloatLiteral = require "thlua.type.basic.FloatLiteral"
const IntegerLiteral = require "thlua.type.basic.IntegerLiteral"
const StringLiteral = require "thlua.type.basic.StringLiteral"
const BooleanLiteral= require "thlua.type.basic.BooleanLiteral"

(@do
	let.clazz = import($class).clazz
	clazz.ICompletion = Interface {
		putCompletion=Mfn(clazz.FieldCompletion)
	}
end)

const FieldCompletion = class@<clazz.FieldCompletion, false>()

function.open FieldCompletion:ctor()
	self._passDict = {}@Dict(clazz.IAtomType, True)
	self._keyToKind = {}@Dict(String, Integer)
end

const LiteralMetaDict:Dict(Truth, True) = {
	[StringLiteral.meta]= true,
	[IntegerLiteral.meta]= true,
	[FloatLiteral.meta]= true,
	[BooleanLiteral.meta]= true,
}

const function isLiteral(vType:clazz.UAtomUnion):Ret(Boolean)
	const nMeta = getmetatable(vType)
	if nMeta and LiteralMetaDict[nMeta] then
		return true
	else
		return false
	end
end

function FieldCompletion:putField(vKey:String, vValue:clazz.UMustType)
	const nType = vValue:checkAtomUnion()
	if MemberFunction.is(nType) then
		self._keyToKind[vKey] = CompletionKind.Method
	elseif ClassFactory.is(nType) then
		self._keyToKind[vKey] = CompletionKind.Function
	elseif BaseFunction.is(nType) then
		self._keyToKind[vKey] = CompletionKind.Function
	elseif isLiteral(nType) then
		self._keyToKind[vKey] = CompletionKind.Constant
	else
		self._keyToKind[vKey] = CompletionKind.Field
	end
end

function FieldCompletion:putSpaceField(vKey:String, vValue:clazz.LocalSpaceValue)
	if SpaceTable.checkSpace(vValue) then
		self._keyToKind[vKey] = CompletionKind.Module
	elseif SpaceBuiltin.is(vValue) then
		self._keyToKind[vKey] = CompletionKind.Function
	elseif Reference.is(vValue) then
		const nCom = vValue:getComNowait()
		if AsyncUnion.is(nCom) then
			self._keyToKind[vKey] = CompletionKind.Class
		elseif TemplateReferCom.is(nCom) then
			self._keyToKind[vKey] = CompletionKind.Function
		else
			self._keyToKind[vKey] = CompletionKind.Variable
		end
	else
		self._keyToKind[vKey] = CompletionKind.Class
	end
end

function FieldCompletion:testAndSetPass(vAtomType:clazz.IAtomType):Ret(Boolean)
	if self._passDict[vAtomType] then
		return false
	else
		self._passDict[vAtomType] = true
		return true
	end
end

function FieldCompletion:foreach(vOnPair:Fn(String, Integer))
	for k,v in pairs(self._keyToKind) do
		vOnPair(k, v)
	end
end

return FieldCompletion
