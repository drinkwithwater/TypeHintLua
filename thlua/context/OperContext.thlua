
const class = require "thlua.class"

const RefineTerm = require "thlua.term.RefineTerm"
const VariableCase = require "thlua.term.VariableCase"
const AutoHolder = require "thlua.auto.AutoHolder"
const TypeFunction = require "thlua.func.TypeFunction"
const BaseTable = require "thlua.object.BaseTable"
const AutoTable = require "thlua.object.AutoTable"
const AutoFunction = require "thlua.func.AutoFunction"

const TermTuple = require "thlua.tuple.TermTuple"
const AutoFlag = require "thlua.auto.AutoFlag"
const AutoHolder = require "thlua.auto.AutoHolder"
const DotsTail = require "thlua.tuple.DotsTail"
const AutoTail = require "thlua.auto.AutoTail"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
end)

const OperContext = class@<clazz.OperContext, false>()

function.open OperContext:ctor(
	vNode:clazz.IAstNode,
	vStack:clazz.BaseStack,
	vManager:clazz.TypeManager
)
	self._node=vNode
	self._manager=vManager
	self._stack = vStack
end

function OperContext:UTermTupleByAppend(vTermList:List(clazz.UAutoTerm), vTermTuple:OrNil(False, clazz.UTermTuple)):Ret(clazz.UTermTuple)
	if vTermTuple then
		for i=1, #vTermTuple do
			const nTerm = (assert(vTermTuple:rawget(i), "term tuple length error"))
			vTermList[#vTermList + 1] = nTerm
		end
		return self:UTermTupleByTail(vTermList, vTermTuple:getTail())
	else
		return self:UTermTupleByTail(vTermList, false)
	end
end

function OperContext:UTermTupleByTail(vTermList:List(clazz.UAutoTerm), vTail:OrNil(False, clazz.DotsTail, clazz.AutoTail)):Ret(clazz.UTermTuple)
	if AutoTail.is(vTail) then
		vTail = vTail:recurPutTermWithTail(vTermList)
	end
	if AutoTail.is(vTail) then
		return TermTuple.new@<true>(self, true, vTermList, vTail or false, false)
	end
	local nHasAuto = false
	if not nHasAuto then
		for i=1, #vTermList do
			const nAuto = vTermList[i]!
			if AutoHolder.is(nAuto) then
				const nTerm = nAuto:getRefineTerm()
				if not nTerm then
					nHasAuto = true
					break
				else
					vTermList[i] = nAuto
				end
			end
		end
	end
	if nHasAuto then
		return TermTuple.new@<true>(self, true, vTermList, vTail or false, false)
	else
		return TermTuple.new@<false>(self, false, vTermList @ List(clazz.RefineTerm), vTail or false, false)
	end
end

function OperContext:FixedTermTuple(vTermList:List(clazz.RefineTerm), vDotsType:OrNil(False, clazz.UAllType), vTypeTuple:OrNil(clazz.UTypeTuple)):Ret(clazz.FixedTermTuple)
	if vDotsType then
		const nTail = DotsTail.new(self, vDotsType)
		return TermTuple.new@<false>(self, false, vTermList, nTail, vTypeTuple or false)
	else
		return TermTuple.new@<false>(self, false, vTermList, false, vTypeTuple or false)
	end
end

function OperContext:castLuaType(vRawSrcType:clazz.UAllType, vRawDstType:clazz.UAllType):Ret(OrFalse(clazz.UAtomUnion))
	const nSrcType = vRawSrcType:checkAtomUnion()
	const nDstType = vRawDstType:checkAtomUnion()
	if AutoFunction.is(nSrcType) then
		const nFnPartType = nDstType:fnPartType()
		if TypeFunction.is(nFnPartType) then
			nSrcType:checkWhenCast(self, nFnPartType)
			return nFnPartType
		end
	else
		const nSrcTable = nSrcType:objectPartType()
		const nDstObjectPart = nDstType:objectPartType()
		if AutoTable.is(nSrcTable) and not nDstObjectPart:isNever() then
			const nCastResult = nSrcTable:cast(self, nDstType:objectPartType())
			if nCastResult then
				return self._manager:checkedUnion(nSrcTable, nCastResult)
			else
				return false
			end
		end
	end
	return false
end

function OperContext:matchParToDots(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParNum:Integer,
	vHintDots:OrFalse(clazz.AutoFlag, clazz.UAllType)
):Ret(OrFalse(clazz.UTermTuple))
	const nTailTermList:List(clazz.UAutoTerm) = {}
	for i=vParNum + 1, #vTermTuple do
		nTailTermList[#nTailTermList + 1] = vTermTuple:get(self, i)
	end
	const nTermTail = vTermTuple:getTail()
	if not AutoTail.is(nTermTail) then
		if vHintDots == AutoFlag then
			if nTermTail then
				return self:UTermTupleByTail(nTailTermList, DotsTail.new(self, nTermTail:getRepeatType()))
			else
				return self:UTermTupleByTail(nTailTermList)
			end
		elseif vHintDots then
			return self:UTermTupleByTail({}, DotsTail.new(self, vHintDots))
		else
			if nTermTail then
				self:error("args dots not match par")
			end
			return false
		end
	else
		const nMore = vParNum - #vTermTuple
		if vHintDots == AutoFlag then
			if nMore <= 0 then
				return self:UTermTupleByTail(nTailTermList, nTermTail)
			else
				return self:UTermTupleByTail(nTailTermList, nTermTail:openTailFrom(self, nMore + 1))
			end
		elseif vHintDots then
			if nMore <= 0 then
				nTermTail:sealTailFrom(self, 1, vHintDots)
			else
				nTermTail:sealTailFrom(self, nMore + 1, vHintDots)
			end
			return self:UTermTupleByTail({}, DotsTail.new(self, vHintDots))
		else
			if nMore <= 0 then
				nTermTail:sealTailFrom(self, 1, true)
			else
				nTermTail:sealTailFrom(self, nMore + 1, true)
			end
			return false
		end
	end
end

function OperContext:matchToParHintStruct(
	vNode:clazz.IAstNode,
	vTermTuple:clazz.UTermTuple,
	vParHintStruct:clazz.ParHintStruct
):Ret(List(clazz.UAutoTerm), OrFalse(clazz.UTermTuple))
	const nHintDots = vParHintStruct.dots
	const nNamedTermList:List(clazz.UAutoTerm) = {}
	for i=1, #vTermTuple do
		const nAutoTerm = vTermTuple:get(self, i)
		local nHintType = vParHintStruct[i]
		const nMore = i-#vParHintStruct
		if nMore > 0 then
			if nHintDots then
				if nHintDots ~= AutoFlag then
					nHintType = nHintDots
				end
			else
				nHintType = self._manager.type.Nil
			end
		end
		const nPut = (nHintType and nHintType ~= AutoFlag) and self:assignTermToType(nAutoTerm, nHintType) or nAutoTerm
		if nMore <= 0 then
			nNamedTermList[i] = nPut
		end
	end
	for i=#vTermTuple + 1, #vParHintStruct do
		const nAutoTerm = vTermTuple:get(self, i)
		const nHintType = vParHintStruct[i]!
		nNamedTermList[i] = (nHintType ~= AutoFlag) and self:assignTermToType(nAutoTerm, nHintType) or nAutoTerm
	end
	return nNamedTermList, self:matchParToDots(vNode, vTermTuple, #vParHintStruct, vParHintStruct.dots or false)
end

function OperContext:assignTermToType(vAutoTerm:clazz.UAutoTerm, vDstType:clazz.UAllType):Ret(clazz.UAutoTerm)
	const nSrcType = vAutoTerm:getType()
	if not nSrcType then
		vAutoTerm:setAutoCastType(self, vDstType)
	else
		if not self:castLuaType(nSrcType, vDstType) and not vDstType:includeAll(nSrcType) then
			self:error("assign but type not match")
		end
	end
	return self:RefineTerm(vDstType)
end

function OperContext:AutoHolder():Ret(clazz.AutoHolder)
	return AutoHolder.new(self)
end

function OperContext:newOpenStack(vBodyFn:clazz.OpenFunction):Ret(clazz.OpenStack)
	return self._stack:getRuntime():OpenStack(self._node, self._stack, vBodyFn)
end

function OperContext:RefineTerm(vType:clazz.UAllType):Ret(clazz.RefineTerm)
	return RefineTerm.new(self._node, vType:checkAtomUnion())
end

function OperContext:NeverTerm():Ret(clazz.RefineTerm)
	return RefineTerm.new(self._node, self._manager.type.Never)
end

function OperContext:mergeToRefineTerm(vTypeCasePairList:List(clazz.TypeCasePair)):Ret(clazz.RefineTerm)
	const nKeyUnion, nTypeDict = self._manager:mergePairList@<clazz.VariableCase>(vTypeCasePairList)
	return RefineTerm.new(self._node, nKeyUnion, nTypeDict)
end

function OperContext:NilTerm():Ret(clazz.RefineTerm)
	return RefineTerm.new(self._node, self._manager.type.Nil)
end

function OperContext:error(...:Truth)
	self._stack:getRuntime():nodeError(self._node, ...)
end

function OperContext:warn(...:Truth)
	self._stack:getRuntime():nodeWarn(self._node, ...)
end

function OperContext:info(...:Truth)
	self._stack:getRuntime():nodeInfo(self._node, ...)
end

function OperContext:getNode():Ret(clazz.IAstNode)
	return self._node
end

function OperContext:getRuntime():Ret(clazz.Runtime)
	return self._stack:getRuntime()
end

function OperContext:getTypeManager():Ret(clazz.TypeManager)
	return self._manager
end

function OperContext:getStack()
	return self._stack
end

return OperContext
