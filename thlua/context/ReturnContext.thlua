
const class = require "thlua.class"
const AssignContext = require "thlua.context.AssignContext"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ReturnContext = class@<clazz.ReturnContext, false>(AssignContext)

function.open ReturnContext:ctor(...)
end

function ReturnContext:returnMatchTuple(
	vSrcTuple:clazz.UTypeTuple,
	vDstTuple:clazz.UTypeTuple
):Ret(False):Ret(True, Boolean)
	local nCastResult = true
	for i=1, #vSrcTuple do
		const nDstType = vDstTuple:get(i):checkAtomUnion()
		const nSrcType = vSrcTuple:get(i):checkAtomUnion()
		const nIncludeType, nCastSucc = self:includeAndCast(nDstType, nSrcType)
		if not nIncludeType then
			return false
		else
			nCastResult = nCastResult and nCastSucc
		end
	end
	for i=#vSrcTuple + 1, #vDstTuple do
		const nDstType = vDstTuple:get(i):checkAtomUnion()
		const nSrcType = vSrcTuple:get(i):checkAtomUnion()
		const nIncludeType, nCastSucc = self:includeAndCast(nDstType, nSrcType)
		if not nIncludeType then
			return false
		else
			nCastResult = nCastResult and nCastSucc
		end
	end
	const nSrcRepeatType = vSrcTuple:getRepeatType()
	if nSrcRepeatType then
		const nDstRepeatType = vDstTuple:getRepeatType()
		if not nDstRepeatType then
			return false
		elseif not nDstRepeatType:includeAll(nSrcRepeatType) then
			return false
		end
	end
	return true, nCastResult
end

return ReturnContext
