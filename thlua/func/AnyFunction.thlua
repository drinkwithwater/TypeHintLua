
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const Exception = require "thlua.Exception"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const TypeFunction = require "thlua.func.TypeFunction"
const PolyFunction = require "thlua.func.PolyFunction"

const BaseFunction = require "thlua.func.BaseFunction"
const class = require "thlua.class"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const AnyFunction = class@<clazz.AnyFunction, false>(BaseFunction)

function AnyFunction:detailString(vToStringCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
	return "AnyFunction"
end

function AnyFunction:isOpen():Ret(False)
	return false
end

function AnyFunction:meta_call(vContext, vTypeTuple)
	return self._manager:VoidRetTuples()
end

function AnyFunction:assumeIncludeAtom(vAssumeSet, vRight)
	if BaseFunction.is(vRight) then
		return self
	else
		return false
	end
end

function AnyFunction:assumeIntersectAtom(vAssumeSet, vRight)
	if BaseFunction.is(vRight) then
		return vRight
	else
		return false
	end
end

function AnyFunction:mayRecursive()
	return false
end

return AnyFunction
