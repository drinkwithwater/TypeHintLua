
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const Exception = require "thlua.Exception"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const TypeFunction = require "thlua.func.TypeFunction"
const PolyFunction = require "thlua.func.PolyFunction"
const LuaFunction = require "thlua.func.LuaFunction"

const AnyFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function:class(class.AnyFunction) AnyFunction.new(vManager:class.TypeManager):impl(class.IAtomType)
	local self = setmetatable({.class
		_manager=vManager,
		bits=TYPE_BITS.FUNCTION,
		id=vManager:genTypeId(),
	}, AnyFunction)
	return self
end

function AnyFunction:detailString(vToStringCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
	return "AnyFunction"
end

function AnyFunction:isOpen():Ret(False)
	return false
end

function AnyFunction:native_type()
	return self._manager:Literal("function")
end

function AnyFunction:meta_call(vContext, vTypeTuple)
	return self._manager:VoidRetTuples()
end

function AnyFunction:assumeContainAtom(vAssumeSet, vRight)
	if vRight == self then
		return self
	elseif PolyFunction.is(vRight) then
		return self
	elseif TypeFunction.is(vRight) then
		return self
	elseif LuaFunction.is(vRight) and not vRight:isOpen() then
		return self
	else
		return false
	end
end

function AnyFunction:assumeIntersectAtom(vAssumeSet, vRight)
	if vRight == self then
		return self
	elseif PolyFunction.is(vRight) then
		return vRight
	elseif TypeFunction.is(vRight) then
		return vRight
	elseif LuaFunction.is(vRight) and not vRight:isOpen() then
		return vRight
	else
		return false
	end
end

function AnyFunction:fnPartType()
	return self
end

function AnyFunction:mayRecursive()
	return false
end

function AnyFunction:isSingleton()
	return false
end

function.open AnyFunction.is(vType):isguard(class.AnyFunction)
	return getmetatable(vType) == AnyFunction
end

return AnyFunction
