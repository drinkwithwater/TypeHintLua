
const TypedFunction = require "thlua.func.TypedFunction"
const SealFunction = require "thlua.func.SealFunction"
const Exception = require "thlua.Exception"

const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const AutoFunction = class@<clazz.AutoFunction, false>(SealFunction)
AutoFunction.__tostring=function(self:clazz.AutoFunction)
	return "autofn@"..tostring(self._node)
end

function.open AutoFunction:ctor(vManager:clazz.TypeManager, ...)
	self._castList={}@List(clazz.TypedFunction)
	self._firstAssign = false @OrFalse(clazz.AssignContext)
end

function AutoFunction:isCastable()
	return not self._firstAssign
end

function AutoFunction:setAssigned(vContext)
	self._firstAssign = vContext
end

function AutoFunction:checkWhenCast(vContext:clazz.OperContext, vTypeFn:clazz.TypedFunction):Ret(Boolean)
	if not self._headStartEvent:isWaken() then
		const nList = self._castList
		nList[#nList + 1] = vTypeFn
		return true
	else
		return false
	end
end

function AutoFunction:pickCastTypeFn():Ret(OrFalse(clazz.TypedFunction))
	local nCastFn:OrFalse(clazz.TypedFunction) = false
	for k,v in pairs(self._castList) do
		nCastFn = v
	end
	return nCastFn
end

return AutoFunction
