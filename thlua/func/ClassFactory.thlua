
const TermCase = require "thlua.term.TermCase"
const FnComClass = require "thlua.func.FnComClass"

const ClassFactory = FnComClass()

(@let.class = import("thlua.type.TypeClass").class)

function:class(class.ClassFactory) ClassFactory.new(vManager:class.TypeManager, vLuaFunction:class.LuaFunction):impl(class.IFnCom)
	local self = setmetatable({.class
		_manager=vManager,
		_luaFunction=vLuaFunction,
		_refer=nil@class.Reference,
		_referCom=nil@class.ClassReferCom,
	}, ClassFactory)
	return self
end

function ClassFactory:bindReferCom(vReferCom:class.ClassReferCom, vRefer:class.Reference)
	self._referCom = vReferCom
	self._refer = vRefer
end

function ClassFactory:waitBuild()
	self._referCom:waitBuild()
end

function ClassFactory:onSetMetaTable()
	self:_wakeupBuild()
end

function ClassFactory:_wakeupBuild()
	self._referCom:_wakeupBuild()
end

function ClassFactory:matchTypeFn(vContext, vTypeTuple)
	return assert(self._referCom:getTypeFn())
end

function ClassFactory:regionTableSelf(
	vContext:class.Context,
	vNode:class.IAstNode,
	vCallback:Fn(class.LuaTable)
):Ret(class.LuaTable)
	const nLuaTable = self:getLuaTable()
	vCallback(nLuaTable)
	return nLuaTable
end

function ClassFactory:getLuaTable():Ret(class.LuaTable)
	return (assert(self._referCom:getResultType(), "lua table not setted"))
end

function ClassFactory:getInterface():Ret(class.MetaObject)
	return (assert(self._referCom:getInterface(), "lua table's interface not setted"))
end

function.open ClassFactory.is(v):isguard(class.ClassFactory)
	return getmetatable(v) == ClassFactory
end

return ClassFactory
