
const ClassTable = require "thlua.object.ClassTable"
const SealFunction = require "thlua.func.SealFunction"
const Exception = require "thlua.Exception"

const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.BuildRunner = Fn(clazz.ClassTable):Ret(
		OrFalse(clazz.TypeFunction), Fn():Ret(clazz.TypeFunction)
	)
end)

const ClassFactory = class@<clazz.ClassFactory, false>(SealFunction)
function ClassFactory.__tostring(self:clazz.ClassFactory)
	return "class@"..tostring(self._node)
end

function.open ClassFactory:ctor(vManager:clazz.TypeManager, ...)
	const nTask = self._task
	self._classFinishEvent=nTask:makeEvent()
	self._classTable=ClassTable.new(self._manager, self)
end

function ClassFactory:getToString():Ret(String)
	return tostring(self._node)
end

function ClassFactory:getFnAwait():Ret(clazz.TypeFunction)
	if not self._typeFn then
		self._classTable:waitInit()
		self._headStartEvent:wakeup()
		self._headFinishEvent:wait()
		if not self._typeFn then
			self._bodyStartEvent:wakeup()
			self._classFinishEvent:wait()
			if not self._typeFn then
				self._bodyFinishEvent:wait()
			end
		end
	end
	return (assert(self._typeFn, "type function not setted after wait"))
end

function ClassFactory:getClassAwait():Ret(clazz.UAtomUnion)
	self._classTable:waitInit()
	return self._classTable
end

function ClassFactory:build(vRunner:BuildRunner)
	self._task:runAsync(function()
		self:_build(vRunner)
	end)
end

function ClassFactory:_build(vPreRunner:BuildRunner)
	self._headStartEvent:wait()
	self._classTable:waitInit()
	-- nClassType:linkNamedReference(self)
	const nTypeFn, nLateRunner = vPreRunner(self._classTable)
	if nTypeFn then
		self._typeFn = nTypeFn
	end
	self._headFinishEvent:wakeup()
	self._bodyStartEvent:wait()
	-- step 3. run build
	const nTypeFn = nLateRunner()
	if not self._typeFn then
		self._typeFn = nTypeFn
	end
	-- step 4. wakeup fn
	self._classFinishEvent:wakeup()
	self._bodyFinishEvent:wakeup()
end

function ClassFactory:onSetMetaTable()
	self._classFinishEvent:wakeup()
end

function ClassFactory:waitBuild()
	self:startBuild()
	if coroutine.running() ~= self._task:getSelfCo() then
		self._classFinishEvent:wait()
	end
end

return ClassFactory
