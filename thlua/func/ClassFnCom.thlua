
const TermCase = require "thlua.term.TermCase"
const FnComClass = require "thlua.func.FnComClass"

const ClassFnCom = FnComClass()

(@let.class = import("thlua.type.TypeClass").class)

function ClassFnCom.new(vManager:class.TypeManager, vLuaFunction:class.LuaFunction, vRefer:class.Reference)::RetClass(class.ClassFnCom, class.IFnCom)
	local self = setmetatable({::Self()
		_manager=vManager,
		_luaFunction=vLuaFunction,
		_newRefer=vRefer,
		_typeFunction=false@class.TypeFunction,
		_classTableCom=false@class.ClassTableCom,
		_once=false@Boolean,
		_onceHintNew=false@Boolean,
		_startSid=vManager:genSessionId(),
		_waitCoToSid={}@Dict(Thread, Integer),
		_buildFinish=false@Boolean,
	}, ClassFnCom)
	vLuaFunction:setFnCom(self)
	return self
end

function ClassFnCom:bind(vContext:class.UContext, vTableCom:class.ClassTableCom)
	self._classTableCom = vTableCom
	local nAutoArgs = self._luaFunction._autoArgs
	local nArgTuple = nAutoArgs:checkWhenLate(vContext)
	local nRetTuples = self._manager:SingleRetTuples(self._manager:Tuple(vTableCom:getLuaTable()))
	self._typeFunction = self._manager:Function(nArgTuple, nRetTuples)
end

function ClassFnCom:runBuild()
	const co = coroutine.running()
	self._manager:coWait(co, self._startSid)
	assert(not self._once)
	self._once = true
	local nContext = self._luaFunction:newInplaceOpenContext()
	local nTypeTuple = self._typeFunction:getArgTuple()
	self._luaFunction._runFunc(nContext, nTypeTuple:makeTermTuple())
	self._classTableCom:implement(nContext)
end

function ClassFnCom:wakeupBuild()
	self._buildFinish=true
	for co, sid in pairs(self._waitCoToSid) do
		self._manager:coWakeup(co, sid)
	end
end

function ClassFnCom:waitBuild()
	const nSelfCo = self._newRefer:getSelfCo()
	self._manager:coWakeup(nSelfCo, self._startSid)
	if not self._buildFinish then
		const nCurCo = coroutine.running()
		const nSessionId = self._manager:genSessionId()
		self._waitCoToSid[nCurCo] = nSessionId
		self._manager:coWait(nCurCo, nSessionId, nSelfCo)
	end
end

function ClassFnCom:checkDefine()
	self._manager:coWakeup(self._newRefer:getSelfCo(), self._startSid)
end

function ClassFnCom:meta_call(vContext, vTypeTuple)
	--self:checkDefine()
	return self._typeFunction:meta_call(vContext, vTypeTuple)
end

function ClassFnCom:regionTableSelf(vContext, vNode)
	assert(not self._onceHintNew, "New() can only be called once")
	self._onceHintNew = true
	return self._classTableCom
end

function ClassFnCom:regionReturn(vContext, vNode, vTypeTuple)
	if vTypeTuple:getRepeatType() or #vTypeTuple~=1 then
		vContext:getRuntime():nodeError(vNode, "return tuple not match")
	else
		local aType = vTypeTuple:get(1):checkAtomUnion()
		local bType = self._classTableCom:getLuaTable()
		if aType ~= bType then
			vContext:getRuntime():nodeError(vNode, "return type not match")
		end
	end
end

function ClassFnCom:regionEnd(vContext, vNode, vTermTupleList:List(class.TermTuple))
	if #vTermTupleList <= 0 then
		vContext:getRuntime():nodeError(vNode, "return statement not found")
	end
end

function ClassFnCom.is(v)::isguard(class.ClassFnCom)
	return getmetatable(v) == ClassFnCom
end

return ClassFnCom
