
local TermCase = require "thlua.term.TermCase"
local LuaFunction = require "thlua.func.LuaFunction"
local FnComClass = require "thlua.func.FnComClass"

local FixedRetFnCom = FnComClass()

(@var.class = import("thlua.type.TypeClass").class)

function FixedRetFnCom.new(vManager:class.TypeManager, vLuaFunction:class.LuaFunction)::RetNew(class.FixedRetFnCom)
	local self = setmetatable({::New()
		tag=LuaFunction.FIXED_RET,
		_manager=vManager,
		_luaFunction=vLuaFunction,
		_typeFunction=false,
		_once=false,
		_autoArgs=false,
		_retTuples=false,
		_nocheck=false,
	}, FixedRetFnCom)
	vLuaFunction:setFnCom(self)
	return self
end

function FixedRetFnCom:init(vContext, vRetTuples, vNocheck)
	self._autoArgs = self._luaFunction._autoArgs
	self._retTuples = vRetTuples
	self._nocheck = vNocheck
	if not self._autoArgs:hasVariable() then
		local nArgTuple = self._autoArgs:checkWhenLate(self._luaFunction._context)
		self._typeFunction = self._manager:Function(nArgTuple, self._retTuples)
	end
end

function FixedRetFnCom:checkLateRun()
	if self._nocheck then
		return
	end
	if self._once then
		return
	end
	local nTypeFn = self._typeFunction
	if not nTypeFn then
		return
	end
	local nArgTuple = nTypeFn:getArgTuple()
	if nArgTuple then
		self._once = true
		self._luaFunction._runFunc(self._luaFunction:newInplaceContext(), nArgTuple:makeTermTuple())
	end
end

function FixedRetFnCom:meta_call(vContext, vTypeTuple)
	local nTypeFn = self._typeFunction
	if not nTypeFn then
		local nArgTuple = self._autoArgs:checkWhenApply(vContext, vTypeTuple)
		nTypeFn = self._manager:Function(nArgTuple, self._retTuples)
		self._typeFunction = nTypeFn
	end
	local ret = nTypeFn:meta_call(vContext, vTypeTuple)
	self:checkLateRun()
	return ret
end

function FixedRetFnCom:regionReturn(vContext, vNode, vTypeTuple)
	if vTypeTuple:getRepeatType() then
		vContext:nodeError(vNode, "return dots type is invalid")
	end
	local nOneOkay = false
	self._retTuples:foreach(function(vDstTuple)
		if vTypeTuple:castOrIn(vContext, vDstTuple) then
			nOneOkay = true
		end
	end)
	if not nOneOkay then
		vContext:nodeError(vNode, "return check failed")
	end
end

function FixedRetFnCom:regionEnd(vContext, vNode, vTermTupleList)
	-- do nothing
end

function FixedRetFnCom:cast(vContext, vDstTypeFn)::Ret(Boolean)
	if not self._typeFunction then
		self:meta_call(vContext, vDstTypeFn:getArgTuple())
	end
	return vDstTypeFn:contain(self._typeFunction) and true
end

return FixedRetFnCom
