
const VariableCase = require "thlua.term.VariableCase"

const MemberFunction = require "thlua.func.MemberFunction"
const TypeFunction = require "thlua.func.TypeFunction"

const LateFnCom = {}
LateFnCom.__index=LateFnCom

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.LateFnCom) LateFnCom.new(vManager:clazz.TypeManager,
	vLuaFunction:clazz.LuaFunction,
	vPass:Boolean
)
	local self = setmetatable({.class
		_manager=vManager,
		_luaFunction=vLuaFunction,
		_castSpecFnToCheckFn={}@Dict(clazz.TypeFunction, Fn()),
		_once=false@Boolean,
		_pass=vPass,
	}, LateFnCom)
	return self
end

function LateFnCom:checkLateRun()
	if self._pass then
		return
	end
	if self._once then
		print("error, checkLateRun called more than once")
		return
	end
	self._once = true
	const nSpecFnDict:Dict(clazz.TypeFunction, Fn()) = {}
	-- 1. cast fn
	const nCastFn = next(self._castSpecFnToCheckFn)
	if nCastFn then
		nSpecFnDict[nCastFn] = self._castSpecFnToCheckFn[nCastFn]
		const nDict = self._castSpecFnToCheckFn
		for nTypeFn, nCheckFn in pairs(nDict) do
			if not nCastFn:containAll(nTypeFn) then
				nSpecFnDict[nTypeFn] = nCheckFn
				print("polymorphism cast TODO")
			end
		end
	end
	for nTypeFn, nCheckFn in pairs(nSpecFnDict) do
		const nParTuple = nTypeFn:getParTuple()
		nCheckFn()
	end
end

function LateFnCom:addSpecFn(vTypeFn:clazz.TypeFunction, vCheckFn:Fn())
	self._castSpecFnToCheckFn[vTypeFn] = vCheckFn
end

function.open LateFnCom.is(v):isguard(clazz.LateFnCom)
	return getmetatable(v) == LateFnCom
end

return LateFnCom
