
const TermCase = require "thlua.term.TermCase"

const MemberFunction = require "thlua.func.MemberFunction"
const TypeFunction = require "thlua.func.TypeFunction"

const LateFnCom = {}
LateFnCom.__index=LateFnCom

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.LateFnCom) LateFnCom.new(vManager:clazz.TypeManager,
	vLuaFunction:clazz.LuaFunction,
	vDefaultFn:OrFalse(clazz.UDefaultFunction),
	vPass:Boolean
)
	local self = setmetatable({.class
		_manager=vManager,
		_luaFunction=vLuaFunction,
		_defaultFn=vDefaultFn,
		_selfSpecDict={}@Dict(clazz.LuaTable, clazz.TypeFunction),
		_castSpecList={}@List(clazz.TypeFunction),
		_once=false@Boolean,
		_pass=vPass,
	}, LateFnCom)
	return self
end

function LateFnCom:checkLateRun()
	if self._pass then
		return
	end
	if self._once then
		print("error, checkLateRun called more than once")
		return
	end
	self._once = true
	const nSpecFnList:List(Struct {clazz.TypeFunction, OrNil(List(clazz.UAllType)), OrNil(clazz.UAllType)}) = {}
	-- 1. cast fn
	const nCastFn = self._castSpecList[1]
	if nCastFn then
		nSpecFnList[#nSpecFnList + 1] = {nCastFn}
		const nList = self._castSpecList
		for i=2,#nList do
			const nTypeFn = nList[i]!
			if not nCastFn:containAll(nTypeFn) then
				nSpecFnList[#nSpecFnList + 1] = {nTypeFn}
				print("polymorphism cast TODO")
			end
		end
	end
	-- 2. default fn
	const nDefaultFn = self._defaultFn
	if MemberFunction.is(nDefaultFn) then
		const nPairDict = nDefaultFn:getPolyFn():getPolyCallPairDict()
		for _, nPair in pairs(nPairDict) do
			const nRawPolyArgs = nPair[2]
			const nPolyArgs:List(clazz.UAllType) = {table.unpack(nRawPolyArgs, 2)}
			const nSelfType = assert(nRawPolyArgs[1], "self type must existed here")
			nSpecFnList[#nSpecFnList + 1] = {nPair[1], nPolyArgs, nSelfType}
		end
	elseif TypeFunction.is(nDefaultFn) then
		nSpecFnList[#nSpecFnList + 1] = {nDefaultFn}
	elseif nDefaultFn then
		print("poly function lateRun TODO", tostring(self._luaFunction:getNode()))
	else
		if #self._castSpecList <= 0 then
			-- print("function no cast and no default", tostring(self._luaFunction:getNode()))
		end
		-- nDefaultFn is false
	end
	for _, nPair in ipairs(nSpecFnList) do
		const nParTuple = nPair[1]:getParTuple()
		const nInplaceContext = self._luaFunction:newInplaceSealContext()
		const ok, err = pcall(function()
			const nEmpty:List(clazz.UAllType) = {}
			self._luaFunction:getGenFunc()(nPair[1], nInplaceContext, nParTuple:makeTermTuple(), nPair[2] or nEmpty, nPair[3] or false)
		end)
		if not ok then
			nInplaceContext:error(tostring(err))
		end
	end
end

function LateFnCom:getDefaultFn():Ret(OrFalse(clazz.UDefaultFunction))
	return self._defaultFn
end

function LateFnCom:addSpecFn(vTypeFn:clazz.TypeFunction, vSelfType:OrNil(clazz.LuaTable))
	if vSelfType then
		self._selfSpecDict[vSelfType] = vTypeFn
	else
		const nList = self._castSpecList
		nList[#nList + 1] = vTypeFn
	end
end

function.open LateFnCom.is(v):isguard(clazz.LateFnCom)
	return getmetatable(v) == LateFnCom
end

return LateFnCom
