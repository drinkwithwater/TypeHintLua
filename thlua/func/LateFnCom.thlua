
const VariableCase = require "thlua.term.VariableCase"

const MemberFunction = require "thlua.func.MemberFunction"
const TypeFunction = require "thlua.func.TypeFunction"

const LateFnCom = {}
LateFnCom.__index=LateFnCom

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.LateFnCom) LateFnCom.new(vManager:clazz.TypeManager,
	vLuaFunction:clazz.LuaFunction,
	vPass:Boolean
)
	local self = setmetatable({.class
		_manager=vManager,
		_luaFunction=vLuaFunction,
		_castSpecFnToGenFunc={}@Dict(clazz.TypeFunction, clazz.GenFunc),
		_once=false@Boolean,
		_pass=vPass,
	}, LateFnCom)
	return self
end

function LateFnCom:checkLateRun()
	if self._pass then
		return
	end
	if self._once then
		print("error, checkLateRun called more than once")
		return
	end
	self._once = true
	const nSpecFnDict:Dict(clazz.TypeFunction, clazz.GenFunc) = {}
	-- 1. cast fn
	const nCastFn = next(self._castSpecFnToGenFunc)
	if nCastFn then
		nSpecFnDict[nCastFn] = self._castSpecFnToGenFunc[nCastFn]
		const nDict = self._castSpecFnToGenFunc
		for nTypeFn, nGenFunc in pairs(nDict) do
			if not nCastFn:containAll(nTypeFn) then
				nSpecFnDict[nTypeFn] = nGenFunc
				print("polymorphism cast TODO")
			end
		end
	end
	for nTypeFn, nGenFunc in pairs(nSpecFnDict) do
		const nParTuple = nTypeFn:getParTuple()
		const nInplaceContext = self._luaFunction:newInplaceSealContext()
		const ok, err = pcall(function()
			nGenFunc(nTypeFn, nInplaceContext, nParTuple:makeTermTuple(nInplaceContext), false, {}, false)
		end)
		if not ok then
			nInplaceContext:error(tostring(err))
		end
	end
end

function LateFnCom:addSpecFn(vTypeFn:clazz.TypeFunction, vGenFunc:clazz.GenFunc)
	self._castSpecFnToGenFunc[vTypeFn] = vGenFunc
end

function.open LateFnCom.is(v):isguard(clazz.LateFnCom)
	return getmetatable(v) == LateFnCom
end

return LateFnCom
