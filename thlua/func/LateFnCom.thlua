
const TermCase = require "thlua.term.TermCase"
const FnComClass = require "thlua.func.FnComClass"

const LateFnCom = FnComClass()

(@let.class = import("thlua.type.TypeClass").class)

function.class LateFnCom.new(vManager:class.TypeManager, vLuaFunction:class.LuaFunction):RetClass(class.LateFnCom, class.IFnCom)
	local self = setmetatable({.class
		_manager=vManager,
		_luaFunction=vLuaFunction,
		_typeFunction=false@Union(False, class.TypeFunction),
		_selfSpecDict={}@Dict(class.LuaTable, class.TypeFunction),
		_castSpecList={}@List(class.TypeFunction),
		_once=false@Boolean,
		_pass=false@Boolean,
	}, LateFnCom)
	vLuaFunction:setFnCom(self)
	return self
end

function LateFnCom:init(vNocheck:Boolean)
	self._pass = vNocheck
end

function LateFnCom:checkLateRun()
	if self._pass then
		return
	end
	if self._once then
		print("error, checkLateRun called more than once")
		return
	end
	self._once = true
	const nSpecFnList:List(class.TypeFunction) = {}
	for _, nTypeFn in pairs(self._selfSpecDict) do
		nSpecFnList[#nSpecFnList + 1] = nTypeFn
	end
	const nCastFn = self._castSpecList[1]
	if nCastFn then
		nSpecFnList[#nSpecFnList + 1] = nCastFn
		const nList = self._castSpecList
		for i=2,#nList do
			const nTypeFn = nList[i]!
			if not nCastFn:containAll(nTypeFn) then
				nSpecFnList[#nSpecFnList + 1] = nTypeFn
				print("polymorphism cast TODO")
			end
		end
	end
	const nDefaultFn = self._typeFunction
	if #nSpecFnList == 0 and nDefaultFn then
		nSpecFnList[#nSpecFnList + 1] = nDefaultFn
	end
	for _, nTypeFn in ipairs(nSpecFnList) do
		const nParTuple = nTypeFn:getParTuple()
		const nInplaceContext = self._luaFunction:newInplaceSealContext()
		nInplaceContext:setTypeFn(nTypeFn)
		const ok, err = pcall(function():Ret()
			self._luaFunction:getGenFunc()(nInplaceContext, {}, nParTuple:makeTermTuple())
		end)
		if not ok then
			nInplaceContext:error(tostring(err))
		end
	end
	if nCastFn and self._typeFunction then
		self._manager:getRuntime():nodeError(self._luaFunction:getNode(), "both castFn and typeFunc ???")
	end
end

function LateFnCom:matchTypeFn(vContext, vTypeTuple)
	return self:typeDefault()
end

function LateFnCom:regionReturn(vContext, vNode, vRetTypeTuple)
	if vRetTypeTuple:getRepeatType() then
		vContext:getRuntime():nodeError(vNode, "return dots type is invalid")
	end
	local nOneOkay = false
	local nRetTuples = assert(vContext:getTypeFn(), "LateFnCom's context must set TypeFn"):getRetTuples()
	assert(nRetTuples, "ret tuples not setted when return")
	nRetTuples:foreachWithFirst(function(vDstTuple, _)
		if vRetTypeTuple:castOrIn(vContext, vDstTuple) then
			nOneOkay = true
		end
	end)
	if not nOneOkay then
		vContext:getRuntime():nodeError(vNode, "return check failed")
	end
end

function LateFnCom:regionEnd(vContext, vNode, vTermTupleList)
	-- do nothing
end

function LateFnCom:typeDefault():Ret(class.TypeFunction)
	local nTypeFn = self._typeFunction
	if not nTypeFn then
		nTypeFn = self._luaFunction:getHintCom():checkWhenDefault()
		self._typeFunction = nTypeFn
	end
	return nTypeFn
end

function LateFnCom:addSpecFn(vTypeFn:class.TypeFunction, vSelfType:OrNil(class.LuaTable))
	if vSelfType then
		self._selfSpecDict[vSelfType] = vTypeFn
	else
		const nList = self._castSpecList
		nList[#nList + 1] = vTypeFn
	end
end

function.open LateFnCom.is(v):RetIs(class.LateFnCom)
	return getmetatable(v) == LateFnCom
end

return LateFnCom
