
const TermCase = require "thlua.term.TermCase"
const FnComClass = require "thlua.func.FnComClass"

const LateFnCom = FnComClass()

(@let.class = import("thlua.type.TypeClass").class)

function LateFnCom.new(vManager:class.TypeManager, vLuaFunction:class.LuaFunction)::RetClass(class.LateFnCom, class.IFnCom)
	local self = setmetatable({::Self()
		_manager=vManager,
		_luaFunction=vLuaFunction,
		_typeFunction=false@Union(False, class.TypeFunction),
		_selfSpecDict={}@Dict(class.LuaTable, class.TypeFunction),
		_castSpecFn=false@Union(False, class.TypeFunction),
		_once=false@Boolean,
		_autoArgs=nil@class.AutoArguments,
		_retTuples=false@Union(False, class.RetTuples),
		_nocheck=false@Boolean,
	}, LateFnCom)
	vLuaFunction:setFnCom(self)
	return self
end

function LateFnCom:init(vRetTuples:Union(False, class.RetTuples), vNocheck:Boolean)
	self._autoArgs = self._luaFunction._autoArgs
	self._retTuples = vRetTuples or false
	self._nocheck = vNocheck
end

function LateFnCom:checkLateRun()
	if self._nocheck then
		return
	end
	if self._once then
		print("error, checkLateRun called more than once")
		return
	end
	self._once = true
	const nSpecFnList:List(class.TypeFunction) = {}
	for _, nTypeFn in pairs(self._selfSpecDict) do
		nSpecFnList[#nSpecFnList + 1] = nTypeFn
	end
	nSpecFnList[#nSpecFnList + 1] = self._castSpecFn or nil
	for _, nTypeFn in ipairs(nSpecFnList) do
		const nArgTuple = nTypeFn:getArgTuple()
		const nInplaceContext = self._luaFunction:newInplaceSealContext()
		nInplaceContext:setTypeFn(nTypeFn)
		const ok, err = pcall(function()
			self._luaFunction._runFunc(nInplaceContext, nArgTuple:makeTermTuple())
		end)
		if not ok then
			nInplaceContext:error(tostring(err))
		end
	end
	if self._castSpecFn and self._typeFunction then
		self._manager:getRuntime():nodeError(self._luaFunction:getNode(), "both castFn and typeFunc ???", tostring(self._castSpecFn), tostring(self._typeFunction))
	end
end

function LateFnCom:meta_call(vContext, vTypeTuple)
	if not self._typeFunction then
		self:_typeDefault()
	end
	local nTypeFn = self._typeFunction
	assert(nTypeFn, "type-fn not setted in late-fn when meta_call")
	return nTypeFn:meta_call(vContext, vTypeTuple)
end

function LateFnCom:regionReturn(vContext, vNode, vRetTypeTuple)
	if vRetTypeTuple:getRepeatType() then
		vContext:getRuntime():nodeError(vNode, "return dots type is invalid")
	end
	local nOneOkay = false
	local nRetTuples = assert(vContext:getTypeFn(), "LateFnCom's context must set TypeFn"):getRetTuples()
	assert(nRetTuples, "ret tuples not setted when return")
	nRetTuples:foreach(function(vDstTuple)
		if vRetTypeTuple:castOrIn(vContext, vDstTuple) then
			nOneOkay = true
		end
	end)
	if not nOneOkay then
		vContext:getRuntime():nodeError(vNode, "return check failed")
	end
end

function LateFnCom:regionEnd(vContext, vNode, vTermTupleList)
	-- do nothing
end

function LateFnCom:_typeDefault()
	if not self._typeFunction then
		const nArgTuple = self._autoArgs:checkByDefault()
		const nRetTuples = self._retTuples or self._manager:VoidRetTuples()
		self._retTuples = nRetTuples
		self._typeFunction = self._manager:Function(nArgTuple, nRetTuples)
	end
end

function LateFnCom:_typeFnSpecialize(vContext:class.Context, vTypeFn:class.TypeFunction)::Ret(class.TypeFunction)
	const nArgTuple = vTypeFn:getArgTuple()
	self._autoArgs:checkWhenApply(vContext, vTypeFn:getArgTuple())
	local nRetTuples = vTypeFn:getRetTuples()
	const nHintRetTuples = self._retTuples
	if nHintRetTuples then
		if nRetTuples:containTuples(nHintRetTuples) then
			nRetTuples = nHintRetTuples
		else
			if not self._nocheck then
				vContext:getRuntime():nodeError(self._luaFunction:getNode(), "interface-fn ret and hint ret notmatch")
			end
		end
	end
	const nArgTuple = vTypeFn:getArgTuple()
	return self._manager:Function(nArgTuple, nRetTuples)
end

function LateFnCom:specialize(vContext:class.Context, vSelfType:class.LuaTable, vTypeFnOrNil:OrNil(class.TypeFunction))::Ret(class.TypeFunction)
	if vTypeFnOrNil then
		const nNewTypeFn = self:_typeFnSpecialize(vContext, vTypeFnOrNil)
		self._selfSpecDict[vSelfType] = nNewTypeFn
		return nNewTypeFn
	else
		const nArgTuple = self._autoArgs:checkByFirst(vContext, vSelfType)
		local nRetTuples = self._retTuples
		if not nRetTuples then
			if not self._nocheck then
				vContext:getRuntime():nodeError(self._luaFunction:getNode(), "return something but no hint TODO")
			end
			nRetTuples = self._manager:VoidRetTuples()
		end
		const nNewTypeFn = self._manager:Function(nArgTuple, nRetTuples)
		self._selfSpecDict[vSelfType] = nNewTypeFn
		return nNewTypeFn
	end
end

function LateFnCom:cast(vContext:class.Context, vDstTypeFn:class.TypeFunction)::Ret(Boolean)
	local nTypeFn = self._castSpecFn
	if not nTypeFn then
		-- nTypeFn = self:_typeFnSpecialize(vContext, vDstTypeFn)
		local nArgTuple = self._autoArgs:checkWhenApply(vContext, vDstTypeFn:getArgTuple())
		self._retTuples = self._retTuples or vDstTypeFn:getRetTuples()
		nTypeFn = self._manager:Function(nArgTuple, self._retTuples or vDstTypeFn:getRetTuples())
		self._castSpecFn = nTypeFn
	end
	return vDstTypeFn:containAll(nTypeFn) and true
end

function LateFnCom.is(v)::isguard(class.LateFnCom)
	return getmetatable(v) == LateFnCom
end

return LateFnCom
