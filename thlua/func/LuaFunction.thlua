
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local AtomTypeClass = require "thlua.type.AtomTypeClass"
local Exception = require "thlua.Exception"

local LuaFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

LuaFunction.OPEN="open"

LuaFunction.AUTO_RET="auto"

LuaFunction.NEW_RET="new"

LuaFunction.FIXED_RET="fixed"


function LuaFunction.new(vManager:class.TypeManager)::RetClass(class.LuaFunction, class.IAtomType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_context=false@class.Context,
		_node=false@class.AstNode,
		_unionFnCom=false@class.IFnCom,
		_runFunc=false@class.GenFunc,
		_autoArgs=false@class.AutoArguments,
		bits=TYPE_BITS.FUNCTION,
		name="unknown"@String,
		id=vManager:genTypeId(),
	}, LuaFunction)
	return self
end

function LuaFunction:setFnCom(vUnionTagFn:class.IFnCom)
	self._unionFnCom = vUnionTagFn
end

function LuaFunction:init(vContext:class.Context, vNode:class.AstNode, vAutoArgs:class.AutoArguments, vRunFunc:class.GenFunc)
	self._context = vContext
	self._node = vNode
	self._runFunc = vRunFunc
	self._autoArgs = vAutoArgs
	self.name = tostring(vNode)
end

function LuaFunction:newInplaceContext()
	return self._context:newSealContext(self._node)
end

function LuaFunction:isNative()
	local nTag = self._unionFnCom.tag
	return nTag == LuaFunction.OPEN
end

function LuaFunction:detailString(v)
	return "LuaFunction-"..self._unionFnCom.tag.."-"..self.name
end

function LuaFunction:getFnCom()
	return self._unionFnCom
end

function LuaFunction:meta_native_call(vContext, vTermTuple)
	local nTagFn = self._unionFnCom
	if nTagFn.tag == LuaFunction.OPEN then
		return nTagFn:meta_native_call(vContext, vTermTuple)
	else
		error("only native fn can call meta_native_call")
	end
end

function LuaFunction:meta_call(vContext, vTypeTuple)
	return self._unionFnCom:meta_call(vContext, vTypeTuple)
end

function LuaFunction:_intersectOneNotRefer(vType)
	if vType == self then
		return self
	elseif vType:_containOneNotRefer(self) then
		return self
	else
		return false
	end
end

function LuaFunction:_containOneNotRefer(vType)
	if vType == self then
		return self
	else
		return false
	end
end

function LuaFunction:isSingleton()
	return false
end

function LuaFunction:native_type()
	return self._manager:Literal("function")
end

function LuaFunction:cast(vContext, vTypeFn)::Ret(Boolean)
	return self._unionFnCom:cast(vContext, vTypeFn)
end

function LuaFunction:implement(vContext, vSelfType, vIntfFnOrNil)
	local nUnionCom = self._unionFnCom
	if nUnionCom.tag == LuaFunction.FIXED_RET then
		return self._unionFnCom:implement(vContext, vSelfType, vIntfFnOrNil)
	else
		vContext:error("invalid as member")
		return false
	end
end

function LuaFunction:isMember()
	return self._autoArgs:hasSelf() and self._unionFnCom.tag == LuaFunction.FIXED_RET
end

function LuaFunction:getNode()::Ret(class.AstNode)
	return self._node
end

function LuaFunction.is(vType)::isguard(class.LuaFunction)
	return getmetatable(vType) == LuaFunction
end

return LuaFunction
