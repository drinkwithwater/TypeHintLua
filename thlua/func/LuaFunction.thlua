
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const Exception = require "thlua.Exception"
const Enum = require "thlua.Enum"

const OpenFnCom = require "thlua.func.OpenFnCom"
const LateFnCom = require "thlua.func.LateFnCom"
const ClassFactory = require "thlua.func.ClassFactory"

const MemberFunction = require "thlua.func.MemberFunction"
const TypeFunction = require "thlua.func.TypeFunction"
const PolyFunction = require "thlua.func.PolyFunction"

const LuaFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function.class LuaFunction.new(vManager:class.TypeManager):RetClass(class.LuaFunction, class.IAtomType)
	local self = setmetatable({.class
		_manager=vManager,
		_context=false@class.Context,
		_node=false@class.IAstNode,
		_genFunc=false@class.GenFunc,
		_isMember=false@Boolean,
		_unionFnCom=nil@class.UFnCom,
		_hintCom=nil@class.FunctionBuilder,
		bits=TYPE_BITS.FUNCTION,
		name="unknown"@String,
		id=vManager:genTypeId(),
	}, LuaFunction)
	return self
end

function LuaFunction:setMember()
	self._isMember = true
end

function LuaFunction:getBuilder():Ret(class.FunctionBuilder)
	return self._hintCom
end

function LuaFunction:lateInit(vContext:class.Context, vNode:class.IAstNode, vHintCom:class.FunctionBuilder, vFnCom:class.UFnCom)
	self._context = vContext
	self._node = vNode
	self._genFunc = vHintCom:getGenFunc()
	self._hintCom = vHintCom
	self._unionFnCom = vFnCom
	self.name = tostring(vNode)
end

function LuaFunction:newInplaceSealContext():Ret(class.Context)
	return self._context:newSealContext(self._node)
end

function LuaFunction:newInplaceOpenContext():Ret(class.Context)
	return self._context:newOpenContext(self._node)
end

function LuaFunction:isNative():Ret(Boolean)
	return OpenFnCom.is(self._unionFnCom)
end

function LuaFunction:detailString(v, vVerbose)
	return "LuaFunction-"..self.name
end

function LuaFunction:getFnCom():Ret(class.UFnCom)
	return self._unionFnCom
end

function LuaFunction:meta_open_call(vContext:class.Context, vTermTuple:class.TermTuple):Ret(class.TermTuple)
	local nFnCom = self._unionFnCom
	if OpenFnCom.is(nFnCom) then
		return nFnCom:meta_open_call(vContext, vTermTuple)
	else
		error("only open or native fn can call meta_open_call")
	end
end

function LuaFunction:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	local nLateCom = self._unionFnCom
	if LateFnCom.is(nLateCom) then
		const nDefaultFn = nLateCom:getDefaultFn()
		if MemberFunction.is(nDefaultFn) then
			return nDefaultFn:indexTypeFn(vSelfType):meta_call(vContext, vTypeTuple)
		elseif nDefaultFn then
			return nDefaultFn:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
		else
			error("default type is empty, TODO")
		end
	else
		print("TODO, not-late fn com meta_invoke")
		return self:meta_call(vContext, vTypeTuple)
	end
end

function LuaFunction:meta_call(vContext, vTypeTuple)
	if not self._hintCom:isFullHint() then
		vContext:error("TODO can only call full-hint function", tostring(self))
	end
	local nFnCom = self._unionFnCom
	if not OpenFnCom.is(nFnCom) then
		const nTypeFn = nFnCom:matchTypeFn(vContext, vTypeTuple)
		return nTypeFn:meta_call(vContext, vTypeTuple)
	else
		error("open fn can't call meta_call")
	end
end

function LuaFunction:assumeIntersectAtom(vAssumeSet, vType)
	if vType == self then
		return self
	elseif vType:assumeContainAtom(nil, self) then
		return self
	else
		return false
	end
end

function LuaFunction:assumeContainAtom(vAssumeSet, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function LuaFunction:isSingleton()
	return false
end

function LuaFunction:native_type()
	return self._manager:Literal("function")
end

function LuaFunction:castPoly(vContext, vTypeArgsList)
	const nLateCom = self._unionFnCom
	assert(LateFnCom.is(nLateCom), "only LateFnCom can cast generic")
	return self._hintCom:checkWhenGeneric(vContext, vTypeArgsList)
end

function LuaFunction:cast(vContext:class.Context, vTypeFn:class.TypeFunction):Ret(OrFalse(class.TypeFunction))
	local nUnionFnCom = self._unionFnCom
	if LateFnCom.is(nUnionFnCom) then
		const nAfterTypeFn = self._hintCom:checkWhenCast(vContext, vTypeFn)
		nUnionFnCom:addSpecFn(nAfterTypeFn)
		return nAfterTypeFn
	else
		return false
	end
end

function LuaFunction:castSpecialize(vContext:class.Context, vTypeFn:class.TypeFunction):Ret(class.TypeFunction)
	const nLateCom = self._unionFnCom
	assert(LateFnCom.is(nLateCom), "only LateFnCom can specificate")
	const nAfterTypeFn = self._hintCom:checkWhenCast(vContext, vTypeFn)
	nLateCom:addSpecFn(nAfterTypeFn)
	return nAfterTypeFn
end

function LuaFunction:autoSpecialize(vContext:class.Context, vSelfType:OrNil(class.LuaTable)):Ret(class.TypeFunction)
	local nLateCom = self._unionFnCom
	assert(LateFnCom.is(nLateCom), "only LateFnCom can specificate")
	const nDefaultFn = nLateCom:getDefaultFn()
	if not vSelfType then
		assert(TypeFunction.is(nDefaultFn), "only type function can be auto specialize")
		return nDefaultFn
	else
		assert(MemberFunction.is(nDefaultFn), "only member function can be auto specialize with self")
		return nDefaultFn:indexTypeFn(vSelfType)
	end
end

function LuaFunction:isMember():Ret(Boolean)
	return self._isMember and LateFnCom.is(self._unionFnCom)
end

function LuaFunction:fnPartType()
	return self
end

function LuaFunction:mayRecursive()
	return true
end

function LuaFunction:getNode():Ret(class.IAstNode)
	return self._node
end

function LuaFunction:getGenFunc():Ret(class.GenFunc)
	return self._genFunc
end

function.open LuaFunction.is(vType):RetIs(class.LuaFunction)
	return getmetatable(vType) == LuaFunction
end

return LuaFunction
