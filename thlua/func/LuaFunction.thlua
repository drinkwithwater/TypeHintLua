
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const Exception = require "thlua.Exception"
const Enum = require "thlua.Enum"

const AutoFunction = require "thlua.refer.AutoFunction"
const ClassFactory = require "thlua.refer.ClassFactory"
const OpenFunction = require "thlua.func.OpenFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const TypeFunction = require "thlua.func.TypeFunction"
const PolyFunction = require "thlua.func.PolyFunction"

const LuaFunction = AtomTypeClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.LuaFunction) LuaFunction.new(vManager:clazz.TypeManager):impl(clazz.IAtomType)
	local self = setmetatable({.class
		_manager=vManager,
		_node=false@clazz.IAstNode,
		_isMember=false@Boolean,
		_innerFn=false@OrFalse(clazz.ULuaInnerFn),
		_hintCom=nil@clazz.FunctionBuilder,
		bits=TYPE_BITS.FUNCTION,
		name="unknown"@String,
		id=vManager:genTypeId(),
	}, LuaFunction)
	return self
end

function LuaFunction:setMember()
	self._isMember = true
end

function LuaFunction:lateInit(vNode:clazz.IAstNode, vHintCom:clazz.FunctionBuilder, vInnerFn:OrFalse(clazz.ULuaInnerFn))
	self._node = vNode
	self._hintCom = vHintCom
	self._innerFn = vInnerFn
	if not vInnerFn then
		print(vNode)
	end
	self.name = tostring(vNode)
end

function LuaFunction:isOpen():Ret(Boolean)
	return OpenFunction.is(self._innerFn)
end

function LuaFunction:detailString(v, vVerbose)
	return "LuaFunction-"..self.name
end

function LuaFunction:triggerAsMetaIndex(vContext, vSelfTerm, vKeyTerm)
	const nInnerFn = self._innerFn
	if OpenFunction.is(nInnerFn) then
		return nInnerFn:triggerAsMetaIndex(vContext, vSelfTerm, vKeyTerm)
	elseif AutoFunction.is(nInnerFn) then
		const nTermTuple = vContext:FixedTermTuple({vSelfTerm, vKeyTerm})
		return vContext:RefineTerm(nInnerFn:meta_call(vContext, nTermTuple):getFirstType())
	else
		error("this function can't called as __index")
	end
end

function LuaFunction:triggerAsMetaNewIndex(vContext, vSelfTerm, vKeyTerm, vValueTerm)
	const nInnerFn = self._innerFn
	if OpenFunction.is(nInnerFn) then
		nInnerFn:triggerAsMetaNewIndex(vContext, vSelfTerm, vKeyTerm, vValueTerm)
	elseif AutoFunction.is(nInnerFn) then
		const nTermTuple = vContext:FixedTermTuple({vSelfTerm, vKeyTerm, vValueTerm})
		nInnerFn:meta_call(vContext, nTermTuple)
	else
		error("this function can't called as __index")
	end
end

function LuaFunction:meta_open_call(vContext:clazz.Context, vTermTuple:clazz.UTermTuple):Ret(clazz.UTermTuple)
	const nInnerFn = self._innerFn
	if OpenFunction.is(nInnerFn) then
		return nInnerFn:meta_open_call(vContext, vTermTuple)
	else
		error("only open or native fn can call meta_open_call"..tostring(nInnerFn))
	end
end

function LuaFunction:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	const nInnerFn = self._innerFn
	if MemberFunction.is(nInnerFn) then
		return nInnerFn:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	elseif PolyFunction.is(nInnerFn) then
		return nInnerFn:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	elseif AutoFunction.is(nInnerFn) or TypeFunction.is(nInnerFn) or ClassFactory.is(nInnerFn) then
		return self:meta_call(vContext, vTypeTuple)
	elseif OpenFunction.is(nInnerFn) then
		error("open function can't called with meta_invoke")
	else
		error("innerFn is empty, TODO")
	end
end

function LuaFunction:meta_call(vContext, vTypeTuple)
	const nInnerFn = self._innerFn
	if PolyFunction.is(nInnerFn) or TypeFunction.is(nInnerFn) or AutoFunction.is(nInnerFn) or ClassFactory.is(nInnerFn) then
		return nInnerFn:meta_call(vContext, vTypeTuple)
	else
		error("innerFn can't be called, TODO")
	end
end

function LuaFunction:assumeIntersectAtom(vAssumeSet, vType)
	if vType == self then
		return self
	elseif vType:assumeIncludeAtom(nil, self) then
		return self
	else
		return false
	end
end

function LuaFunction:assumeIncludeAtom(vAssumeSet, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function LuaFunction:isSingleton()
	return false
end

function LuaFunction:native_type()
	return self._manager:Literal("function")
end

function LuaFunction:castPoly(vContext, vTypeArgsList)
	const nInnerFn = self._innerFn
	if PolyFunction.is(nInnerFn) then
		return nInnerFn:castPoly(vContext, vTypeArgsList)
	else
		if TypeFunction.is(nInnerFn) then
			vContext:error("poly cast for non-poly function")
			return nInnerFn
		else
			error("TODO, poly cast error")
		end
	end
end


function LuaFunction:cast(vContext:clazz.Context, vTypeFn:clazz.TypeFunction):Ret(clazz.TypeFunction)
	const nInnerFn = self._innerFn
	if AutoFunction.is(nInnerFn) then
		nInnerFn:checkWhenCast(vContext, vTypeFn)
		return vTypeFn
	elseif MemberFunction.is(nInnerFn) then
		const nSelfType = vTypeFn:getParTuple():get(1)
		nInnerFn:indexAutoFn(nSelfType):checkWhenCast(vContext, vTypeFn)
		return vTypeFn
	else
		error("TODO: poly or open or class function take cast")
	end
end

function LuaFunction:autoSpecialize(vContext:clazz.Context, vSelfType:OrNil(clazz.LuaTable)):Ret(clazz.AutoFunction)
	const nInnerFn = self._innerFn
	if not vSelfType then
		assert(AutoFunction.is(nInnerFn), "only auto function can be specialized without self")
		return nInnerFn
	else
		assert(MemberFunction.is(nInnerFn), "only member function can be specialized with self")
		return nInnerFn:indexAutoFn(vSelfType)
	end
end

function LuaFunction:getInnerFn():Ret(OrFalse(clazz.ULuaInnerFn))
	return self._innerFn
end

function LuaFunction:isMember():Ret(Boolean)
	return self._isMember
end

function LuaFunction:fnPartType()
	return self
end

function LuaFunction:mayRecursive()
	return true
end

function.open LuaFunction.is(vType):isguard(clazz.LuaFunction)
	return getmetatable(vType) == LuaFunction
end

return LuaFunction
