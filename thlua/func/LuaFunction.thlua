
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local AtomTypeClass = require "thlua.type.AtomTypeClass"
local Exception = require "thlua.Exception"

local LuaFunction = AtomTypeClass()

(@var.class = import("thlua.type.TypeClass").class)

LuaFunction.OPEN="open"

LuaFunction.NOCHECK="nocheck"

LuaFunction.DEFINE="define"

LuaFunction.DEFAULT="default"

(@do

--[[
OpenFn = Struct {
	tag="open",
	fn=class.NativeFunction,
	isGuard=Boolean,
}

NocheckFn = Struct {
	tag="nocheck",
	fn=class.TypeFunction,
}

DefineFn = Struct {
	tag="define",
	fn=Union(false, class.TypeFunction),
	autoArgs=class.AutoArguments,
	runFunc=Truth,
	newTypeRefer=Union(class.Reference, False),
	newTypeImpl=Union(class.IValueType, False),
	once=Boolean,
}

DefaultFn = Struct {
	tag="default",
	fn=Union(false, class.TypeFunction),
	autoArgs=class.AutoArguments,
	retTuples=Union(false, class.RetTuples),
	runFunc=Truth,
	once=Boolean,
}
]]

end)

function LuaFunction.new(vManager:class.TypeManager)::RetNew(class.LuaFunction, class.IAtomType)
	local self = setmetatable({::New()
		_manager=vManager,
		_context=false,
		_node=false,
		_unionTagFn=false,
		_tupleSet={},
		pos="??",
		bits=TYPE_BITS.FUNCTION,
		name="unknown",
		id=vManager:genTypeId(),
		implType=false,
	}, LuaFunction)
	return self
end

function LuaFunction:setUnionFn(vUnionTagFn)
	self._unionTagFn = vUnionTagFn
end

function LuaFunction:init(vContext, vNode)
	self._context = vContext
	self._node = vNode
	self.name = tostring(vNode)
end

function LuaFunction:newInplaceContext()
	return self._context:newContext(self._node)
end

function LuaFunction:isNative()
	local nTag = self._unionTagFn.tag
	return nTag == LuaFunction.OPEN
end

function LuaFunction:detailString(v)
	return "LuaFunction-"..self._unionTagFn.tag.."-"..self.name
end

-- TODO
function LuaFunction:getPath()
	return self.name
end

function LuaFunction:checkDefine()
	local nTagFn = self._unionTagFn
	local nManager = self._manager
	if nTagFn.tag ~= LuaFunction.DEFINE then
		error("only def-fn can be refer's ctor")
		return
	end
	if nTagFn.once then
		return
	end
	nTagFn.once = true
	local nRefer = nTagFn.newTypeRefer
	local nContext = self:newInplaceContext()
	nRefer:setTypeAsync(function()
		return nContext._manager:LuaTable()
	end)
	local nTypeTuple = nTagFn.autoArgs:checkWhenLate(nContext)
	nContext:setNewTagFn(nTagFn)
	local nRetTermTuple = nTagFn.runFunc(nContext, nTypeTuple:makeTermTuple(), self)
	local nRightTypeTuple = nRetTermTuple:getTypeTuple()
	if #nRightTypeTuple ~= 1 then
		error("define-fn can't return more than one value")
	end
	local nReturnType = nRightTypeTuple:get(1):checkType()
	local nDefineType = nRefer:checkType()
	if nDefineType ~= nReturnType then
		error("define function must return table")
	end
	nDefineType:seal(nContext)
	local nRetTuples = nManager:EmptyRetTuples():Add(nManager:Tuple(nDefineType))
	nTagFn.fn = nManager:Function(nTypeTuple, nRetTuples)
end

-- called outside
function LuaFunction:checkLateRun()
	local nTagFn = self._unionTagFn
	local nTypeFn = nTagFn.fn
	if nTypeFn then
		local nTermTuple = nTypeFn:getArgTuple():makeTermTuple()
		local nRetTermTuple = nTagFn.runFunc(self:newInplaceContext(), nTermTuple, self)
		local nRetTypeTuple = nRetTermTuple:getTypeTuple()
		local nRetTuples = nTagFn.fn:getReturnTuples()
		if not nRetTuples:containTuple(nRetTypeTuple) then
			self._context:error("return not match", nRetTuples, nRetTypeTuple)
		end
	else
		local nArgsTypeTuple = nTagFn.autoArgs:checkWhenLate(self._context)
		local nTermTuple = nArgsTypeTuple:makeTermTuple()
		local nRetTermTuple = nTagFn.runFunc(self:newInplaceContext(), nTermTuple, self)
		local nRetTypeTuple = nRetTermTuple:getTypeTuple()
		local nRetTuples = nTagFn.retTuples
		if nRetTuples then
			if not nRetTuples:containTuple(nRetTypeTuple) then
				self._context:error("return not match", nRetTuples, nRetTypeTuple)
			end
		else
			nTagFn.retTuples = nRetTuples
			nTagFn.fn = self._manager:Function(nArgsTypeTuple, nRetTypeTuple)
		end
	end
end

function LuaFunction:_checkLateCall(vTypeTuple)
	local nContext = self:newInplaceContext()
	local nTagFn = self._unionTagFn
	if nTagFn.tag ~= LuaFunction.DEFAULT then
		nContext:error("unexcept branch")
		return
	end
	if nTagFn.once then
		return
	end
	nTagFn.once = true
	local nTypeTuple = nTagFn.autoArgs:checkWhenApply(nContext, vTypeTuple)
	local nRetTuples = nTagFn.retTuples
	if nRetTuples then
		nTagFn.fn = self._manager:Function(nTypeTuple, nRetTuples)
		nContext:getRuntime():recordLateLuaFunction(self)
		return
	end
	-- not late function
	local nRetTermTuple = nTagFn.runFunc(nContext, nTypeTuple:makeTermTuple(), self)
	local nRightTypeTuple = nRetTermTuple:getTypeTuple()
	nRetTuples = self._manager:EmptyRetTuples():Add(nRightTypeTuple)
	nTagFn.fn = self._manager:Function(nTypeTuple, nRetTuples)
end

function LuaFunction:implement(vContext, vFuncType)
	local nTagFn = self._unionTagFn
	local nTag = nTagFn.tag
	if nTag ~= LuaFunction.DEFAULT then
		error(nTag.." fn can't implement typefunction")
	end
	if self.implType then
		vContext:error("implement more than once")
		return
	end
	self.implType = vFuncType
	if not nTagFn.retTuples then
		nTagFn.retTuples = vFuncType:getReturnTuples()
	end
	self:_checkLateCall(vFuncType:getArgTuple())
end

function LuaFunction:meta_native_call(vContext, vTermTuple)
	local nTagFn = self._unionTagFn
	local nTag = nTagFn.tag
	if nTag == LuaFunction.OPEN then
		return nTagFn.fn:meta_native_call(vContext, vTermTuple)
	else
		error("only native fn can call meta_native_call")
	end
end

function LuaFunction:meta_call(vContext, vTypeTuple)
	local nTagFn = self._unionTagFn
	local nTag = nTagFn.tag
	if nTag == LuaFunction.OPEN then
		error("native fn can't call meta_native_call")
	elseif nTag == LuaFunction.NOCHECK then
		return nTagFn.fn:meta_call(vContext, vTypeTuple)
	else
		local nImplType = self.implType
		if nImplType then
			return nImplType:meta_call(vContext, vTypeTuple)
		end
		if nTag == LuaFunction.DEFAULT then
			self:_checkLateCall(vTypeTuple)
		elseif nTag == LuaFunction.DEFINE then
			self:checkDefine()
		else
			vContext:error("error occur for tag unexcept:"..tostring(nTag))
		end
		local nFn = nTagFn.fn
		if not nFn then
			vContext:error("error occur in function but rettuple not setted")
		else
			return nFn:meta_call(vContext, vTypeTuple)
		end
	end
end

function LuaFunction:_intersectOneNotRefer(vType)
	if vType == self then
		return self
	elseif vType:_containOneNotRefer(self) then
		return self
	else
		return false
	end
end

function LuaFunction:_containOneNotRefer(vType)
	if vType == self then
		return self
	else
		return false
	end
end

function LuaFunction:isSingleton()
	return false
end

function LuaFunction:native_type()
	return self._manager:Literal("function")
end

return LuaFunction
