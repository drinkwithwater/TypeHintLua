
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const Exception = require "thlua.Exception"
const Enum = require "thlua.Enum"

const LateFnCom = require "thlua.func.LateFnCom"
const ClassReferCom = require "thlua.refer.ClassReferCom"

const OpenFunction = require "thlua.func.OpenFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const TypeFunction = require "thlua.func.TypeFunction"
const PolyFunction = require "thlua.func.PolyFunction"

const LuaFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function:class(class.LuaFunction) LuaFunction.new(vManager:class.TypeManager):impl(class.IAtomType)
	local self = setmetatable({.class
		_manager=vManager,
		_context=false@class.Context,
		_node=false@class.IAstNode,
		_isMember=false@Boolean,
		_innerFn=false@OrFalse(class.OpenFunction, class.UDefaultFunction, class.ClassReferCom),
		_lateFnCom=false@OrFalse(class.LateFnCom),
		_hintCom=nil@class.FunctionBuilder,
		bits=TYPE_BITS.FUNCTION,
		name="unknown"@String,
		id=vManager:genTypeId(),
	}, LuaFunction)
	return self
end

function LuaFunction:setMember()
	self._isMember = true
end

function LuaFunction:getBuilder():Ret(class.FunctionBuilder)
	return self._hintCom
end

function LuaFunction:lateInit(vContext:class.Context, vNode:class.IAstNode, vHintCom:class.FunctionBuilder, vLateFnCom:OrFalse(class.LateFnCom), vInnerFn:OrFalse(class.OpenFunction, class.UDefaultFunction, class.ClassReferCom))
	self._context = vContext
	self._node = vNode
	self._hintCom = vHintCom
	self._lateFnCom = vLateFnCom
	self._innerFn = vInnerFn
	self.name = tostring(vNode)
end

function LuaFunction:newInplaceSealContext():Ret(class.Context)
	return self._context:newSealContext(self._node)
end

function LuaFunction:newInplaceOpenContext():Ret(class.Context)
	return self._context:newOpenContext(self._node)
end

function LuaFunction:isOpen():Ret(Boolean)
	return OpenFunction.is(self._innerFn)
end

function LuaFunction:detailString(v, vVerbose)
	return "LuaFunction-"..self.name
end

function LuaFunction:meta_open_call(vContext:class.Context, vTermTuple:class.TermTuple):Ret(class.TermTuple)
	const nInnerFn = self._innerFn
	if OpenFunction.is(nInnerFn) then
		return nInnerFn:meta_open_call(vContext, vTermTuple)
	else
		error("only open or native fn can call meta_open_call"..tostring(nInnerFn))
	end
end

function LuaFunction:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	local nInnerFn = self._innerFn
	if ClassReferCom.is(nInnerFn) then
		nInnerFn = assert(nInnerFn:getTypeFn(), "class refer com's typefn not setted")
	end
	if MemberFunction.is(nInnerFn) then
		return nInnerFn:indexTypeFn(vSelfType):meta_call(vContext, vTypeTuple)
	elseif PolyFunction.is(nInnerFn) or TypeFunction.is(nInnerFn) then
		return nInnerFn:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	elseif nInnerFn then
		print("TODO, not-late fn com meta_invoke")
		return self:meta_call(vContext, vTypeTuple)
	else
		error("innerFn is empty, TODO")
	end
end

function LuaFunction:meta_call(vContext, vTypeTuple)
	local nInnerFn = self._innerFn
	if ClassReferCom.is(nInnerFn) then
		nInnerFn = assert(nInnerFn:getTypeFn(), "class refer com's typefn not setted")
	end
	if PolyFunction.is(nInnerFn) or TypeFunction.is(nInnerFn) then
		return nInnerFn:meta_call(vContext, vTypeTuple)
	else
		error("innerFn can't be called, TODO")
	end
end

function LuaFunction:assumeIntersectAtom(vAssumeSet, vType)
	if vType == self then
		return self
	elseif vType:assumeContainAtom(nil, self) then
		return self
	else
		return false
	end
end

function LuaFunction:assumeContainAtom(vAssumeSet, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function LuaFunction:isSingleton()
	return false
end

function LuaFunction:native_type()
	return self._manager:Literal("function")
end

function LuaFunction:castPoly(vContext, vTypeArgsList)
	-- TODO
	print("cast poly TODO")
	return self._hintCom:checkWhenGeneric(vContext, vTypeArgsList)
end

function LuaFunction:cast(vContext:class.Context, vTypeFn:class.TypeFunction):Ret(OrFalse(class.TypeFunction))
	const nUnionFnCom = self._lateFnCom
	if LateFnCom.is(nUnionFnCom) then
		const nAfterTypeFn = self._hintCom:checkWhenCast(vContext, vTypeFn)
		nUnionFnCom:addSpecFn(nAfterTypeFn)
		return nAfterTypeFn
	else
		return false
	end
end

function LuaFunction:castSpecialize(vContext:class.Context, vTypeFn:class.TypeFunction):Ret(class.TypeFunction)
	const nLateCom = self._lateFnCom
	assert(LateFnCom.is(nLateCom), "only LateFnCom can specificate")
	const nAfterTypeFn = self._hintCom:checkWhenCast(vContext, vTypeFn)
	nLateCom:addSpecFn(nAfterTypeFn)
	return nAfterTypeFn
end

function LuaFunction:autoSpecialize(vContext:class.Context, vSelfType:OrNil(class.LuaTable)):Ret(class.TypeFunction)
	local nLateCom = self._lateFnCom
	assert(LateFnCom.is(nLateCom), "only LateFnCom can specificate")
	const nDefaultFn = nLateCom:getDefaultFn()
	if not vSelfType then
		assert(TypeFunction.is(nDefaultFn), "only type function can be auto specialize")
		return nDefaultFn
	else
		assert(MemberFunction.is(nDefaultFn), "only member function can be auto specialize with self")
		return nDefaultFn:indexTypeFn(vSelfType)
	end
end

function LuaFunction:isMember():Ret(Boolean)
	return self._isMember
end

function LuaFunction:fnPartType()
	return self
end

function LuaFunction:mayRecursive()
	return true
end

function LuaFunction:getNode():Ret(class.IAstNode)
	return self._node
end

function LuaFunction:getGenFunc():Ret(class.GenFunc)
	return self._hintCom:getGenFunc()
end

function.open LuaFunction.is(vType):isguard(class.LuaFunction)
	return getmetatable(vType) == LuaFunction
end

return LuaFunction
