
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local AtomTypeClass = require "thlua.type.AtomTypeClass"
local Exception = require "thlua.Exception"

local OpenFnCom = require "thlua.func.OpenFnCom"
local LateFnCom = require "thlua.func.LateFnCom"
local ClassFnCom = require "thlua.func.ClassFnCom"

local LuaFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function LuaFunction.new(vManager:class.TypeManager)::RetClass(class.LuaFunction, class.IAtomType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_context=false@class.Context,
		_node=false@class.AstNode,
		_unionFnCom=false@class.UFnCom,
		_runFunc=false@class.GenFunc,
		_autoArgs=false@class.AutoArguments,
		bits=TYPE_BITS.FUNCTION,
		name="unknown"@String,
		id=vManager:genTypeId(),
	}, LuaFunction)
	return self
end

function LuaFunction:setFnCom(vUnionTagFn:class.UFnCom)
	self._unionFnCom = vUnionTagFn
end

function LuaFunction:init(vContext:class.Context, vNode:class.AstNode, vAutoArgs:class.AutoArguments, vRunFunc:class.GenFunc)
	self._context = vContext
	self._node = vNode
	self._runFunc = vRunFunc
	self._autoArgs = vAutoArgs
	self.name = tostring(vNode)
end

function LuaFunction:newInplaceSealContext()::Ret(class.Context)
	return self._context:newSealContext(self._node)
end

function LuaFunction:newInplaceOpenContext()::Ret(class.Context)
	return self._context:newOpenContext(self._node)
end

function LuaFunction:isNative()::Ret(Boolean)
	return OpenFnCom.is(self._unionFnCom)
end

function LuaFunction:detailString(v)
	return "LuaFunction-"..self.name
end

function LuaFunction:getFnCom()
	return self._unionFnCom
end

function LuaFunction:meta_native_call(vContext, vTermTuple)
	assert(self:isNative(), "only native fn can call meta_native_call")
	return self._unionFnCom:meta_native_call(vContext, vTermTuple)
end

function LuaFunction:meta_call(vContext, vTypeTuple)
	assert(not self:isNative(), "native fn can't call meta_call")
	return self._unionFnCom:meta_call(vContext, vTypeTuple)
end

function LuaFunction:_intersectOneNotRefer(vType)
	if vType == self then
		return self
	elseif vType:_containOneNotRefer(self) then
		return self
	else
		return false
	end
end

function LuaFunction:_containOneNotRefer(vType)
	if vType == self then
		return self
	else
		return false
	end
end

function LuaFunction:isSingleton()
	return false
end

function LuaFunction:native_type()
	return self._manager:Literal("function")
end

function LuaFunction:cast(vContext, vTypeFn)::Ret(Boolean)
	return self._unionFnCom:cast(vContext, vTypeFn)
end

function LuaFunction:implement(vContext, vSelfType, vIntfFnOrNil)
	local nUnionCom = self._unionFnCom
	if LateFnCom.is(nUnionCom) then
		return self._unionFnCom:implement(vContext, vSelfType, vIntfFnOrNil)
	else
		vContext:error("invalid as member")
		return false
	end
end

function LuaFunction:isMember()
	return self._autoArgs:hasSelf() and LateFnCom.is(self._unionFnCom)
end

function LuaFunction:getNode()::Ret(class.AstNode)
	return self._node
end

function LuaFunction.is(vType)::isguard(class.LuaFunction)
	return getmetatable(vType) == LuaFunction
end

return LuaFunction
