
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const Exception = require "thlua.Exception"

const OpenFnCom = require "thlua.func.OpenFnCom"
const LateFnCom = require "thlua.func.LateFnCom"
const ClassFactory = require "thlua.func.ClassFactory"

const LuaFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function.class LuaFunction.new(vManager:class.TypeManager):RetClass(class.LuaFunction, class.IAtomType)
	local self = setmetatable({.class
		_manager=vManager,
		_context=false@class.Context,
		_node=false@class.IAstNode,
		_genFunc=false@class.GenFunc,
		_member=false@Boolean,
		_unionFnCom=nil@class.UFnCom,
		_hintCom=nil@class.FnHintCom,
		bits=TYPE_BITS.FUNCTION,
		name="unknown"@String,
		id=vManager:genTypeId(),
	}, LuaFunction)
	return self
end

function LuaFunction:setFnCom(vUnionTagFn:class.UFnCom)
	self._unionFnCom = vUnionTagFn
end

function LuaFunction:setMember()
	self._member = true
end

function LuaFunction:getHintCom():Ret(class.FnHintCom)
	return self._hintCom
end

function LuaFunction:init(vContext:class.Context, vNode:class.IAstNode, vHintCom:class.FnHintCom, vRunFunc:class.GenFunc)
	self._context = vContext
	self._node = vNode
	self._genFunc = vRunFunc
	self._hintCom = vHintCom
	self.name = tostring(vNode)
end

function LuaFunction:newInplaceSealContext():Ret(class.Context)
	return self._context:newSealContext(self._node)
end

function LuaFunction:newInplaceOpenContext():Ret(class.Context)
	return self._context:newOpenContext(self._node)
end

function LuaFunction:isNative():Ret(Boolean)
	return OpenFnCom.is(self._unionFnCom)
end

function LuaFunction:detailString(v, vVerbose)
	return "LuaFunction-"..self.name
end

function LuaFunction:getFnCom():Ret(class.UFnCom)
	return self._unionFnCom
end

function LuaFunction:meta_open_call(vContext:class.Context, vTermTuple:class.TermTuple):Ret(class.TermTuple)
	local nFnCom = self._unionFnCom
	if OpenFnCom.is(nFnCom) then
		return nFnCom:meta_open_call(vContext, vTermTuple)
	else
		error("only open or native fn can call meta_open_call")
	end
end

function LuaFunction:meta_poly_call(vContext, vTypeArgs, vTypeTuple)
	local nFnCom = self._unionFnCom
	if not OpenFnCom.is(nFnCom) then
		const nTypeFn = nFnCom:matchTypeFn(vContext, vTypeTuple)
		return nTypeFn:meta_poly_call(vContext, vTypeArgs, vTypeTuple)
	else
		error("open fn can't call meta_poly_call")
	end
end

function LuaFunction:assumeIntersectAtom(vAssumeSet, vType)
	if vType == self then
		return self
	elseif vType:assumeContainAtom(nil, self) then
		return self
	else
		return false
	end
end

function LuaFunction:assumeContainAtom(vAssumeSet, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function LuaFunction:isSingleton()
	return false
end

function LuaFunction:native_type()
	return self._manager:Literal("function")
end

function LuaFunction:cast(vContext:class.Context, vTypeFn:class.TypeFunction):Ret(OrFalse(class.TypeFunction))
	local nUnionFnCom = self._unionFnCom
	if LateFnCom.is(nUnionFnCom) then
		const nAfterTypeFn = self._hintCom:checkWhenCast(vContext, vTypeFn)
		nUnionFnCom:addCastSpecFn(nAfterTypeFn)
		return nAfterTypeFn
	else
		return false
	end
end

function LuaFunction:castSpecialize(vContext:class.Context, vTypeFn:class.TypeFunction):Ret(class.TypeFunction)
	const nLateCom = self._unionFnCom
	assert(LateFnCom.is(nLateCom), "only LateFnCom can specificate")
	const nAfterTypeFn = self._hintCom:checkWhenCast(vContext, vTypeFn)
	nLateCom:addCastSpecFn(nAfterTypeFn)
	return nAfterTypeFn
end

function LuaFunction:autoSpecialize(vContext:class.Context, vSelfType:OrNil(class.LuaTable)):Ret(class.TypeFunction)
	local nLateCom = self._unionFnCom
	assert(LateFnCom.is(nLateCom), "only LateFnCom can specificate")
	if not vSelfType then
		return nLateCom:typeDefault()
	else
		return nLateCom:selfSpecialize(vContext, vSelfType)
	end
end

function LuaFunction:isMember():Ret(Boolean)
	return self._member and LateFnCom.is(self._unionFnCom)
end

function LuaFunction:fnPartType()
	return self
end

function LuaFunction:mayRecursive()
	return true
end

function LuaFunction:getNode():Ret(class.IAstNode)
	return self._node
end

function LuaFunction:getGenFunc():Ret(class.GenFunc)
	return self._genFunc
end

function.open LuaFunction.is(vType):RetIs(class.LuaFunction)
	return getmetatable(vType) == LuaFunction
end

return LuaFunction
