
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const Exception = require "thlua.Exception"
const Enum = require "thlua.Enum"

const LateFnCom = require "thlua.func.LateFnCom"

const AutoFunction = require "thlua.refer.AutoFunction"
const ClassFactory = require "thlua.refer.ClassFactory"
const OpenFunction = require "thlua.func.OpenFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const TypeFunction = require "thlua.func.TypeFunction"
const PolyFunction = require "thlua.func.PolyFunction"

const LuaFunction = AtomTypeClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.LuaFunction) LuaFunction.new(vManager:clazz.TypeManager):impl(clazz.IAtomType)
	local self = setmetatable({.class
		_manager=vManager,
		_context=false@clazz.Context,
		_node=false@clazz.IAstNode,
		_isMember=false@Boolean,
		_innerFn=false@OrFalse(clazz.ULuaInnerFn),
		_lateFnCom=false@OrFalse(clazz.LateFnCom),
		_hintCom=nil@clazz.FunctionBuilder,
		bits=TYPE_BITS.FUNCTION,
		name="unknown"@String,
		id=vManager:genTypeId(),
	}, LuaFunction)
	return self
end

function LuaFunction:setMember()
	self._isMember = true
end

function LuaFunction:getBuilder():Ret(clazz.FunctionBuilder)
	return self._hintCom
end

function LuaFunction:lateInit(vContext:clazz.Context, vNode:clazz.IAstNode, vHintCom:clazz.FunctionBuilder, vLateFnCom:OrFalse(clazz.LateFnCom), vInnerFn:OrFalse(clazz.ULuaInnerFn))
	self._context = vContext
	self._node = vNode
	self._hintCom = vHintCom
	self._lateFnCom = vLateFnCom
	self._innerFn = vInnerFn
	self.name = tostring(vNode)
end

function LuaFunction:newInplaceSealContext():Ret(clazz.Context)
	return self._context:newSealContext(self._node)
end

function LuaFunction:newInplaceOpenContext():Ret(clazz.Context)
	return self._context:newOpenContext(self._node)
end

function LuaFunction:isOpen():Ret(Boolean)
	return OpenFunction.is(self._innerFn)
end

function LuaFunction:detailString(v, vVerbose)
	return "LuaFunction-"..self.name
end

function LuaFunction:meta_open_call(vContext:clazz.Context, vTermTuple:clazz.UTermTuple):Ret(clazz.UTermTuple)
	const nInnerFn = self._innerFn
	if OpenFunction.is(nInnerFn) then
		return nInnerFn:meta_open_call(vContext, vTermTuple)
	else
		error("only open or native fn can call meta_open_call"..tostring(nInnerFn))
	end
end

function LuaFunction:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	const nInnerFn = self._innerFn
	if MemberFunction.is(nInnerFn) then
		return nInnerFn:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	elseif PolyFunction.is(nInnerFn) then
		return nInnerFn:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	elseif AutoFunction.is(nInnerFn) or TypeFunction.is(nInnerFn) or ClassFactory.is(nInnerFn) then
		return self:meta_call(vContext, vTypeTuple)
	elseif OpenFunction.is(nInnerFn) then
		error("open function can't called with meta_invoke")
	else
		error("innerFn is empty, TODO")
	end
end

function LuaFunction:meta_call(vContext, vTypeTuple)
	const nInnerFn = self._innerFn
	if PolyFunction.is(nInnerFn) or TypeFunction.is(nInnerFn) or AutoFunction.is(nInnerFn) or ClassFactory.is(nInnerFn) then
		return nInnerFn:meta_call(vContext, vTypeTuple)
	else
		error("innerFn can't be called, TODO")
	end
end

function LuaFunction:assumeIntersectAtom(vAssumeSet, vType)
	if vType == self then
		return self
	elseif vType:assumeIncludeAtom(nil, self) then
		return self
	else
		return false
	end
end

function LuaFunction:assumeIncludeAtom(vAssumeSet, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function LuaFunction:isSingleton()
	return false
end

function LuaFunction:native_type()
	return self._manager:Literal("function")
end

function LuaFunction:castPoly(vContext, vTypeArgsList)
	const nInnerFn = self._innerFn
	if PolyFunction.is(nInnerFn) then
		return nInnerFn:castPoly(vContext, vTypeArgsList)
	else
		if TypeFunction.is(nInnerFn) then
			vContext:error("poly cast for non-poly function")
			return nInnerFn
		else
			error("TODO, poly cast error")
		end
	end
end

function LuaFunction:cast(vContext:clazz.Context, vTypeFn:clazz.TypeFunction):Ret(OrFalse(clazz.TypeFunction))
	const nUnionFnCom = self._lateFnCom
	if LateFnCom.is(nUnionFnCom) then
		const nAfterTypeFn = self._hintCom:checkWhenCast(vContext, vTypeFn)
		nUnionFnCom:addSpecFn(nAfterTypeFn)
		return nAfterTypeFn
	else
		return false
	end
end

function LuaFunction:castSpecialize(vContext:clazz.Context, vTypeFn:clazz.TypeFunction):Ret(clazz.TypeFunction)
	const nLateCom = self._lateFnCom
	assert(LateFnCom.is(nLateCom), "only LateFnCom can specificate")
	const nAfterTypeFn = self._hintCom:checkWhenCast(vContext, vTypeFn)
	nLateCom:addSpecFn(nAfterTypeFn)
	return nAfterTypeFn
end

function LuaFunction:autoSpecialize(vContext:clazz.Context, vSelfType:OrNil(clazz.LuaTable)):Ret(clazz.TypeFunction)
	local nLateCom = self._lateFnCom
	assert(LateFnCom.is(nLateCom), "only LateFnCom can specificate")
	const nInnerFn = self._innerFn
	if not vSelfType then
		assert(AutoFunction.is(nInnerFn), "only auto function can be specialized without self")
		return nInnerFn:getFnAwait()
	else
		assert(MemberFunction.is(nInnerFn), "only member function can be specialized with self")
		return nInnerFn:indexTypeFn(vSelfType)
	end
end

function LuaFunction:getInnerFn():Ret(OrFalse(clazz.ULuaInnerFn))
	return self._innerFn
end

function LuaFunction:isMember():Ret(Boolean)
	return self._isMember
end

function LuaFunction:fnPartType()
	return self
end

function LuaFunction:mayRecursive()
	return true
end

function LuaFunction:getNode():Ret(clazz.IAstNode)
	return self._node
end

function LuaFunction:getGenFunc():Ret(clazz.GenFunc)
	return self._hintCom:getGenFunc()
end

function.open LuaFunction.is(vType):isguard(clazz.LuaFunction)
	return getmetatable(vType) == LuaFunction
end

return LuaFunction
