
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const Exception = require "thlua.Exception"
const TypeFunction = require "thlua.func.TypeFunction"

const MemberFunction = {}
MemberFunction.__index=MemberFunction

(@let.class = import("thlua.type.TypeClass").class)

function MemberFunction.__tostring(self:class.MemberFunction):Ret(String)
	return self:detailString({}, true)
end

function.class MemberFunction.new(vManager:class.TypeManager, vNode:class.IAstNode,
	vTypeFn:class.TypeFunction):RetClass(class.MemberFunction)
	local self = setmetatable({.class
		_manager=vManager,
		_node=vNode,
		_innerFn=vTypeFn,
		_typeFnDict={} @ Dict(class.IAtomType, class.TypeFunction),
	}, MemberFunction)
	return self
end

function MemberFunction:detailString(vToStringCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
	return "member:"..self._innerFn:detailString(vToStringCache, vVerbose)
end

function MemberFunction:Dots(vType:class.UAllType):Ret(class.MemberFunction)
	self._innerFn:Dots(vType)
	return self
end

function MemberFunction:Ret(...:Truth):Ret(class.MemberFunction)
	self._innerFn:Ret(...)
	return self
end

function MemberFunction:indexTypeFn(vType:class.IAtomType):Ret(class.TypeFunction)
	local nTypeFn = self._typeFnDict[vType]
	if not nTypeFn then
		const nRetTuples = self._innerFn:getRetTuples()
		const nParTuple = self._innerFn:getParTuple():concatFirst(vType)
		nTypeFn = self._manager:Function(nParTuple, nRetTuples)
		self._typeFnDict[vType] = nTypeFn
	end
	return nTypeFn
end

function MemberFunction:mayRecursive():Ret(True)
	return true
end

function.open MemberFunction.is(vType):RetIs(class.MemberFunction)
	return getmetatable(vType) == MemberFunction
end

return MemberFunction
