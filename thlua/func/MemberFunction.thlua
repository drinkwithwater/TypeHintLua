
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const Exception = require "thlua.Exception"

const TypeFunction = require "thlua.func.TypeFunction"
const PolyFunction = require "thlua.func.PolyFunction"
const AutoFunction = require "thlua.func.AutoFunction"

const MemberFunction = {}
MemberFunction.__index=MemberFunction

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

function MemberFunction.__tostring(self:clazz.MemberFunction):Ret(String)
	return self:detailString({}, true)
end

function:class(clazz.MemberFunction) MemberFunction.new(vManager:clazz.TypeManager, vNode:clazz.IAstNode,
	vPolyFn:clazz.PolyFunction, vWildFn:OrFalse(clazz.TypeFunction))
	const self = setmetatable({.class
		_manager=vManager,
		_node=vNode,
		_wildFn=vWildFn,
		_polyFn=vPolyFn,
	}, MemberFunction)
	return self
end

function MemberFunction:detailString(vToStringCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
	const nWildFn = self._wildFn
	if nWildFn then
		local nCache = vToStringCache[self]
		if nCache then
			return nCache
		end
		const nParTuple = nWildFn:getParTuple()
		const nRetTuples = nWildFn:getRetTuples()
		vToStringCache[self] = "member:fn-..."
		const nResult = "member:fn-" .. nParTuple:detailStringIfFirst(vToStringCache, vVerbose, false)..
										"->"..nRetTuples:detailString(vToStringCache, vVerbose)
		vToStringCache[self] = nResult
		return nResult
	else
		return "MemberFunction("..tostring(self._node)..")"
	end
end

function MemberFunction:Dots(vType:clazz.UAllType):Ret(clazz.MemberFunction)
	const nWildFn = assert(self._wildFn, "member function without wildfn can't take :Dots")
	nWildFn:Dots(vType)
	return self
end

function MemberFunction:RetDots(vFirst:clazz.UAllType, ...:clazz.UAllType):Ret(clazz.MemberFunction)
	const nWildFn = assert(self._wildFn, "member function without wildfn can't take :Ret")
	nWildFn:Ret(vFirst, ...)
	return self
end

function MemberFunction:Ret(...:clazz.UAllType):Ret(clazz.MemberFunction)
	const nWildFn = assert(self._wildFn, "member function without wildfn can't take :Ret")
	nWildFn:Ret(...)
	return self
end

function MemberFunction:getPolyFn():Ret(clazz.PolyFunction)
	return self._polyFn
end

function MemberFunction:meta_invoke(
	vContext:clazz.OperContext,
	vSelfType:clazz.UAllType,
	vPolyArgs:List(clazz.UAllType),
	vTypeTuple:clazz.UTermTuple
):Ret(clazz.RetTuples)
	if #vPolyArgs == 0 and self:needPolyArgs() then
		vContext:error("TODO poly member function called without poly args")
	end
	const nTypeFn = self._polyFn:noCtxCastPoly({vSelfType, table.unpack(vPolyArgs)})
	return nTypeFn:meta_call(vContext, vTypeTuple)
end

function MemberFunction:needPolyArgs():Ret(Boolean)
	return self._polyFn:getPolyParNum() > 1
end

function MemberFunction:indexAutoFn(vType:clazz.UAllType):Ret(clazz.AutoFunction)
	const nFn = self._polyFn:noCtxCastPoly({vType})
	if AutoFunction.is(nFn) then
		return nFn
	else
		error("auto function is expected here")
	end
end

function MemberFunction:indexTypeFn(vType:clazz.UAllType):Ret(clazz.TypeFunction)
	const nFn = self._polyFn:noCtxCastPoly({vType})
	if AutoFunction.is(nFn) then
		return nFn:getFnAwait()
	elseif TypeFunction.is(nFn) then
		return nFn
	else
		error("class factory can't member function")
	end
end

function MemberFunction:mayRecursive():Ret(True)
	return true
end

function.open MemberFunction.is(vType):isguard(clazz.MemberFunction)
	return getmetatable(vType) == MemberFunction
end

return MemberFunction
