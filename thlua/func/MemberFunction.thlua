
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const Exception = require "thlua.Exception"

const TypeFunction = require "thlua.func.TypeFunction"
const PolyFunction = require "thlua.func.PolyFunction"

const MemberFunction = {}
MemberFunction.__index=MemberFunction

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

function MemberFunction.__tostring(self:clazz.MemberFunction):Ret(String)
	return self:detailString({}, true)
end

function:class(clazz.MemberFunction) MemberFunction.new(vManager:clazz.TypeManager, vNode:clazz.IAstNode,
	vPolyFn:clazz.PolyFunction, vWildFn:OrFalse(clazz.TypeFunction))
	const self = setmetatable({.class
		_manager=vManager,
		_node=vNode,
		_wildFn=vWildFn,
		_polyFn=vPolyFn,
	}, MemberFunction)
	return self
end

function MemberFunction:detailString(vToStringCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
	const nWildFn = self._wildFn
	if nWildFn then
		local nCache = vToStringCache[self]
		if nCache then
			return nCache
		end
		const nParTuple = nWildFn:getParTuple()
		const nRetTuples = nWildFn:getRetTuples()
		vToStringCache[self] = "member:fn-..."
		const nResult = "member:fn-" .. nParTuple:detailStringIfFirst(vToStringCache, vVerbose, false)..
										"->"..nRetTuples:detailString(vToStringCache, vVerbose)
		vToStringCache[self] = nResult
		return nResult
	else
		return "MemberFunction("..tostring(self._node)..")"
	end
end

function MemberFunction:Dots(vType:clazz.UAllType):Ret(clazz.MemberFunction)
	const nWildFn = assert(self._wildFn, "member function without wildfn can't take :Dots")
	nWildFn:Dots(vType)
	return self
end

function MemberFunction:RetDots(vFirst:clazz.UAllType, ...:clazz.UAllType):Ret(clazz.MemberFunction)
	const nWildFn = assert(self._wildFn, "member function without wildfn can't take :Ret")
	nWildFn:Ret(vFirst, ...)
	return self
end

function MemberFunction:Ret(...:clazz.UAllType):Ret(clazz.MemberFunction)
	const nWildFn = assert(self._wildFn, "member function without wildfn can't take :Ret")
	nWildFn:Ret(...)
	return self
end

function MemberFunction:getPolyFn():Ret(clazz.PolyFunction)
	return self._polyFn
end

function MemberFunction:meta_invoke(
	vContext:clazz.Context,
	vSelfType:clazz.UAllType,
	vPolyArgs:List(clazz.UAllType),
	vTypeTuple:clazz.UTypeTuple
):Ret(clazz.RetTuples)
	if #vPolyArgs == 0 and self:needPolyArgs() then
		vContext:error("TODO poly member function called without poly args")
	end
	const nTypeFn = self._polyFn:noCtxCastPoly({vSelfType, table.unpack(vPolyArgs)})
	return nTypeFn:meta_call(vContext, vTypeTuple)
end

function MemberFunction:needPolyArgs():Ret(Boolean)
	return self._polyFn:getPolyParNum() > 1
end

function MemberFunction:indexTypeFn(vType:clazz.IAtomType):Ret(clazz.TypeFunction)
	return self._polyFn:noCtxCastPoly({vType})
end

function MemberFunction:mayRecursive():Ret(True)
	return true
end

function.open MemberFunction.is(vType):isguard(clazz.MemberFunction)
	return getmetatable(vType) == MemberFunction
end

return MemberFunction
