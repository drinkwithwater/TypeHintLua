
local Reference = require "thlua.type.Reference"
local TermCase = require "thlua.term.TermCase"
local LuaFunction = require "thlua.func.LuaFunction"
local FnComClass = require "thlua.func.FnComClass"

local NewRetFnCom = FnComClass()

(@var.class = import("thlua.type.TypeClass").class)

function NewRetFnCom.new(vManager:class.TypeManager, vLuaFunction:class.LuaFunction)::RetNew(class.NewRetFnCom, class.IFnCom)
	local self = setmetatable({::New()
		tag=LuaFunction.NEW_RET,
		_manager=vManager,
		_luaFunction=vLuaFunction,
		_typeFunction=false,
		_newTypeRefer=false,
		_newTypeImpl=vManager:Struct {},
		_isClass=false,
		_once=false,
		_onceHintNew=false,
	}, NewRetFnCom)
	vLuaFunction:setFnCom(self)
	return self
end

function NewRetFnCom:initByRetNew(vContext, vIsClass, vRefer, vStruct)
	self._newTypeRefer = vRefer
	self._isClass = vIsClass
	if vStruct then
		self._newTypeImpl = vStruct 
	end
	local nAutoArgs = self._luaFunction._autoArgs
	local nArgTuple = nAutoArgs:checkWhenLate(vContext)
	local nRetTuples = self._manager:SingleRetTuples(self._manager:Tuple(vRefer))
	self._typeFunction = self._manager:Function(nArgTuple, nRetTuples)
end

function NewRetFnCom:checkDefine()
	if self._once then
		return
	end
	self._once = true
	local nRefer = self._newTypeRefer
	local nImplType = self._newTypeImpl:checkType()
	local nContext = self._luaFunction:newInplaceContext()
	nRefer:setTypeAsync(function()
		--return nContext._manager:LuaTable(self._manager:Struct {})
		local nTable = nContext._manager:LuaTable()
		if self._isClass then
			nTable:initByClass(false, nImplType)
		end
		return nTable
	end)
	local nTypeTuple = self._typeFunction:getArgTuple()
	self._luaFunction._runFunc(nContext, nTypeTuple:makeTermTuple())
	nRefer:getType():sealNew(nContext)
end

function NewRetFnCom:meta_call(vContext, vTermTuple)
	self:checkDefine()
	return self._typeFunction:meta_call(vContext, vTermTuple)
end

function NewRetFnCom:regionTableNew(vContext, vNode)
	assert(not self._onceHintNew, "New() can only be called once")
	self._onceHintNew = true
	local nRefer = self._newTypeRefer
	local nTableType = nRefer:checkType()
	return nTableType
end

function NewRetFnCom:regionReturn(vContext, vNode, vTypeTuple)
	if vTypeTuple:getRepeatType() or #vTypeTuple~=1 then
		vContext:nodeError(vNode, "return tuple not match")
	else
		local aType = vTypeTuple:get(1):checkType()
		local bType = self._newTypeRefer:checkType()
		if aType ~= bType then
			vContext:nodeError(vNode, "return type not match")
		end
	end
end

function NewRetFnCom:regionEnd(vContext, vNode, vTermTupleList)
	if #vTermTupleList <= 0 then
		vContext:nodeError(vNode, "return statement not found")
	end
end

return NewRetFnCom
