
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const TermTuple = require "thlua.tuple.TermTuple"
const Exception = require "thlua.Exception"

const OpenFunction = AtomTypeClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.OpenFunction) OpenFunction.new(
	vManager:clazz.TypeManager
):impl(clazz.IAtomType)
	const self = setmetatable({.class
		_manager=vManager,
		_func=nil@OrNil(clazz.OpenCaller),
		name="unknown"@String,
		bits=TYPE_BITS.FUNCTION,
		id=vManager:genTypeId(),
	}, OpenFunction)
	return self
end

function OpenFunction:lateInitFromAutoNative(vNativeFunc:clazz.OpenCaller):Ret(clazz.OpenFunction)
	self._func = vNativeFunc
	return self
end

function OpenFunction:lateInitFromFixedNative(vNativeFunc:clazz.FixedNativeFunc):Ret(clazz.OpenFunction)
	const nFn:clazz.OpenCaller = function(vContext, vTermTuple)
		assert(TermTuple.isFixed(vTermTuple), Exception.new("this native func can't take auto term", vContext:getNode()))
		const re = vNativeFunc(vContext, vTermTuple)
		if TermTuple.is(re) then
			return re
		else
			return vContext:TermTupleByAppend({re}, false)
		end
	end
	self._func = nFn
	return self
end

function OpenFunction:lateInitFromGenFunc(vHintTypeList:List(OrFalse(clazz.UAllType)), vGenFunc:clazz.GenFunc):Ret(clazz.OpenFunction)
	const nFn:clazz.OpenCaller = function(vContext, vTermTuple)
		return vGenFunc(self, vContext, vTermTuple, vHintTypeList, {}, false)
	end
	self._func = nFn
	return self
end

function OpenFunction:lateInitFromGuard(vType:clazz.UAllType):Ret(clazz.OpenFunction)
	const nTrue = self._manager.type.True
	const nFalse = self._manager.type.False
	const nFn:clazz.OpenCaller = function(vContext, vTermTuple)
		const nIsLuaTable, nTableType = self._manager:tryLuaTable(vType)
		assert(nIsLuaTable, "assert lua table failed")
		assert(TermTuple.isFixed(vTermTuple), "guard function can't take auto term")
		const nTerm = vTermTuple:get(vContext, 1)
		const caseTrue = nTerm:caseIsType(nTableType)
		const caseFalse = nTerm:caseIsNotType(nTableType)
		const nTypeCaseList:List(clazz.TypeCasePair) = {}
		if caseTrue then
			nTypeCaseList[#nTypeCaseList + 1] = {nTrue, caseTrue}
		end
		if caseFalse then
			nTypeCaseList[#nTypeCaseList + 1] = {nFalse, caseFalse}
		end
		return vContext:TermTuple({self._manager:mergeToRefineTerm(nTypeCaseList)})
	end
	self._func = nFn
	return self
end

function OpenFunction:isOpen():Ret(True)
	return true
end

function OpenFunction:detailString(v, vVerbose)
	return "OpenFunction-"..self.name
end

function OpenFunction:set_name(name:String)
	self.name = name
end

function OpenFunction:meta_open_call(vContext:clazz.Context, vTermTuple:clazz.UTermTuple):Ret(clazz.UTermTuple)
	return self._func!(vContext, vTermTuple)
end

function OpenFunction:assumeIntersectAtom(vAssumeSet, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function OpenFunction:assumeIncludeAtom(vAssumeSet, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function OpenFunction:fnPartType()
	return self
end

function OpenFunction:isSingleton()
	return true
end

function OpenFunction:mayRecursive()
	return true
end

function.open OpenFunction.is(vType):isguard(clazz.OpenFunction)
	return getmetatable(vType) == OpenFunction
end

return OpenFunction
