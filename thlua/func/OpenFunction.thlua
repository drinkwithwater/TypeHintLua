
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const TermTuple = require "thlua.tuple.TermTuple"
const Exception = require "thlua.Exception"

const BaseFunction = require "thlua.func.BaseFunction"
const class = require "thlua.class"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const OpenFunction = class@<clazz.OpenFunction, false>(BaseFunction)

function.open OpenFunction:ctor(vManager:clazz.TypeManager, vNode:clazz.IAstNode, vParentStack:clazz.BaseStack, vUpValueCase:OrNil(False, clazz.VariableCase))
	self._func=nil@OrNil(clazz.OpenCaller)
	self._polyWrapper=false@OrFalse(Fn(List(clazz.UAllType)):Ret(clazz.OpenFunction))
	self._node = vNode
	self._lexStack = vParentStack
	self._uvCase = vUpValueCase or false
	self.name="unknown"@String
end

function OpenFunction:getStack()
	return self._lexStack
end

function OpenFunction:lateInitFromAutoNative(vNativeFunc:clazz.OpenCaller):Ret(clazz.OpenFunction)
	self._func = vNativeFunc
	return self
end

function OpenFunction:lateInitFromFixedNative(vNativeFunc:clazz.FixedNativeFunc):Ret(clazz.OpenFunction)
	const nFn:clazz.OpenCaller = function(vStack, vTermTuple)
		assert(TermTuple.isFixed(vTermTuple), Exception.new("this native func can't take auto term", vStack:getNode()))
		const nInplaceContext = vStack:getHeadContext()
		const re = vNativeFunc(nInplaceContext, vTermTuple)
		if TermTuple.is(re) then
			return re
		else
			return nInplaceContext:UTermTupleByAppend({re}, false)
		end
	end
	self._func = nFn
	return self
end

function OpenFunction:castPoly(vContext, vTypeList)
	const nPolyWrapper = self._polyWrapper
	if nPolyWrapper then
		return nPolyWrapper(vTypeList)
	else
		vContext:error("this open function can't cast poly")
		return self
	end
end

function OpenFunction:lateInitFromBuilder(vPolyParNum:Integer, vFunc:Fn(clazz.OpenFunction, clazz.BaseStack, List(clazz.UAllType), clazz.UTermTuple):Ret(clazz.UTermTuple)):Ret(clazz.OpenFunction)
	const nNoPolyFn:$self._func = function(vStack, vTermTuple)
		if vPolyParNum == 0 then
			return vFunc(self, vStack, {}, vTermTuple)
		else
			vStack:error("this open function need poly args")
		end
	end
	const nPolyWrapper:$self._polyWrapper = function(vList)
		return self._lexStack:newOpenFunction(self._node, self._uvCase):lateInitFromAutoNative(function(vStack, vTermTuple)
			if #vList ~= vPolyParNum then
				vStack:error("poly args number not match")
			end
			return vFunc(self, vStack, vList, vTermTuple)
		end)
	end
	self._func = nNoPolyFn
	self._polyWrapper = nPolyWrapper
	return self
end

function OpenFunction:lateInitFromGuard(vType:clazz.UAllType):Ret(clazz.OpenFunction)
	const nTrue = self._manager.type.True
	const nFalse = self._manager.type.False
	const nFn:clazz.OpenCaller = function(vStack, vTermTuple)
		const nHeadContext = vStack:getHeadContext()
		const nIsBaseTable, nTableType = self._manager:tryBaseTable(vType)
		assert(nIsBaseTable, "assert lua table failed")
		assert(TermTuple.isFixed(vTermTuple), "guard function can't take auto term")
		const nTerm = vTermTuple:get(nHeadContext, 1)
		const caseTrue = nTerm:caseIsType(nTableType)
		const caseFalse = nTerm:caseIsNotType(nTableType)
		const nTypeCaseList:List(clazz.TypeCasePair) = {}
		if caseTrue then
			nTypeCaseList[#nTypeCaseList + 1] = {nTrue, caseTrue}
		end
		if caseFalse then
			nTypeCaseList[#nTypeCaseList + 1] = {nFalse, caseFalse}
		end
		return vStack:getTailContext():FixedTermTuple({nHeadContext:mergeToRefineTerm(nTypeCaseList)})
	end
	self._func = nFn
	return self
end

function OpenFunction:detailString(v, vVerbose)
	return "OpenFunction-"..self.name
end

function OpenFunction:set_name(name:String)
	self.name = name
end

function OpenFunction:newStack(vContext:clazz.ApplyContext)
	return self._lexStack:getRuntime():OpenStack(vContext:getNode(), self._uvCase, self, vContext:getStack())
end

function OpenFunction:meta_call(vContext, vTermTuple)
	const nRet = self:meta_open_call(vContext, vTermTuple)
	vContext:pushOpenReturn(nRet)
end

function OpenFunction:meta_open_call(vContext:clazz.ApplyContext, vTermTuple:clazz.UTermTuple):Ret(clazz.UTermTuple, clazz.OpenStack)
	const nNewStack = self:newStack(vContext)
	return self._func!(nNewStack, vTermTuple), nNewStack
end

function OpenFunction:assumeIntersectAtom(vAssumeSet, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function OpenFunction:assumeIncludeAtom(vAssumeSet, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function OpenFunction:fnPartType()
	return self
end

function OpenFunction:isSingleton()
	return true
end

function OpenFunction:mayRecursive()
	return false
end

return OpenFunction
