
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const Exception = require "thlua.Exception"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const TypeFunction = require "thlua.func.TypeFunction"

const PolyFunction = AtomTypeClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.PolyFunction) PolyFunction.new(vManager:clazz.TypeManager, vNode:clazz.IAstNode, vFunc:AnyFunction, vPolyParNum:Integer):impl(clazz.IAtomType)
	local self = setmetatable({.class
		_manager=vManager,
		_polyParNum=vPolyParNum,
		_innerFunc=vFunc,
		_polyCallPairDict = {} @ Dict(String, Struct {clazz.TypeFunction, List(clazz.UAllType)}),
		bits=TYPE_BITS.FUNCTION,
		id=vManager:genTypeId(),
	}, PolyFunction)
	return self
end

function PolyFunction:detailString(vToStringCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
	return "PolyFunction"
end

function PolyFunction:isOpen():Ret(False)
	return false
end

function PolyFunction:getPolyCallPairDict():Ret(Dict(String, Struct {clazz.TypeFunction, List(clazz.UAllType)}))
	return self._polyCallPairDict
end

function PolyFunction:getPolyParNum():Ret(Integer)
	return self._polyParNum
end

function PolyFunction:noCtxCastPoly(vTypeList:List(clazz.UAllType)):Ret(clazz.TypeFunction)
	assert(#vTypeList == self._polyParNum, "PolyFunction type args num not match")
	const nAtomUnionList:List(clazz.UAtomUnion) = {}
	for i=1, #vTypeList do
		nAtomUnionList[i] = vTypeList[i]!:checkAtomUnion()
	end
	const nKey = self._manager:signTemplateArgs(nAtomUnionList)
	const nPair = self._polyCallPairDict[nKey]
	if not nPair then
		const nResult = (self._innerFunc(table.unpack(vTypeList)) @ Any)
		if not TypeFunction.is(nResult) then
			error("poly function must return Fn type but got:"..tostring(nResult))
		end
		self._polyCallPairDict[nKey] = {nResult, vTypeList}
		return nResult
	else
		return nPair[1]
	end
end

function PolyFunction:castPoly(vContext, vTypeList)
	return self:noCtxCastPoly(vTypeList)
end

function PolyFunction:native_type()
	return self._manager:Literal("function")
end

function PolyFunction:meta_call(vContext, vTypeTuple)
	error("poly function meta_call TODO")
	-- TODO
end

function PolyFunction:assumeIncludeAtom(vAssumeSet, vRight)
	return self == vRight and self
end

function PolyFunction:assumeIntersectAtom(vAssumeSet, vRight)
	return self == vRight and self
end

function PolyFunction:fnPartType()
	return self
end

function PolyFunction:mayRecursive()
	return false
end

function PolyFunction:isSingleton()
	return false
end

function.open PolyFunction.is(vType):isguard(clazz.PolyFunction)
	return getmetatable(vType) == PolyFunction
end

return PolyFunction
