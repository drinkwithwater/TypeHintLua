
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const Exception = require "thlua.Exception"
const AtomTypeClass = require "thlua.type.AtomTypeClass"

const PolyFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function.class PolyFunction.new(vManager:class.TypeManager, vNode:class.IAstNode, vFunc:Truth):RetClass(class.PolyFunction, class.IAtomType)
	const nInfo = debug.getinfo(vFunc)
	local self = setmetatable({.class
		_manager=vManager,
		_nparams = nInfo.nparams,
		_func = vFunc,
		bits=TYPE_BITS.FUNCTION,
		id=vManager:genTypeId(),
	}, PolyFunction)
	return self
end

function PolyFunction:detailString(vToStringCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
	return "PolyFunction"
end

function PolyFunction:isNative():Ret(False)
	return false
end

function PolyFunction:native_type()
	return self._manager:Literal("function")
end

function PolyFunction:meta_call(vContext, vTypeTuple)
	error("poly function meta_call TODO")
	-- TODO
end

function PolyFunction:assumeContainAtom(vAssumeSet, vRight)
	return self == vRight and self
end

function PolyFunction:assumeIntersectAtom(vAssumeSet, vRight)
	return self == vRight and self
end

function PolyFunction:fnPartType()
	return self
end

function PolyFunction:mayRecursive()
	return false
end

function PolyFunction:isSingleton()
	return false
end

function.open PolyFunction.is(vType):RetIs(class.PolyFunction)
	return getmetatable(vType) == PolyFunction
end

return PolyFunction
