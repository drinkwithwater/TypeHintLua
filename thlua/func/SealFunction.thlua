
const ScheduleTask = require "thlua.manager.ScheduleTask"
const Exception = require "thlua.Exception"

const MonoFunction = require "thlua.func.MonoFunction"

const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const SealFunction = class@<clazz.SealFunction, false>(MonoFunction)

function.open SealFunction:ctor(vManager:clazz.TypeManager, vNode:clazz.IAstNode, vParentStack:OrFalse(clazz.BaseStack), vUpValueCase:OrFalse(clazz.VariableCase))
	const nRuntime = vManager:getRuntime()
	const nNewStack = nRuntime:SealStack(vNode, vParentStack, self @ Union(clazz.AutoFunction, clazz.ClassFactory), vUpValueCase)
	self._stack = nNewStack
	const nTask = nRuntime:getScheduleManager():newTask(nNewStack)
	self._task = nTask
	self._node = vNode
	self._headStartEvent=nTask:makeWildEvent()
	self._headFinishEvent=nTask:makeEvent()
	self._bodyStartEvent=nTask:makeWildEvent()
	self._bodyFinishEvent=nTask:makeEvent()
	self._typeFn=false@OrFalse(clazz.TypeFunction)
end

function SealFunction:meta_call(vContext:clazz.OperContext, vTermTuple:clazz.UTermTuple):Ret(clazz.RetTuples)
	const nTypeFn = self:getFnAwait()
	return nTypeFn:meta_call(vContext, vTermTuple)
end

function SealFunction:getAssignNode()
	return self._node
end

function SealFunction:assumeIncludeAtom(_, vType)
	if vType == self then
		return self
	else
		return false
	end
end

function SealFunction:assumeIntersectAtom(_, vType)
	if vType == self then
		return vType
	else
		return false
	end
end

function SealFunction:getStack()
	return self._stack
end

return SealFunction
