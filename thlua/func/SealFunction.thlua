
const ScheduleTask = require "thlua.manager.ScheduleTask"
const Exception = require "thlua.Exception"

const BaseFunction = require "thlua.func.BaseFunction"

const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
end)

const SealFunction = class@<clazz.SealFunction, false>(BaseFunction)

function.open SealFunction:ctor(vManager:clazz.TypeManager, vNode:clazz.IAstNode, vLexShot:OrFalse(clazz.LexShot))
	const nNewStack = vManager:getRuntime():SealStack(vNode, vLexShot, self @> Union(clazz.AutoFunction, clazz.ClassFactory))
	self._lexStack = vLexShot and vLexShot.branch:getStack() or false
	self._buildStack = nNewStack
	const nTask = vManager:getScheduleManager():newTask(nNewStack)
	self._task = nTask
	self._node = vNode
	self._headFinishEvent=nTask:makeEvent()
	self._bodyStartEvent=nTask:makeWildEvent()
	self._bodyFinishEvent=nTask:makeEvent()
	self._typeFn=false@OrFalse(clazz.TypedFunction)
	self._retTuples=false@OrFalse(clazz.RetTuples)
	self._buildingFn=false@OrFalse(Fn())
end

function SealFunction:meta_call(vContext, vTermTuple)
	const nTypeFn = self:getFnAwait()
	return nTypeFn:meta_call(vContext, vTermTuple)
end

function SealFunction:getFnAwait():Ret(clazz.TypedFunction)
	if not self._typeFn then
		self:_build()
		self._headFinishEvent:wait()
		if not self._typeFn then
			self._bodyStartEvent:wakeup()
			self._bodyFinishEvent:wait()
		end
	end
	return (assert(self._typeFn, "_typeFn must existed here"))
end

function SealFunction:getNode()
	return self._node
end

function SealFunction:getBuildStack()
	return self._buildStack
end

function SealFunction:findRequireStack()
	const nLexShot = self._lexShot
	if not nLexShot then
		return false
	end
	return nLexShot.branch:getStack():findRequireStack()
end

function SealFunction:getRetTuples():Ret(OrFalse(clazz.RetTuples))
	return self._retTuples
end

function SealFunction:_build()
	const nFn = self._buildingFn
	if nFn then
		self._buildingFn = false
		self._task:runAsync(nFn)
	end
end

function SealFunction:buildAsync(vRunner:Fn():Ret(
	OrFalse(clazz.UTypeTuple), OrFalse(clazz.RetTuples), Fn():Ret(
		clazz.UTypeTuple, clazz.RetTuples
	)
))
	self._buildingFn=function()
		const nParTuple, nRetTuples, nLateRunner = vRunner()
		self._retTuples = nRetTuples
		if nParTuple and nRetTuples then
			self._typeFn = self._manager:TypedFunction(self._node, nParTuple, nRetTuples)
		end
		self._headFinishEvent:wakeup()
		self._bodyStartEvent:wait()
		const nParTuple, nRetTuples = nLateRunner()
		self._typeFn = self._typeFn or self._manager:TypedFunction(self._node, nParTuple, nRetTuples)
		self._bodyFinishEvent:wakeup()
	end
end

function SealFunction:startTask()
	self:_build()
	self._bodyStartEvent:wakeup()
end

function SealFunction:findRequireStack()
	const nLexStack = self._lexStack
	return nLexStack and nLexStack:findRequireStack() or false
end

function SealFunction:getIfLuaNode():Ret(False):Ret(True, clazz.IAstNode)
	return true, self._node
end

return SealFunction
