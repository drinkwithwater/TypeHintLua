
const BaseTask = require "thlua.refer.BaseTask"
const Exception = require "thlua.Exception"

const MonoFunction = require "thlua.func.MonoFunction"

const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const SealFunction = class@<clazz.SealFunction, false>(MonoFunction)

function.open SealFunction:ctor(vManager:clazz.TypeManager, vNode:clazz.IAstNode, vParentContext:OrFalse(clazz.BodyContext))
	const nRuntime = vManager:getRuntime()
	const nNewContext = nRuntime:SealContext(vNode, vParentContext)
	self._context = nNewContext
	const nTask = BaseTask.new(vManager, nNewContext)
	self._task = nTask
	self._node = vNode
	self._headStartEvent=nTask:makeWildEvent()
	self._headFinishEvent=nTask:makeEvent()
	self._bodyStartEvent=nTask:makeWildEvent()
	self._bodyFinishEvent=nTask:makeEvent()
	self._typeFn=false@OrFalse(clazz.TypeFunction)
end

function SealFunction:meta_call(vContext:clazz.OperContext, vTermTuple:clazz.UTermTuple):Ret(clazz.RetTuples)
	const nTypeFn = self:getFnAwait()
	return nTypeFn:meta_call(vContext, vTermTuple)
end

function.pass SealFunction:getFnAwait():Ret(clazz.TypeFunction)
	error("SealFunction.getFnAwait is virtual function")
end

function SealFunction:getAssignNode()
	return self._node
end

return SealFunction
