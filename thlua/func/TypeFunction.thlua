
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const Exception = require "thlua.Exception"
const TermTuple = require "thlua.tuple.TermTuple"

const MonoFunction = require "thlua.func.MonoFunction"
const class = require "thlua.class"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const TypeFunction = class@<clazz.TypeFunction, false>(MonoFunction)

function.open TypeFunction:ctor(vManager:clazz.TypeManager, vNode:clazz.IAstNode,
	vParTuple:clazz.UTypeTuple, vRetTuples:OrFalse(clazz.RetTuples)
)
	self._node=vNode
	self._buildingRetTuples=vRetTuples
	self._parTuple=vParTuple
	self._retTuples=vRetTuples
end

function TypeFunction:Dots(vType:clazz.UAllType):Ret(clazz.TypeFunction)
	assert(not self._retTuples, "fn building is finish, can't call Dots")
	local nParTuple = self._parTuple
	if TypeTupleDots.is(nParTuple) then
		error("use Dots but tuple has dots")
	end
	self._parTuple = nParTuple:Dots(vType)
	return self
end

function TypeFunction:RetDots(vFirst:clazz.UAllType, ...:clazz.UAllType):Ret(clazz.TypeFunction)
	-- TODO check ... is type
	assert(not self._retTuples, "fn building is finish, can't call RetDots")
	const nTypeList:List(clazz.UAllType) = {vFirst, ...}
	const nLen = #nTypeList
	assert(nLen > 0, "RetDots must take at least 1 value")
	const nDotsType = nTypeList[nLen]!
	nTypeList[#nTypeList] = nil
	const nTypeTuple = self._manager:TypeTuple(self._node, table.unpack(nTypeList)):Dots(nDotsType)
	local nPreRetTuples = self._buildingRetTuples
	if not nPreRetTuples then
		nPreRetTuples = self._manager:SingleRetTuples(nTypeTuple)
	else
		nPreRetTuples = self._manager:retConcat(self._node, nPreRetTuples, nTypeTuple)
	end
	self._buildingRetTuples = nPreRetTuples
	return self
end

function TypeFunction:Ret(...:clazz.UAllType):Ret(clazz.TypeFunction)
	assert(not self._retTuples, "fn building is finish, can't call Ret")
	local nTypeTuple = self._manager:TypeTuple(self._node, ...)
	local nPreRetTuples = self._buildingRetTuples
	if not nPreRetTuples then
		nPreRetTuples = self._manager:SingleRetTuples(nTypeTuple)
	else
		nPreRetTuples = self._manager:retConcat(self._node, nPreRetTuples, nTypeTuple)
	end
	self._buildingRetTuples = nPreRetTuples
	return self
end

function TypeFunction:finish():Ret(clazz.TypeFunction)
	self:_buildRetTuples()
	return self
end

function TypeFunction:_buildRetTuples():Ret(clazz.RetTuples)
	local nRetTuples = self._retTuples
	if not nRetTuples then
		nRetTuples = self._buildingRetTuples or self._manager:VoidRetTuples()
		self._retTuples = nRetTuples
	end
	return nRetTuples
end

function TypeFunction:native_type()
	return self._manager:Literal("function")
end

function TypeFunction:detailString(vToStringCache, vVerbose)
	const nRetTuples = self:_buildRetTuples()
	local nCache = vToStringCache[self]
	if nCache then
		return nCache
	end
	vToStringCache[self] = "fn-..."
	const nResult = "fn-" .. self._parTuple:detailString(vToStringCache, vVerbose)..
									"->"..nRetTuples:detailString(vToStringCache, vVerbose)
	vToStringCache[self] = nResult
	return nResult
end

function TypeFunction:meta_call(vContext, vTermTuple)
	const nRetTuples = self:_buildRetTuples()
	const nTypeTuple = self._parTuple
	vContext:matchToParHintStruct(vContext:getNode(), vTermTuple, nTypeTuple:makeParHintStruct())
	return nRetTuples
end

function TypeFunction:assumeIntersectAtom(vAssumeSet, vType)
	const nLeftRetFirst = self:_buildRetTuples():getFirstType()
	if vType == self then
		return self
	elseif vType:assumeIncludeAtom(nil, self) then
		return self
	elseif self:assumeIncludeAtom(nil, vType) then
		return vType
	else
		return false
	end
end

function TypeFunction:assumeIncludeFn(vAssumeSet:Dict(Integer, Boolean), vRight:clazz.TypeFunction):Ret(Boolean)
	local nLeftRetTuples = self:_buildRetTuples()
	local nRightRetTuples = vRight:_buildRetTuples()
	if not vRight:getParTuple():assumeIncludeTuple(vAssumeSet, self._parTuple) then
		return false
	end
	if not nLeftRetTuples:assumeIncludeTuples(vAssumeSet, nRightRetTuples) then
		return false
	end
	return true
end

function TypeFunction:assumeIncludeAtom(vAssumeSet, vRight)
	if self == vRight then
		return self
	end
	if not TypeFunction.is(vRight) then
		return false
	end
	const nMgr = self._manager
	const nPair = self._manager:makePair(self, vRight)
	if not vAssumeSet then
		return self:assumeIncludeFn({[nPair]=true}, vRight) and self
	end
	const nAssumeResult = vAssumeSet[nPair]
	if nAssumeResult ~= nil then
		return nAssumeResult and self
	end
	vAssumeSet[nPair] = true
	local nAssumeInclude = self:assumeIncludeFn(vAssumeSet, vRight)
	if not nAssumeInclude then
		vAssumeSet[nPair] = false
		return false
	else
		return self
	end
end

function TypeFunction:getParTuple():Ret(clazz.UTypeTuple)
	self:_buildRetTuples()
	return self._parTuple
end

function TypeFunction:getRetTuples():Ret(clazz.RetTuples)
	return self:_buildRetTuples()
end

function TypeFunction:fnPartType()
	return self
end

function TypeFunction:mayRecursive()
	return true
end

function TypeFunction:isSingleton()
	return false
end

function TypeFunction:getFnAwait():Ret(clazz.TypeFunction)
	return self
end

return TypeFunction
