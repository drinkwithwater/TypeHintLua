
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local AtomTypeClass = require "thlua.type.AtomTypeClass"
local TypeTupleDots = require "thlua.tuple.TypeTupleDots"
local Exception = require "thlua.Exception"

local TypeFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function TypeFunction.new(vManager:class.TypeManager,
	vArgTuple:class.UTypeTuple,
	vRetTuples:Union(False, class.RetTuples),
	vMember:Boolean)::RetClass(class.TypeFunction, class.IAtomType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_buildingRetTuples=vRetTuples,
		_retTuples=vRetTuples,
		_argTuple=vArgTuple,
		_member=vMember,
		id=vManager:genTypeId(),
		bits=TYPE_BITS.FUNCTION,
	}, TypeFunction)
	return self
end

function TypeFunction:Dots(vType:class.UAllType)::Ret(class.TypeFunction)
	assert(not self._retTuples, "fn building is finish, can't call Dots")
	local nArgTuple = self._argTuple
	if TypeTupleDots.is(nArgTuple) then
		error("use Dots but tuple has dots")
	end
	self._argTuple = nArgTuple:Dots(vType)
	return self
end

function TypeFunction:Ret(...:Truth)::Ret(class.TypeFunction)
	assert(not self._retTuples, "fn building is finish, can't call Ret")
	local nTypeTuple = self._manager:Tuple(...)
	local nPreRetTuples = self._buildingRetTuples
	if not nPreRetTuples then
		nPreRetTuples = self._manager:SingleRetTuples(nTypeTuple)
	else
		nPreRetTuples = nPreRetTuples:Add(nTypeTuple)
	end
	self._buildingRetTuples = nPreRetTuples
	return self
end

function TypeFunction:finish()::Ret(class.TypeFunction)
	self:_buildRetTuples()
	return self
end

function TypeFunction:_buildRetTuples()::Ret(class.RetTuples)
	local nRetTuples = self._retTuples
	if not nRetTuples then
		nRetTuples = self._buildingRetTuples or self._manager:VoidRetTuples()
		self._retTuples = nRetTuples
	end
	return nRetTuples
end

function TypeFunction:isMember()::Ret(Boolean)
	return self._member
end

function TypeFunction:isNative()::Ret(Boolean)
	return false
end

function TypeFunction:detailString(v)
	return (self._member and "mfn-" or "fn-") ..
		self._argTuple:detailString(v).."->"..tostring(self._retTuples)
end

function TypeFunction:meta_call(vContext, vTypeTuple)
	local nRetTuples = self:_buildRetTuples()
	if not vTypeTuple:castOrIn(vContext, self._argTuple) then
		vContext:error("args error when call", self._argTuple, vTypeTuple)
	end
	return nRetTuples
end

function TypeFunction:_intersectOneNotRefer(vType)
	self:_buildRetTuples()
	if vType == self then
		return self
	elseif vType:containAtom(self) then
		return self
	elseif self:containAtom(vType) then
		return vType
	else
		return false
	end
end

function TypeFunction:assumeContainAtom(vAssumeSet, vRight)
	local nLeftRetTuples = self:_buildRetTuples()
	if TypeFunction.is(vRight) then
		local nRightRetTuples = vRight:_buildRetTuples()
		if not vRight._argTuple:tupleContainAssume(vAssumeSet, self._argTuple) then
			return false
		end
		if not nLeftRetTuples:tuplesContainAssume(vAssumeSet, nRightRetTuples) then
			return false
		end
		return self
	else
		return false
	end
end

function TypeFunction:getArgTuple()::Ret(class.UTypeTuple)
	self:_buildRetTuples()
	return self._argTuple
end

function TypeFunction:getRetTuples()::Ret(class.RetTuples)
	return self:_buildRetTuples()
end

function TypeFunction:isSingleton()
	return false
end

function TypeFunction.is(vType)::isguard(class.TypeFunction)
	return getmetatable(vType) == TypeFunction
end

return TypeFunction
