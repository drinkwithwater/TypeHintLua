
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local AtomTypeClass = require "thlua.type.AtomTypeClass"
local TypeTupleDots = require "thlua.tuple.TypeTupleDots"
local Exception = require "thlua.Exception"

local TypeFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function TypeFunction.new(vManager:class.TypeManager,
	vArgTuple:class.UTypeTuple,
	vRetTuples:class.RetTuples,
	vMember:Boolean)::RetClass(class.TypeFunction, class.IAtomType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_argTuple=vArgTuple,
		_retTuples=vRetTuples,
		_member=vMember,
		_structSign=false,
		id=vManager:genTypeId(),
		bits=TYPE_BITS.FUNCTION,
	}, TypeFunction)
	return self
end

function TypeFunction:Dots(vType:class.UAllType)::Ret(class.TypeFunction)
	local nArgTuple = self._argTuple
	if TypeTupleDots.is(nArgTuple) then
		error("use dots but tuple has dots")
		return self
	end
	if self._member then
		return self._manager:MemberFunction(nArgTuple:Dots(vType), self._retTuples)
	else
		return self._manager:Function(nArgTuple:Dots(vType), self._retTuples)
	end
end

function TypeFunction:isMember()::Ret(Boolean)
	return self._member
end

function TypeFunction:isNative()::Ret(Boolean)
	return false
end

function TypeFunction:Ret(...:Truth)::Ret(class.TypeFunction)
	local nTypeTuple = self._manager:Tuple(...)
	local nRetTuples = self._retTuples:Add(nTypeTuple)
	if self._member then
		return self._manager:MemberFunction(self._argTuple, nRetTuples)
	else
		return self._manager:Function(self._argTuple, nRetTuples)
	end
end

function TypeFunction:detailString(v)
	return (self._member and "mfn-" or "fn-") ..
		self._argTuple:detailString(v).."->"..self._retTuples:detailString(v)
end

function TypeFunction:meta_call(vContext, vTypeTuple)
	if not vTypeTuple:castOrIn(vContext, self._argTuple) then
		vContext:error("args error when call", self._argTuple, vTypeTuple)
	end
	return self._retTuples
end

function TypeFunction:_intersectOneNotRefer(vType)
	if vType == self then
		return self
	elseif vType:_containOneNotRefer(self) then
		return self
	elseif self:_containOneNotRefer(vType) then
		return vType
	else
		return false
	end
end

function TypeFunction:_containOneNotRefer(vRight)
	if TypeFunction.is(vRight) then
		if not vRight._argTuple:containTuple(self._argTuple) then
			return false
		end
		if not self._retTuples:containTuples(vRight._retTuples) then
			return false
		end
		return self
	else
		return false
	end
end

function TypeFunction:getArgTuple()::Ret(class.UTypeTuple)
	return self._argTuple
end

function TypeFunction:getRetTuples()::Ret(class.RetTuples)
	return self._retTuples
end

function TypeFunction:structSign()
	local nSign = self._structSign
	if not nSign then
		local l:List(String) = {
			self._member and "mfn" or "fn",
			self._argTuple:structSign(),
			"->",
			self._retTuples:structSign(),
		}
		nSign = table.concat(l)
		self._structSign = nSign
	end
	return nSign
end

function TypeFunction:isSingleton()
	return false
end

function TypeFunction.is(vType)::isguard(class.TypeFunction)
	return getmetatable(vType) == TypeFunction
end

return TypeFunction
