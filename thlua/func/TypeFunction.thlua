
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local AtomTypeClass = require "thlua.type.AtomTypeClass"
local Exception = require "thlua.Exception"

local TypeFunction = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function TypeFunction.new(vManager:class.TypeManager, vArgTuple:class.TypeTuple, vMember:Boolean)::RetClass(class.TypeFunction, class.IAtomType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_preRetTuples=false,
		_argTuple=vArgTuple,
		_retTuples=false,
		_member=vMember,
		id=0,
		bits=TYPE_BITS.FUNCTION,
	}, TypeFunction)
	return self
end

function TypeFunction:initByRetTuples(vRetTuples)
	assert(not self._retTuples, "type-function has been locked when init")
	self._retTuples = vRetTuples
end

function TypeFunction:Dots(vType)
	assert(not self._retTuples, "type-function has been locked when call Dots")
	self._argTuple = self._argTuple:Dots(vType)
	return self
end

function TypeFunction:Ret(...:Truth)
	assert(not self._retTuples, "type-function has been locked when call Ret")
	local nTypeTuple = self._manager:Tuple(...)
	local nRetTuples = self._preRetTuples
	if not nRetTuples then
		nRetTuples = self._manager:SingleRetTuples(nTypeTuple)
	else
		nRetTuples = nRetTuples:Add(nTypeTuple)
	end
	self._preRetTuples = nRetTuples
	return self
end

function TypeFunction:preBuild()
	if not self._retTuples then
		self._retTuples = self._preRetTuples or self._manager:VoidRetTuples()
	end
end

function TypeFunction:postBuild()
end

function TypeFunction:isMember()::Ret(Boolean)
	return self._member
end

function TypeFunction:isNative()::Ret(Boolean)
	return false
end

function TypeFunction:detailString(v)
	return (self._member and "mfn-" or "fn-") ..
		self._argTuple:detailString(v).."->"..self._retTuples:detailString(v)
end

function TypeFunction:meta_call(vContext, vTypeTuple)
	if not vTypeTuple:castOrIn(vContext, self._argTuple) then
		vContext:error("args error when call", self._argTuple, vTypeTuple)
	end
	return self._retTuples
end

function TypeFunction:_intersectOneNotRefer(vType)
	if vType == self then
		return self
	elseif vType:_containOneNotRefer(self) then
		return self
	elseif self:_containOneNotRefer(vType) then
		return vType
	else
		return false
	end
end

function TypeFunction:_containOneNotRefer(vRight)
	if TypeFunction.is(vRight) then
		if not vRight._argTuple:containTuple(self._argTuple) then
			return false
		end
		if not self._retTuples:containTuples(vRight._retTuples) then
			return false
		end
		return self
	else
		return false
	end
end

function TypeFunction:getArgTuple()
	return self._argTuple
end

function TypeFunction:getRetTuples()
	return self._retTuples
end

function TypeFunction:structSign()
	local nSign = self._structSign
	if not nSign then
		local l = {
			self._member and "mfn" or "fn",
			self._argTuple:structSign(),
			"->",
			self._retTuples:structSign(),
		}
		nSign = table.concat(l)
		self._structSign = nSign
	end
	return nSign
end

function TypeFunction:isSingleton()
	return false
end

function TypeFunction.is(vType)::isguard(class.TypeFunction)
	return getmetatable(vType) == TypeFunction
end

return TypeFunction
