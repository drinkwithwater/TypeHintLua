return [[

const math = {}

function.pass math.abs(x:Number):Ret(Number)
end

function.pass math.acos(x:Number):Ret(Number)
end

function.pass math.asin(x:Number):Ret(Number)
end

function.pass math.atan(y:Number, x:OrNil(Number)):Ret(Number)
end

function.pass math.ceil(x:Number):Ret(Integer)
end

function.pass math.cos(x:Number):Ret(Number)
end

function.pass math.deg(x:Number):Ret(Number)
end

function.pass math.exp(x:Number):Ret(Number)
end

function.pass math.floor(x:Number):Ret(Integer)
end

function.pass math.fmod(x:Number, y:Number):Ret(Number)
end

math.huge = (1.0/0.0) @ Number

function.pass math.log(x:Number, base:OrNil(Number)):Ret(Number)
    base = base or math.exp(1)
end

function.pass math.max(x:Number, ...:Number):Ret(Number)
end

math.maxinteger = 9223372036854775807 @ Integer

function.pass math.min(x:Number, ...:Number):Ret(Number)
end

math.mininteger = (-9223372036854775808) @ Integer

function.pass math.modf(x:Number):Ret(Integer, Number)
end

math.pi = 3.14159265358979323846 @ Number

function.pass math.rad(x:Number):Ret(Number)
end

function.pass math.random(m:OrNil(Integer), n:OrNil(Integer)):Ret(Number)
end

function.pass math.randomseed(x:OrNil(Integer), y:OrNil(Integer))
end

function.pass math.sin(x:Number):Ret(Number)
end

function.pass math.sqrt(x:Number):Ret(Number)
end

function.pass math.tan(x:Number):Ret(Number)
end

function.pass math.tointeger(x:Any):Ret(OrNil(Integer))
end

function.pass math.type(x:Any):Ret(OrNil("float", "integer"))
    -- use guard?
end

function.pass math.ult(m:Integer, n:Integer):Ret(Boolean)
end

_ENV.math = math

]]