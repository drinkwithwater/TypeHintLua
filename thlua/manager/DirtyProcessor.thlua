
const Exception = require "thlua.Exception"
const SpaceValue = require "thlua.space.SpaceValue"
const NameReference = require "thlua.space.NameReference"
const AsyncTypeCom = require "thlua.space.AsyncTypeCom"
const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const BaseUnionType = require "thlua.type.union.BaseUnionType"
const class = require "thlua.class"
const type = type

const DirtyProcessor = {}

DirtyProcessor.__index = DirtyProcessor

(@do
	let.clazz = import($class).clazz
end)

function:class(clazz.DirtyProcessor) DirtyProcessor.new(vTypeManager:clazz.TypeManager)
    const self = setmetatable({.class
        _manager = vTypeManager,
		_runtime = vTypeManager:getRuntime()
    }, DirtyProcessor)
    return self
end

function DirtyProcessor:easyToMustType(vNode:clazz.IBaseNode, vData:clazz.USpaceAny):Ret(clazz.UMustType)
	local t = type(vData)
	if t == "table" then
		if AsyncTypeCom.is(vData) or BaseAtomType.is(vData) or BaseUnionType.is(vData) then
			return vData
		else
			const nRefer = SpaceValue.checkRefer(vData)
			if nRefer then
				return nRefer:waitAsyncTypeCom(vNode)
			else
				if NameReference.is(vData) then
					return vData:waitAsyncTypeCom(vNode)
				else
					error(vNode:toExc("to type failed"))
				end
			end
		end
	elseif t == "number" or t == "string" or t == "boolean"then
		return self._manager:Literal(vData @> Union(Number, String, Boolean))
	elseif t == "nil" then
		error(vNode:toExc("can't trans nil into type in hint space"))
	else
		error(vNode:toExc("can't trans this value into type in hint space"))
	end
end

return DirtyProcessor