
const Exception = require "thlua.Exception"
const Reference = require "thlua.refer.Reference"
const AsyncUnion = require "thlua.refer.AsyncUnion"
const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const BaseUnionType = require "thlua.type.union.BaseUnionType"

const DirtyProcessor = {}

DirtyProcessor.__index = DirtyProcessor

(@do
	let.clazz = import("thlua.class").clazz
end)

function:class(clazz.DirtyProcessor) DirtyProcessor.new(vTypeManager:clazz.TypeManager)
    const self = setmetatable({.class
        _manager = vTypeManager,
		_runtime = vTypeManager:getRuntime()
    }, DirtyProcessor)
    return self
end

function DirtyProcessor:makeDirtyException(vNode:clazz.IBaseNode, vMsg:String):Ret(clazz.Exception)
	return Exception.new(vMsg, vNode)
end

function DirtyProcessor:easyToAllType(vNode:clazz.IBaseNode, vData:Any):Ret(clazz.UAllType)
	const nOkay, nType = self:peasyToAllType(vData)
	if nOkay then
		return nType
	else
		error(self:makeDirtyException(vNode, nType))
	end
end

function DirtyProcessor:easyToAllTypeList(vNode:clazz.IBaseNode, ...:Any):Ret(List(clazz.UAllType))
	const l:List(Any) = {...}
	for i=1,#l do
		l[i] = self:easyToAllType(vNode, l[i])
	end
	return l @? List(clazz.UAllType)
end

function DirtyProcessor:peasyToAllType(vData:Any):Ret(False, String):Ret(True, clazz.UAllType)
	local t = type(vData)
	if t == "table" then
		if Reference.is(vData) or AsyncUnion.is(vData) or BaseAtomType.is(vData) or BaseUnionType.is(vData) then
			return true, vData
		else
			return false, "to type failed"
		end
	elseif t == "number" or t == "string" or t == "boolean"then
		return true, self._manager:Literal(vData @> Union(Number, String, Boolean))
	else
		return false, "easyToAllType("..t..") invalid"
	end
end

function DirtyProcessor:peasyToMustType(vData:Any):Ret(False, String):Ret(True, clazz.UMustType)
	const ok, ret = self:peasyToAllType(vData)
	if ok then
		if Reference.is(ret) then
			return true, ret:waitTypeCom()
		else
			return true, ret
		end
	else
		return false, ret
	end
end

function DirtyProcessor:easyToMustType(vNode:clazz.IBaseNode, vData:Any):Ret(clazz.UMustType)
	const nOkay, nType = self:peasyToMustType(vData)
	if nOkay then
		return nType
	else
		error(self:makeDirtyException(vNode, nType))
	end
end

return DirtyProcessor