
const Exception = require "thlua.Exception"
const SpaceValue = require "thlua.space.SpaceValue"
const Reference = require "thlua.space.Reference"
const AsyncTypeCom = require "thlua.space.AsyncTypeCom"
const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const BaseUnionType = require "thlua.type.union.BaseUnionType"
const class = require "thlua.class"

const DirtyProcessor = {}

DirtyProcessor.__index = DirtyProcessor

(@do
	let.clazz = import($class).clazz
end)

function:class(clazz.DirtyProcessor) DirtyProcessor.new(vTypeManager:clazz.TypeManager)
    const self = setmetatable({.class
        _manager = vTypeManager,
		_runtime = vTypeManager:getRuntime()
    }, DirtyProcessor)
    return self
end

function DirtyProcessor:peasyToMustType(vNode:clazz.IBaseNode, vData:clazz.USpaceAny):Ret(False, String):Ret(True, clazz.UMustType)
	local t = type(vData)
	if t == "table" then
		if AsyncTypeCom.is(vData) or BaseAtomType.is(vData) or BaseUnionType.is(vData) then
			return true, vData
		else
			const nRefer = SpaceValue.checkRefer(vData)
			if nRefer then
				return true, nRefer:waitAsyncTypeCom(vNode)
			else
				if Reference.is(vData) then
					return true, vData:waitAsyncTypeCom(vNode)
				else
					return false, "to type failed"
				end
			end
		end
	elseif t == "number" or t == "string" or t == "boolean"then
		return true, self._manager:Literal(vData @> Union(Number, String, Boolean))
	elseif t == "nil" then
		return false, "can't trans nil into type in hint space"
	else
		return false, "can't trans this value into type in hint space"
	end
end

function DirtyProcessor:easyToMustType(vNode:clazz.IBaseNode, vData:clazz.USpaceAny):Ret(clazz.UMustType)
	const nOkay, nType = self:peasyToMustType(vNode, vData)
	if nOkay then
		return nType
	else
		error(vNode:toExc(nType))
	end
end

return DirtyProcessor