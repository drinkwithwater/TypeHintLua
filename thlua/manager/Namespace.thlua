
const Exception = require "thlua.Exception"
const Reference = require "thlua.refer.Reference"
const StringLiteral = require "thlua.type.StringLiteral"
const Node = require "thlua.code.Node"
const Namespace = {}
Namespace.__tostring=function(self):Ret(String)
	return (self:isLetSpace() and "letspace-" or "namespace-") .. tostring(self._node).."|"..tostring(self._key or "!keynotset")
end
Namespace.__index=Namespace

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	clazz.SpaceTable = Interface {
		[clazz.UAllType]=clazz.TypeReference,
	}
	let.StringToRefer = Dict(clazz.IAtomType, Union(clazz.TypeReference, clazz.SpaceTable))
end)

const function throw(vMsg:String)
	const nNode = Node.getDebugNode(4)
	error(Exception.new(vMsg, nNode))
end

function:class(clazz.Namespace) Namespace.new(vManager:clazz.TypeManager, vNode:clazz.IAstNode, vIndexTable:OrNil(Truth)):impl(clazz.ICompletion)
	const self = setmetatable({.class
		_manager=vManager,
		_key2type=(vIndexTable and setmetatable({}, {__index=vIndexTable}) or {})@StringToRefer,
		_closed=false@Boolean,
		_node=vNode,
		_key=false@Union(False, String),
		localExport=nil@!clazz.SpaceTable,
		globalExport=nil@!clazz.SpaceTable,
	}, Namespace)
	self.localExport=setmetatable({}, {
		__index=function(_:Truth,k:Any):Ret(Union(clazz.TypeReference, clazz.SpaceTable))
			const nKeyType = self:assertSpaceKeyType(k)
			const nNode = Node.getDebugNode(3)
			local rawgetV = rawget(self._key2type, nKeyType)
			if rawgetV ~= nil then
				return rawgetV
			end
			const getV = self._key2type[nKeyType]
			if getV ~= nil then
				throw("let can only get symbol in current level key="..tostring(k))
			end
			if self._closed then
				throw("namespace closed, can't create key="..tostring(k))
			end
			const refer = self._manager:Reference(tostring(nKeyType))
			refer:pushReferNode(nNode)
			self._key2type[nKeyType] = refer
			return refer
		end,
		__newindex=function(_:Truth,k:Any,newV:Any)
			const nKeyType = self:assertSpaceKeyType(k)
			if self._closed then
				throw("namespace closed, can't create key="..tostring(k))
			end
			const getV = self._key2type[nKeyType]
			local rawgetV = rawget(self._key2type, nKeyType)
			if getV ~= nil and rawgetV == nil then
				throw("let shadow set : key="..tostring(nKeyType))
			end
			if rawgetV ~= nil then
				-- for recursive indexing reference
				if Reference.is(rawgetV) then
					rawgetV:setAssignAsync(Node.getDebugNode(3), function() return newV end)
				else
					throw("assign conflict: key="..tostring(nKeyType))
				end
			else
				const namespace = Namespace.fromExport(newV)
				if namespace then
					namespace:trySetKey(tostring(nKeyType))
					self._key2type[nKeyType] = newV @? clazz.SpaceTable
				else
					const refer = self._manager:Reference(tostring(nKeyType))
					refer:setAssignAsync(Node.getDebugNode(3), function() return newV end)
					self._key2type[nKeyType] = refer
				end
			end
		end,
		__tostring=function(_:Truth):Ret(String)
			return tostring(self).."->localExport"
		end,
		__self=self,
	}) @? clazz.SpaceTable
	self.globalExport=setmetatable({}, {
		__index=function(_:Truth,k:Any):Ret(Union(clazz.TypeReference, clazz.SpaceTable))
			const nKeyType = self:assertSpaceKeyType(k)
			local v = self._key2type[nKeyType]
			if v ~= nil then
				return v
			end
			throw("key with empty value, key="..tostring(nKeyType))
		end,
		__newindex=function(t:Truth,k:Any,v:Any)
			throw("global can't assign")
		end,
		__tostring=function(t:Truth):Ret(String)
			return tostring(self).."->globalExport"
		end,
		__self=self,
	}) @? clazz.SpaceTable
	return self
end

function Namespace:assertSpaceKeyType(vKey:Any):Ret(clazz.IAtomType)
	const nNode = Node.getDebugNode(5)
	const nOkay, nType = self._manager:peasyToType(vKey)
	if not nOkay then
		error(Exception.new(nType, nNode))
	end
	local nFinalKey = nType
	if Reference.is(nFinalKey) then
		nFinalKey = nFinalKey:checkAtomUnion()
	end
	if not nFinalKey:isUnion() then
		return nFinalKey
	else
		error("namespace's key can't be union type")
	end
end

function Namespace:trySetKey(vKey:String)
	if not self._key then
		self._key = vKey
	end
end

function.pass Namespace:isLetSpace():Ret(Boolean)
	return getmetatable(self._key2type) and true or false
end

function.pass Namespace.fromExport(t:Any):Ret(OrFalse(clazz.Namespace))
	local nMeta = getmetatable(t)
	if type(nMeta) == "table" then
		local self = rawget(nMeta, "__self")
		if getmetatable(self) == Namespace then
			return self
		end
	end
	return false
end

function Namespace:close()
	self._closed=true
end

function Namespace:check()
	for k,v in pairs(self._key2type) do
		if Reference.is(v) then
			if not v:waitTypeCom():getResultType() then
				print(self, v)
			else
				-- print(self, v)
			end
		end
	end
end

function Namespace:getKeyToType():Ret(StringToRefer)
	return self._key2type
end

function Namespace:putCompletion(vCompletion)
	for k,v in pairs(self._key2type) do
		if StringLiteral.is(k) then
			vCompletion:putPair(k:getLiteral(), v)
		end
	end
end

return Namespace
