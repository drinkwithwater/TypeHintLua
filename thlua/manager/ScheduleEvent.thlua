
const ScheduleEvent = {}
ScheduleEvent.__index = ScheduleEvent

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.ScheduleEvent) ScheduleEvent.new(vManager:clazz.ScheduleManager, vThread:OrFalse(Thread))
	return setmetatable({.class
		_scheduleManager=vManager,
		_selfCo=vThread,
		_coToSid={}@OrFalse(Dict(Thread, Integer)),
	}, ScheduleEvent)
end

function ScheduleEvent:wait()
	const nCoToSid = self._coToSid
	if nCoToSid then
		const nManager = self._scheduleManager
		const nCurCo = coroutine.running()
		nCoToSid[nCurCo] = 1
		nManager:getTask(nCurCo):waitEvent(self)
		-- nManager:coWait(nCurCo, nSessionId, self._selfCo)
	end
end

function ScheduleEvent:wakeup()
	const nCoToSid = self._coToSid
	if nCoToSid then
		self._coToSid = false
		const nManager = self._scheduleManager
		for co, sid in pairs(nCoToSid) do
			nManager:getTask(co):wakeupEvent(self)
			nManager:coWakeup(co)
		end
	end
end

return ScheduleEvent
