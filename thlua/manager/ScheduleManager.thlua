
const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const Exception = require "thlua.Exception"
const class = require "thlua.class"

const chrono = (function()
	const ok, t = pcall(require, "chrono")
	return ok and t or {
		now=function():Ret(Integer)
			return 0
		end,
		sub=function():Ret(Integer)
			return 0
		end,
	}
end)()

const ScheduleTask = require "thlua.manager.ScheduleTask"

(@do
	let.clazz = import($class).clazz
	let.WaitingInfo = Struct {
		waitSid = Integer,
		dependCo = Thread,
	}
	let.ProfileInfo = Struct {
		counter = Integer,
		start = OrFalse(Integer),
		accumulate = Integer,
		name = String,
	}
end)

const ScheduleManager = class@<clazz.ScheduleManager, false>()

function.open ScheduleManager:ctor(vRuntime:clazz.BaseRuntime)
	self._coToTask={} @ Dict(Thread, clazz.ScheduleTask)
	self._coToScheduleParam={}@Dict(Thread, Union(True, Fn()))
	self._coToWaitingInfo={}@Dict(Thread, WaitingInfo)
	self._sessionIdCounter=0@Integer
	self._selfCo=coroutine.running()
	self._runtime = vRuntime
	self._profileThread = false @ OrFalse(Thread)
	self._fnToProfile = {} @ Dict(AnyFunction, ProfileInfo)
	self.useProfile = false @Boolean
end

function ScheduleManager:newTask(vTaskHost:clazz.UTaskHost)
	const nTask = ScheduleTask.new(self, vTaskHost)
	self._coToTask[nTask:getSelfCo()] = nTask
	return nTask
end

function ScheduleManager:coWait(vWaitCo:Thread, vWaitSid:Integer, vDependCo:OrNil(Thread))
	assert(vWaitCo == coroutine.running(), "wait co must be current co")
	if vDependCo then
		const nWaitingTask = self._coToTask[vWaitCo]
		if not nWaitingTask then
			const nDependTask = self._coToTask[vDependCo]
			error("can only call coWait in a task, try to get:"..tostring(nDependTask))
		else
			const nDependTask = self._coToTask[vDependCo]
			if nDependTask then
				-- stack can't wait async type
				const nCurStack = nWaitingTask:getStack()
				if nCurStack then
					if not nDependTask:getStack() then
						nDependTask:errorWaitByStack(nCurStack)
					end
				end
			end
		end
		local nCurCo:Thread = vDependCo
		const nThreadList:List(Thread) = {}
		while nCurCo do
			nThreadList[#nThreadList + 1] = nCurCo
			if nCurCo == vWaitCo then
				const nNodeList:List(clazz.IBaseNode) = {}
				for _, co in pairs(nThreadList) do
					const nTask = self._coToTask[co]!
					nNodeList[#nNodeList + 1] = nTask:getNode() or nil
				end
				const nFirstNode = nNodeList[1]
				if not nFirstNode then
					error("recursive build type")
				else
					error(Exception.new("recursive build type", nFirstNode, table.unpack(nNodeList, 2)))
				end
			else
				const nNextWaitingInfo = self._coToWaitingInfo[nCurCo]
				if nNextWaitingInfo then
					nCurCo = nNextWaitingInfo.dependCo
				else
					break
				end
			end
		end
	else
		vDependCo = self._selfCo
	end
	self._coToWaitingInfo[vWaitCo] = {
		waitSid = vWaitSid,
		dependCo = vDependCo,
	}
	coroutine.yield()
end

function ScheduleManager:coWakeup(vWaitCo:Thread, vWaitSid:Integer)
	const nWaitingInfo = self._coToWaitingInfo[vWaitCo]
	if not nWaitingInfo then
		-- session is cancel
		print("session is cancel when wakeup")
		return
	elseif vWaitSid ~= nWaitingInfo.waitSid then
		print("wait sid not match when wakeup")
		return
	end
	self._coToWaitingInfo[vWaitCo] = nil
	self._coToScheduleParam[vWaitCo] = true
	const nTask = self._coToTask[coroutine.running()]
	if not nTask or nTask:getStack() then
		self:_schedule()
	end
end

function ScheduleManager:coStart(vCo:Thread, vFunc:Fn())
	self._coToScheduleParam[vCo] = vFunc
	const nTask = self._coToTask[coroutine.running()]
	if not nTask or nTask:getStack() then
		self:_schedule()
	end
end

function ScheduleManager:_schedule()
	while true do
		const nCoToParam = self._coToScheduleParam
		if not next(nCoToParam) then
			break
		else
			self._coToScheduleParam = {}@Dict(Thread, Union(True, Fn()))
			for co, param in pairs(nCoToParam) do
				assert(coroutine.resume(co, param))
			end
		end
	end
end

function ScheduleManager:genSessionId():Ret(Integer)
	local nNewId = self._sessionIdCounter + 1
	self._sessionIdCounter = nNewId
	return nNewId
end

function ScheduleManager:makeEvent(vThread:OrNil(Thread)):Ret(clazz.ScheduleEvent)
	return ScheduleEvent.new(self, vThread)
end

function ScheduleManager:getRuntime()
	return self._runtime
end

function ScheduleManager:hook(vCase:Union("call", "return", "line"), vDepth:OrNil(Integer))
	vDepth = vDepth or 3
	const f = debug.getinfo(vDepth, "f").func
	const nProfile = self._fnToProfile[f]
	if not nProfile then
		local name = ""
		do.pass
			local n = debug.getinfo(vDepth, "Sn")
			if n.what == "C" then
				name = n.name
			else
				local loc = string.format("[%s]:%s", n.short_src, n.linedefined)
				if n.namewhat ~= "" then
					name = string.format("%s (%s)", loc, n.name)
				else
					name = string.format("%s", loc)
				end
			end
		end
		self._fnToProfile[f] = {
			counter = 1,
			start = chrono.now(),
			accumulate = 0,
			name = name,
		}
	else
		if vCase == "return" then
			const nStart = nProfile.start
			if nStart then
				nProfile.accumulate = nProfile.accumulate + (chrono.now() - nStart)
				nProfile.start = false
			end
		else
			nProfile.start = chrono.now()
			nProfile.counter = nProfile.counter + 1
		end
	end
end

function ScheduleManager:dump()
	const l:List(ProfileInfo) = {}
	for k, profile in pairs(self._fnToProfile) do
		if profile.counter > 1 then
			l[#l+1] = profile
		end
	end
	table.sort(l, function(a,b)
		return a.accumulate < b.accumulate
	end)
	for _, profile in pairs(l) do
		print(profile.accumulate, profile.counter, profile.name)
	end
end

return ScheduleManager
