
const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const Exception = require "thlua.Exception"
const class = require "thlua.class"

const ScheduleTask = require "thlua.manager.ScheduleTask"

(@do
	let.clazz = import($class).clazz
	let.WaitingInfo = Struct {
		waitSid = Integer,
		dependCo = Thread,
	}
end)

const ScheduleManager = class@<clazz.ScheduleManager, false>()

function.open ScheduleManager:ctor()
	self._coToTask={} @ Dict(Thread, clazz.ScheduleTask)
	self._coToScheduleParam={}@Dict(Thread, Union(True, Fn()))
	self._coToWaitingInfo={}@Dict(Thread, WaitingInfo)
	self._sessionIdCounter=0@Integer
	self._selfCo=coroutine.running()
end

function ScheduleManager:newTask(vTaskHost:clazz.UTaskHost)
	const nTask = ScheduleTask.new(self, vTaskHost)
	self._coToTask[nTask:getSelfCo()] = nTask
	return nTask
end

function ScheduleManager:coWait(vWaitCo:Thread, vWaitSid:Integer, vDependCo:OrNil(Thread))
	assert(vWaitCo == coroutine.running(), "wait co must be current co")
	if vDependCo then
		const nWaitingTask = self._coToTask[vWaitCo]
		if not nWaitingTask then
			const nDependTask = self._coToTask[vDependCo]
			error("can only call coWait in a task, try to get:"..tostring(nDependTask))
		else
			const nDependTask = self._coToTask[vDependCo]
			if nDependTask then
				if not nWaitingTask:canWaitType() then
					if not nDependTask:getStack() then
						error(nDependTask:makeWaitExc())
					end
				end
			end
		end
		local nCurCo:Thread = vDependCo
		while nCurCo do
			if nCurCo == vWaitCo then
				error("recursive build type:"..tostring(self._coToTask[nCurCo]))
			else
				const nNextWaitingInfo = self._coToWaitingInfo[nCurCo]
				if nNextWaitingInfo then
					nCurCo = nNextWaitingInfo.dependCo
				else
					break
				end
			end
		end
	else
		vDependCo = self._selfCo
	end
	self._coToWaitingInfo[vWaitCo] = {
		waitSid = vWaitSid,
		dependCo = vDependCo,
	}
	coroutine.yield()
end

function ScheduleManager:coWakeup(vWaitCo:Thread, vWaitSid:Integer)
	const nWaitingInfo = self._coToWaitingInfo[vWaitCo]
	if not nWaitingInfo then
		-- session is cancel
		print("session is cancel when wakeup")
		return
	elseif vWaitSid ~= nWaitingInfo.waitSid then
		print("wait sid not match when wakeup")
		return
	end
	self._coToWaitingInfo[vWaitCo] = nil
	self._coToScheduleParam[vWaitCo] = true
	const nTask = self._coToTask[coroutine.running()]
	if not nTask or nTask:getStack() then
		self:_schedule()
	end
end

function ScheduleManager:coStart(vCo:Thread, vFunc:Fn())
	self._coToScheduleParam[vCo] = vFunc
	const nTask = self._coToTask[coroutine.running()]
	if not nTask or nTask:getStack() then
		self:_schedule()
	end
end

function ScheduleManager:_schedule()
	while true do
		const nCoToParam = self._coToScheduleParam
		if not next(nCoToParam) then
			break
		else
			self._coToScheduleParam = {}@Dict(Thread, Union(True, Fn()))
			for co, param in pairs(nCoToParam) do
				assert(coroutine.resume(co, param))
			end
		end
	end
end

function ScheduleManager:genSessionId():Ret(Integer)
	local nNewId = self._sessionIdCounter + 1
	self._sessionIdCounter = nNewId
	return nNewId
end

function ScheduleManager:makeEvent(vThread:OrNil(Thread)):Ret(clazz.ScheduleEvent)
	return ScheduleEvent.new(self, vThread)
end

return ScheduleManager
