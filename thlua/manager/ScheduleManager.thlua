
const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const Exception = require "thlua.Exception"
const class = require "thlua.class"

const ScheduleTask = require "thlua.manager.ScheduleTask"

(@do
	let.clazz = import($class).clazz
	let.ProfileInfo = Struct {
		counter = Integer,
		start = OrFalse(Integer),
		accumulate = Integer,
		name = String,
	}
end)

const ScheduleManager = class@<clazz.ScheduleManager, false>()

function.open ScheduleManager:ctor(vRuntime:clazz.BaseRuntime)
	self._coToTask={} @ Dict(Thread, clazz.ScheduleTask)
	self._coToScheduleParam={}@Dict(Thread, Union(True, Fn()))
	self._selfCo=coroutine.running()
	self._runtime = vRuntime
	self._profileThread = false @ OrFalse(Thread)
	self.useProfile = false @Boolean
end

function ScheduleManager:newTask(vTaskHost:clazz.UTaskHost)
	const nTask = ScheduleTask.new(self, vTaskHost)
	self._coToTask[nTask:getSelfCo()] = nTask
	return nTask
end

function ScheduleManager:getTask(vThread:Thread):Ret(clazz.ScheduleTask)
	return self._coToTask[vThread]!
end

function ScheduleManager:coWait(vWaitCo:Thread, vWaitSid:Integer, vDependCo:OrFalse(Thread))
	assert(vWaitCo == coroutine.running(), "wait co must be current co")
	if vDependCo then
		const nWaitingTask = self._coToTask[vWaitCo]
		if not nWaitingTask then
			const nDependTask = self._coToTask[vDependCo]
			error("can only call coWait in a task, try to get:"..tostring(nDependTask))
		else
			const nDependTask = self._coToTask[vDependCo]
			if nDependTask then
				-- stack can't wait async type
				const nCurStack = nWaitingTask:getStack()
				if nCurStack then
					if not nDependTask:getStack() then
						nDependTask:errorWaitByStack(nCurStack)
					end
				end
			end
		end
		local nCurCo:Thread = vDependCo
		const nThreadList:List(Thread) = {}
		while nCurCo do
			nThreadList[#nThreadList + 1] = nCurCo
			if nCurCo == vWaitCo then
				const nNodeList:List(clazz.IBaseNode) = {}
				for _, co in pairs(nThreadList) do
					const nTask = self._coToTask[co]!
					nNodeList[#nNodeList + 1] = nTask:getNode() or nil
				end
				const nFirstNode = nNodeList[1]
				if not nFirstNode then
					error("recursive build type")
				else
					error(Exception.new("recursive build type", nFirstNode, table.unpack(nNodeList, 2)))
				end
			else
				--[[
				const nNextWaitingInfo = self._coToWaitingInfo[nCurCo]
				if nNextWaitingInfo then
					nCurCo = nNextWaitingInfo.dependCo
				else
					break
				end
				]]
			end
		end
	else
		vDependCo = self._selfCo
	end
end

function ScheduleManager:coWakeup(vWaitCo:Thread)
	self._coToScheduleParam[vWaitCo] = true
	const nTask = self._coToTask[coroutine.running()]
	if not nTask or nTask:getStack() then
		self:_schedule()
	end
end

function ScheduleManager:_schedule()
	while true do
		const nCoToParam = self._coToScheduleParam
		if not next(nCoToParam) then
			break
		else
			self._coToScheduleParam = {}@Dict(Thread, Union(True, Fn()))
			for co, param in pairs(nCoToParam) do
				assert(coroutine.resume(co, param))
			end
		end
	end
end

function ScheduleManager:makeWildEvent():Ret(clazz.ScheduleEvent)
	return ScheduleEvent.new(self, false)
end

function ScheduleManager:getRuntime()
	return self._runtime
end

function ScheduleManager:dump()
	const nFnToProfile:Dict(AnyFunction, clazz.ProfileInfo) = {}
	for k, nTask in pairs(self._coToTask) do
		for fn, profile in pairs(nTask:getFnToProfile()) do
			const nCurProfile = nFnToProfile[fn]
			if not nCurProfile then
				nFnToProfile[fn] = {
					accumulate = profile.accumulate,
					counter = profile.counter,
					name = profile.name,
					start = false,
				}
			else
				nCurProfile.accumulate = nCurProfile.accumulate + profile.accumulate
				nCurProfile.counter = nCurProfile.counter + profile.counter
			end
		end
	end
	const l:List(clazz.ProfileInfo) = {}
	for k, profile in pairs(nFnToProfile) do
		if profile.counter > 1 then
			l[#l+1] = profile
		end
	end
	table.sort(l, function(a,b)
		return a.accumulate < b.accumulate
	end)
	for _, profile in pairs(l) do
		--print(profile.accumulate, profile.counter, profile.name)
	end
end


return ScheduleManager
