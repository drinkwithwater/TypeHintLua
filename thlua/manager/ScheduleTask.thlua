
const Exception = require "thlua.Exception"

const SealStack = require "thlua.runtime.SealStack"
const Node = require "thlua.code.Node"
const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const class = require "thlua.class"

(@do
	let.clazz = import($class).clazz
	clazz.UTaskHost = Union(clazz.IBaseNode, clazz.SealStack, clazz.TypeRelation)
end)

const ScheduleTask = class@<clazz.ScheduleTask, false>()

function.open ScheduleTask:ctor(vScheduleManager:clazz.ScheduleManager, vHost:clazz.UTaskHost)
	self._scheduleManager = vScheduleManager
	self._selfCo = coroutine.create(function(vRunFn:Fn():Err(clazz.Exception))
		const ok, nExc = pcall(vRunFn)
		if not ok then
			const nHost = self._host
			const nStack = SealStack.is(nHost) and nHost
			if nStack then
				if Exception.is(nExc) then
					nStack:getRuntime():nodeError(nExc.node, nExc.msg)
				else
					nStack:getRuntime():nodeError(nStack:getNode(), tostring(nExc))
				end
			end
			if not nStack or nStack:isRoot() then
				error(nExc)
			end
		end
	end)
	self._host = vHost
end

function ScheduleTask:getSelfCo():Ret(Thread)
	return self._selfCo
end

function ScheduleTask:canWaitType()
	return not SealStack.is(self._host)
end

function ScheduleTask:runAsync(vFunc:Fn())
	self._scheduleManager:coStart(self._selfCo, vFunc)
end

function ScheduleTask:getStack():Ret(OrFalse(clazz.SealStack))
	const nHost = self._host
	return SealStack.is(nHost) and nHost
end

function ScheduleTask:makeEvent():Ret(clazz.ScheduleEvent)
	return self._scheduleManager:makeEvent(self._selfCo)
end

function ScheduleTask:makeWildEvent():Ret(clazz.ScheduleEvent)
	return self._scheduleManager:makeEvent()
end

function ScheduleTask:makeWaitExc():Ret(Union(String, clazz.Exception))
	const nHost = self._host
	if SealStack.is(nHost) then
		return nHost:getNode():toExc("waiting exception in stack")
	elseif Node.is(nHost) then
		return nHost:toExc("waiting exception in type")
	else
		return "waiting exception when type relation"
	end
end

return ScheduleTask
