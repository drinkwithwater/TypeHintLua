
const Exception = require "thlua.Exception"

const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ScheduleTask = class@<clazz.ScheduleTask, false>()

-- function.open ScheduleTask:ctor(vScheduleManager:clazz.ScheduleManager, vStack:OrNil(clazz.IBaseNode, clazz.NameLocation, clazz.SealStack))
function.open ScheduleTask:ctor(vScheduleManager:clazz.ScheduleManager, vStack:OrNil(clazz.SealStack))
	self._scheduleManager = vScheduleManager
	self._selfCo = coroutine.create(function(vRunFn:Fn():Err(clazz.Exception))
		const ok, nExc = pcall(vRunFn)
		if not ok then
			const nStack = self:getStack()
			if nStack then
				if Exception.is(nExc) then
					nStack:getRuntime():nodeError(nExc.node, nExc.msg)
				else
					nStack:getRuntime():nodeError(nStack:getNode(), tostring(nExc))
				end
			end
			if not nStack or nStack:isRoot() then
				error(nExc)
			end
		end
	end)
	self._stack = vStack or false
end

function ScheduleTask:getSelfCo():Ret(Thread)
	return self._selfCo
end

function ScheduleTask:canWaitType()
	return not self._stack
end

function ScheduleTask:runAsync(vFunc:Fn())
	self._scheduleManager:coStart(self._selfCo, vFunc)
end

function ScheduleTask:getStack():Ret(OrFalse(clazz.SealStack))
	return self._stack
end

function ScheduleTask:makeEvent():Ret(clazz.ScheduleEvent)
	return self._scheduleManager:makeEvent(self._selfCo)
end

function ScheduleTask:makeWildEvent():Ret(clazz.ScheduleEvent)
	return self._scheduleManager:makeEvent()
end

return ScheduleTask
