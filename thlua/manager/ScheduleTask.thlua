
const Exception = require "thlua.Exception"

const SealStack = require "thlua.runtime.SealStack"
const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ScheduleTask = class@<clazz.ScheduleTask, false>()

function ScheduleTask:__tostring()
	const nTarget = self._target
	return tostring(nTarget)
end

function.open ScheduleTask:ctor(vScheduleManager:clazz.ScheduleManager, vTarget:OrNil(clazz.SealStack, clazz.Reference))
	self._scheduleManager = vScheduleManager
	self._selfCo = coroutine.create(function(vRunFn:Fn():Err(clazz.Exception))
		const ok, nExc = pcall(vRunFn)
		if not ok then
			const nStack = self:getStack()
			if nStack then
				if Exception.is(nExc) then
					nStack:getRuntime():nodeError(nExc.node, nExc.msg)
				else
					nStack:getRuntime():nodeError(nStack:getNode(), tostring(nExc))
				end
			end
			if not nStack or nStack:isRoot() then
				error(nExc)
			end
		end
	end)
	self._target = vTarget or false
end

function ScheduleTask:getSelfCo():Ret(Thread)
	return self._selfCo
end

function ScheduleTask:canWaitType()
	return not SealStack.is(self._target)
end

function ScheduleTask:runAsync(vFunc:Fn())
	self._scheduleManager:coStart(self._selfCo, vFunc)
end

function ScheduleTask:getStack():Ret(OrFalse(clazz.SealStack))
	const nStack = self._target
	return SealStack.is(nStack) and nStack
end

function ScheduleTask:makeEvent():Ret(clazz.ScheduleEvent)
	return self._scheduleManager:makeEvent(self._selfCo)
end

function ScheduleTask:makeWildEvent():Ret(clazz.ScheduleEvent)
	return self._scheduleManager:makeEvent()
end

return ScheduleTask
