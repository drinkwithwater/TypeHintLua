
local TYPE_BITS = require "thlua.type.TYPE_BITS"

local StringLiteralSetCom = require "thlua.union.StringLiteralSetCom"
local NumberLiteralSetCom = require "thlua.union.NumberLiteralSetCom"
local ObjectSetCom = require "thlua.union.ObjectSetCom"
local FuncSetCom = require "thlua.union.FuncSetCom"
local ComplexUnion = require "thlua.union.ComplexUnion"
local FalsableUnion = require "thlua.union.FalsableUnion"

(@let.class = import("thlua.type.TypeClass").class)

local FastTypeBitsToTrue = {
	[TYPE_BITS.NIL]=true,
	[TYPE_BITS.FALSE]=true,
	[TYPE_BITS.TRUE]=true,
	[TYPE_BITS.TRUTH]=true,
}

local TrueBitToTrue = {
	[TYPE_BITS.TRUE]=true,
	[TYPE_BITS.OBJECT]=true,
	[TYPE_BITS.FUNCTION]=true,
	[TYPE_BITS.NUMBER]=true,
	[TYPE_BITS.STRING]=true,
}

local TypeCollection = {}
TypeCollection.__index=TypeCollection
TypeCollection.__len=function(self)
	return self.count
end

function TypeCollection.new(vManager:class.TypeManager)::Ret(class.TypeCollection)
	local self = {
		_manager=vManager,
		_type=vManager.type,
		bitsToSet={} @ Dict(Number,Dict(class.IAtomType,True)),
		bits=0 @ Number,
 		count=0 @ Number,
	}
	return (setmetatable(self, TypeCollection)) @ class.TypeCollection
end

function TypeCollection:_putOne(vType)
	local nBitsToSet = self.bitsToSet
	local nBits = vType.bits
	local nSet = nBitsToSet[nBits]
	if not nSet then
		nSet = {}
		nBitsToSet[nBits] = nSet
	end
	if not nSet[vType] then
		nSet[vType] = true
		self.count = self.count + 1
	end
end

function TypeCollection:put(vType:class.UKeyType)
	vType:foreach(function(vSubType)
		self.bits = self.bits | vSubType.bits
		self:_putOne(vSubType)
	end)
end

function TypeCollection:_makeSimpleTruePart(vBit, vSet)::Ret(Union(class.IAtomType, classISetCom))
	local nSetCom
	if vBit == TYPE_BITS.TRUE then
		return self._type.True
	elseif vBit == TYPE_BITS.NUMBER then
		local nNumberType = self._type.Number
		if vSet[nNumberType] then
			return nNumberType
		end
		nSetCom = NumberLiteralSetCom.new(self._manager)
	elseif vBit == TYPE_BITS.STRING then
		local nStringType = self._type.String
		if vSet[nStringType] then
			return nStringType
		end
		nSetCom = StringLiteralSetCom.new(self._manager)
	elseif vBit == TYPE_BITS.OBJECT then
		nSetCom = ObjectSetCom.new(self._manager)
	elseif vBit == TYPE_BITS.FUNCTION then
		nSetCom = FuncSetCom.new(self._manager)
	else
		error("bit can't be="..tostring(vBit))
	end
	for nType, _ in pairs(vSet) do
		nSetCom:_put(nType)
	end
	return nSetCom
end

function TypeCollection:makeBitToCom()::Ret(Dict(Number, Union(class.IAtomType, classISetCom)))
	local nBits = self.bits
	local nTruableBits = nBits & (~ (TYPE_BITS.NIL | TYPE_BITS.FALSE))
	local nFalsableBits = nBits & (TYPE_BITS.NIL | TYPE_BITS.FALSE)
	-- 2. make true part
	local nBitToCom = {}
	for nBit, nSet in pairs(self.bitsToSet) do
		if TrueBitToTrue[nBit] then
			nBitToCom[nBit] = self:_makeSimpleTruePart(nBit, nSet)
		end
	end
	if nTruableBits == TYPE_BITS.TRUTH then
		error("Truth TODO")
	end
	-- 3. check false part
	if nFalsableBits ~= 0 then
		if TYPE_BITS.NIL & nBits then
			nBitToCom[TYPE_BITS.NIL] = self._type.Nil
		end
		if TYPE_BITS.FALSE & nBits then
			nBitToCom[TYPE_BITS.FALSE] = self._type.False
		end
	end
	return nBitToCom
end

function TypeCollection:mergeToType()::Ret(Dict(Number, Union(class.IAtomType, class.ISetCom)))
	-- TODO merge contained type
	local nBits = self.bits
	-- 0. only one type
	if self.count == 1 then
		return (next(self.bitsToSet[nBits]))
	end
	-- 1. fast type
	if nBits == 0 then
		-- 1) bits=0 for never
		return self._type.Never
	elseif FastTypeBitsToTrue[nBits] then
		-- 2) some bit for only one type
		return (next(self.bitsToSet[nBits]))
	end
	return self._manager:FullUnionByComDict(self:makeBitToCom())
end

return TypeCollection
