
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const TypeCollection = require "thlua.manager.TypeCollection"
const Node = require "thlua.code.Node"
const Exception = require "thlua.Exception"

const Never = require "thlua.union.Never"
const StringLiteral = require "thlua.type.StringLiteral"
const String = require "thlua.type.String"
const NumberLiteral = require "thlua.type.NumberLiteral"
const Number = require "thlua.type.Number"
const BooleanLiteral= require "thlua.type.BooleanLiteral"
const Nil = require "thlua.type.Nil"
const Thread = require "thlua.type.Thread"
const Truth = require "thlua.type.Truth"
const TypedObject = require "thlua.object.TypedObject"
const Struct = require "thlua.object.Struct"
const Interface = require "thlua.object.Interface"
const OpenTable = require "thlua.object.OpenTable"
const AutoTable = require "thlua.object.AutoTable"
const SealTable = require "thlua.object.SealTable"
const OpenFunction = require "thlua.func.OpenFunction"
const TypedFunction = require "thlua.func.TypedFunction"
const PolyFunction = require "thlua.func.PolyFunction"
const AnyFunction = require "thlua.func.AnyFunction"
const Reference = require "thlua.refer.Reference"

const MemberFunction = require "thlua.func.MemberFunction"

const StringLiteralUnion = require "thlua.union.StringLiteralUnion"
const NumberLiteralUnion = require "thlua.union.NumberLiteralUnion"
const ObjectUnion = require "thlua.union.ObjectUnion"
const FuncUnion = require "thlua.union.FuncUnion"
const FalsableUnion = require "thlua.union.FalsableUnion"
const ComplexUnion = require "thlua.union.ComplexUnion"

const RetTuples = require "thlua.tuple.RetTuples"
const TypeTuple = require "thlua.tuple.TypeTuple"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"
const ScheduleEvent = require "thlua.manager.ScheduleEvent"

const BaseReadyType = require "thlua.type.BaseReadyType"
const MetaEventCom = require "thlua.object.MetaEventCom"
const native = require "thlua.native"

const UnionReferCom = require "thlua.refer.UnionReferCom"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.WaitingInfo = Struct {
		waitSid = Integer,
		dependCo = Thread,
	}
end)

const TypeManager = {}
TypeManager.__index=TypeManager

const function:class(let.BuiltinFunc) makeBuiltinFunc(vManager:clazz.TypeManager)
	const self = {.class
		string=native.make_string(vManager),
		next=native.make_next(vManager),
		inext=native.make_inext(vManager),
		bop={
			mathematic=native.make_mathematic(vManager),
			comparison=native.make_comparison(vManager),
			bitwise=native.make_bitwise(vManager),
			concat=native.make_concat(vManager),
		},
	}
	return self
end

function:class(clazz.TypeManager) TypeManager.new(vRuntime:clazz.Runtime)
	const function:class(let.BuiltinType) makeBuiltinType(vManager:clazz.TypeManager)
		const self = {.class
			Never = Never.new(vManager),
			Nil = Nil.new(vManager),
			False = BooleanLiteral.new(vManager, false),
			True = BooleanLiteral.new(vManager, true),
			Thread = Thread.new(vManager),
			Number = Number.new(vManager),
			String = String.new(vManager),
			Truth = Truth.new(vManager),
			AnyFunction = AnyFunction.new(vManager),
			Boolean = nil @! clazz.TypeReference,
			Any = nil @! clazz.TypeReference,
			AnyObject = nil @! clazz.Interface,
		}
		self.Integer = self.Number
		return self
	end
	const self = setmetatable({.class
		_runtime=vRuntime,
		-- type items
		type=nil @! BuiltinType,
		builtin=nil @! BuiltinFunc,
		generic={} @ Dict(String, clazz.TypeReference),
		_pairToInclude={} @ Dict(Integer, clazz.TypeReference),
		_literalDict={}@Struct {[Number]=clazz.NumberLiteral, [String]=clazz.StringLiteral, [Boolean]=OrNil(clazz.BooleanLiteral)},
		_unionSignToType=setmetatable({}, {__mode="v"}) @ Dict(String, clazz.UAtomUnion),
		_typeIdCounter=0@Integer,
		_rootNode=vRuntime:getNode(),
	}, TypeManager)
	const nRootNode = vRuntime:getNode()
	self.type = makeBuiltinType(self)
	self.type.Boolean = self:buildUnion(nRootNode, self.type.False, self.type.True)
	self.type.Any = self:buildUnion(nRootNode, self.type.False, self.type.Nil, self.type.Truth)
	self.type.AnyObject = self:buildInterface(nRootNode, {})
	self.generic.Dict = self:buildTemplate(nRootNode, function(vKey:clazz.UAllType,vValue:clazz.UAllType)
		assert(vKey and vValue, "key or value can't be nil when build Dict")
		return self:buildStruct(nRootNode, {[vKey]=vValue}, {__next=vKey})
	end)
	self.generic.Cond = self:buildTemplate(nRootNode, function(vCond:clazz.UAllType,v1:clazz.UAllType,v2:clazz.UAllType)
		local nType = vCond
		if Reference.is(vCond) then
			nType = vCond:waitTypeCom():getTypeAwait()
		end
		if nType:isUnion() then
			error("Cond's first value can't be union")
		end
		return (nType == self.type.Nil or nType == self.type.False) and v2 or v1
	end)
	self.generic.IDict = self:buildTemplate(nRootNode, function(vKey:clazz.UAllType,vValue:clazz.UAllType)
		assert(vKey and vValue, "key or value can't be nil when build IDict")
		return self:buildInterface(nRootNode, {[vKey]=vValue}, {__next=vKey})
	end)
	self.generic.List = self:buildTemplate(nRootNode, function(vValue:clazz.UAllType)
		assert(vValue, "value can't be nil when build List")
		return self:buildStruct(nRootNode, {[self.type.Integer]=vValue}, {__next=self.type.Integer, __len=self.type.Integer})
	end)
	self.generic.IList = self:buildTemplate(nRootNode, function(vValue:clazz.UAllType)
		assert(vValue, "value can't be nil when build IList")
		return self:buildInterface(nRootNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer})
	end)
	self.generic.KeyOf = self:buildTemplate(nRootNode, function(vOneType:clazz.UAllType)
		local nObject = vOneType
		if Reference.is(vOneType) then
			nObject = vOneType:waitTypeCom():getTypeAwait()
		end
		if not TypedObject.is(nObject) then
			error("key of can only worked on object function")
		end
		const nKeyRefer, _ = nObject:getKeyTypes()
		const nRefer = self:Reference(false)
		nRefer:setUnionAsync(nObject:getNode(), function()
			return nKeyRefer:getListAwait(), function()
				nKeyRefer:getTypeAwait()
			end
		end)
		return nRefer
	end)
	return self
end

function TypeManager:lateInit()
	self.builtin = makeBuiltinFunc(self)
end

const AtomMetatableSet:Dict(Truth, String) = {
	-- not recursive
}

const AtomUnionMetatableSet:Dict(Truth, String) = {
	[Never]="Never",
	[NumberLiteralUnion]="NumberLiteralUnion",
	[StringLiteralUnion]="StringLiteralUnion",
	[FalsableUnion]="FalsableUnion",
	[ObjectUnion]="ObjectUnion",
	[FuncUnion]="FuncUnion",
	[ComplexUnion]="ComplexUnion",
}

for k, v in pairs(AtomMetatableSet) do
	AtomUnionMetatableSet[k] = v
end

function TypeManager:pcheckNamespaceAssigValue(vData:Any):Ret(True, Union(clazz.TypeReference, clazz.IAtomType)):Ret(False, String)
	local meta = getmetatable(vData)
	if meta and (AtomMetatableSet[meta] or Reference.is(vData) or BaseReadyType.is(vData)) then
		return true, vData @? Union(clazz.TypeReference, clazz.IAtomType)
	else
		return false, "not atom or reference"
	end
end

function TypeManager:assertAllType(vData:Truth):Ret(clazz.UAllType)
	local meta = getmetatable(vData)
	if meta and (AtomUnionMetatableSet[meta] or Reference.is(vData) or BaseReadyType.is(vData)) then
		return vData @? clazz.UAllType
	else
		error("assertAllType failed, type="..type(vData)..tostring(debug.traceback()))
	end
end

function.pass TypeManager:_checkAllType(vData:Any):Ret(OrFalse(clazz.UAllType))
	local t = type(vData)
	if t == "table" then
		local meta = getmetatable(vData)
		if AtomMetatableSet[meta] then
			return vData
		end
	end
	if Reference.is(vData) then
		return vData
	end
	return false
end

function.pass TypeManager:easyToTypeList(...:Any):Ret(List(clazz.UAllType))
	const l = {...}
	for i=1,#l do
		l[i] = self:easyToType(l[i])
	end
	return l
end

function.pass TypeManager:peasyToType(vData:Any):Ret(False, String):Ret(True, clazz.UAllType)
	local t = type(vData)
	if t == "table" then
		local meta = getmetatable(vData)
		if AtomMetatableSet[meta] or AtomUnionMetatableSet[meta] or Reference.is(vData) or BaseReadyType.is(vData) then
			return true, vData
		else
			return false, "to type failed"
		end
	elseif t == "number" or t == "string" or t == "boolean"then
		return true, self:Literal(vData)
	else
		return false, "easyToType("..t..") invalid"
	end
end

function TypeManager:easyToType(vData:Any):Ret(clazz.UAllType)
	const nOkay, nType = self:peasyToType(vData)
	if nOkay then
		return nType
	else
		error(nType)
	end
end

function TypeManager:TypeCollection():Ret(clazz.TypeCollection)
	return TypeCollection.new(self)
end

function TypeManager:UnionReferCom(vNode:clazz.IAstNode, vTask:clazz.ScheduleTask):Ret(clazz.UnionReferCom)
	const nCom = UnionReferCom.new(self, vNode, vTask)
	return nCom
end

function TypeManager:_buildCombineObject(vNode:clazz.IAstNode, vIsInterface:Boolean, vObjectList:List(clazz.UAllType)):Ret(clazz.TypeReference)
	const nObjectRefer = self:Reference(false)
	nObjectRefer:setUnionAsync(vNode, function()
		if vIsInterface then
			assert(#vObjectList>=1, "Intersect must take at least one arguments")
		else
			assert(#vObjectList >= 2, "StructExtend must take at least one interface after struct")
		end
		const nKeyList:List(clazz.IAtomType) = {}
		const nAllValueDict:clazz.MemberDict = {}
		const nIntersectSet:Dict(clazz.TypedObject, True) = {}
		const nMetaEventComList:List(clazz.MetaEventCom) = {}
		local nIntersectNextKey:OrFalse(clazz.UAllType) = self.type.Any
		for i=1,#vObjectList do
			local nTypedObject = vObjectList[i]!
			if Reference.is(nTypedObject) then
				nTypedObject = nTypedObject:waitTypeCom():getTypeAwait()
			end
			if not TypedObject.is(nTypedObject) then
				error("Interface or Struct is expected here")
				break
			end
			if i == 1 then
				if vIsInterface then
					assert(Interface.is(nTypedObject), "Intersect must take Interface")
					nIntersectSet[nTypedObject] = true
				else
					assert(not Interface.is(nTypedObject), "StructExtend must take Struct as first argument")
				end
			else
				assert(Interface.is(nTypedObject), vIsInterface
					and "Intersect must take Interface as args"
					or "StructExtend must take Interface after first argument")
				nIntersectSet[nTypedObject] = true
			end
			local nValueDict = nTypedObject:getMemberDict()
			const nKeyRefer, nNextKey = nTypedObject:getKeyTypes()
			for _, nKeyType in ipairs(nKeyRefer:getListAwait()) do
				nKeyList[#nKeyList + 1] = nKeyType
				nAllValueDict[nKeyType] = nValueDict[nKeyType]
			end
			nMetaEventComList[#nMetaEventComList + 1] = nTypedObject:getMetaEventCom() or nil
			if nIntersectNextKey then
				if nNextKey then
					const nTypeOrFalse = nIntersectNextKey:safeIntersect(nNextKey)
					if not nTypeOrFalse then
						error("intersect error")
					else
						nIntersectNextKey = nTypeOrFalse
					end
				else
					nIntersectNextKey = false
				end
			end
		end
		const nNewObject = vIsInterface
			and Interface.new(self, vNode, nIntersectNextKey)
			or Struct.new(self, vNode, nIntersectNextKey)
		nNewObject:buildAsync(function(vAsyncKey)
			if #nMetaEventComList > 0 then
				const nNewEventCom = self:makeMetaEventCom(nNewObject)
				nNewEventCom:initByMerge(nMetaEventComList)
				nNewObject:lateInit(nIntersectSet, nAllValueDict, nNewEventCom)
			else
				nNewObject:lateInit(nIntersectSet, nAllValueDict, false)
			end
			const nKeyAtomUnion = vAsyncKey:setAtomList(nKeyList)
			-- TODO check key's count and intersect valid
			nNewObject:lateCheck()
		end)
		return {nNewObject}
	end)
	return nObjectRefer
end

function TypeManager:buildStructExtend(vNode:clazz.IAstNode, vFirst:Union(Dict(Truth, Truth), clazz.UAllType),
	...:Union(clazz.TypeReference, clazz.TypedObject)):Ret(clazz.TypeReference)
	const nStruct = self:_checkAllType(vFirst) or self:buildStruct(vNode, vFirst @> Dict(Truth, Truth))
	const l:List(clazz.UAllType) = {nStruct, ...}
	return self:_buildCombineObject(vNode, false, l)
end

function TypeManager:buildIntersect(vNode:clazz.IAstNode, ...:Union(clazz.TypeReference, clazz.TypedObject)):Ret(clazz.TypeReference)
	const l:List(clazz.UAllType) = {...}
	return self:_buildCombineObject(vNode, true, l)
end

function TypeManager:checkedUnion(...:clazz.UAllType):Ret(clazz.UAtomUnion)
	const l:List(clazz.UAllType) = {...}
	const nCollection = self:TypeCollection()
	for i=1, select("#", ...) do
		l[i]!:checkAtomUnion():foreach(function(vAtomType)
			nCollection:put(vAtomType)
		end)
	end
	return nCollection:mergeToAtomUnion()
end

function TypeManager:buildUnion(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeReference)
	local l = {...}
	const nLen = select("#", ...)
	local nNewRefer = self:Reference(false)
	nNewRefer:setUnionAsync(vNode, function()
		local nTypeList:List(clazz.IAtomType) = {}
		for i=1, nLen do
			local nItem = l[i]
			if Reference.is(nItem) then
				local nList = nItem:waitTypeCom():getListAwait()
				table.move(nList, 1, #nList, #nTypeList + 1, nTypeList)
			else
				self:easyToType(nItem):foreachAwait(function(vAtom)
					nTypeList[#nTypeList + 1] = vAtom
				end)
			end
		end
		return nTypeList
	end)
	return nNewRefer
end

function TypeManager:buildInterface(vNode:clazz.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType))):Ret(clazz.Interface)
	return self:_buildTypedObject@<True>(vNode, vTable, vMetaEventDict, true)
end

function TypeManager:buildStruct(vNode:clazz.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType))):Ret(clazz.Struct)
	return self:_buildTypedObject@<False>(vNode, vTable, vMetaEventDict, false)
end

function TypeManager:_buildTypedObject@<IsInterface>(vNode:clazz.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType)), vIsInterface:IsInterface):Ret(Cond(IsInterface, clazz.Interface, clazz.Struct))
	const nNewObject = vIsInterface
	and Interface.new(self, vNode, vMetaEventDict and vMetaEventDict.__next or false)
	or Struct.new(self, vNode, vMetaEventDict and vMetaEventDict.__next or false)
	nNewObject:buildAsync(function(vAsyncKey)
		const nKeyList:List(clazz.IAtomType) = {}
		const nValueDict:Dict(clazz.IAtomType, Union(clazz.UAllType, clazz.MemberFunction)) = {}
		for nKey, nValue in pairs(vTable) do
			local nValueType:OrNil(clazz.UAllType, clazz.MemberFunction) = nil
			if MemberFunction.is(nValue) then
				nValueType = nValue
			else
				nValueType = self:easyToType(nValue)
			end
			local nKeyType = self:easyToType(nKey)
			nKeyType:foreachAwait(function(vAtomType)
				nKeyList[#nKeyList + 1] = vAtomType
				if vAtomType:isSingleton() then
					nValueDict[vAtomType] = nValueType
				else
					assert(nValueType and not MemberFunction.is(nValueType), "valuetype with non-singleton key can't be nil or MemberFunction")
					nValueDict[vAtomType] = self:buildUnion(vNode, nValueType, self.type.Nil)
				end
			end)
		end
		if vMetaEventDict then
			const nNewEventCom = self:makeMetaEventCom(nNewObject)
			nNewEventCom:initByEventDict(vMetaEventDict)
			nNewObject:lateInit({}, nValueDict, nNewEventCom)
		else
			nNewObject:lateInit({}, nValueDict, false)
		end
		const nKeyAtomUnion = vAsyncKey:setAtomList(nKeyList)
		nNewObject:lateCheck()
		local nFinalCount = 0
		nKeyAtomUnion:foreach(function(_)
			nFinalCount = nFinalCount + 1
		end)
		if nFinalCount ~= #nKeyList then
			error("Object's key can not has intersect part")
		end
	end)
	return nNewObject
end

function TypeManager:buildIDict(vNode:clazz.IAstNode, vKey:clazz.UAtomUnion, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildInterface(vNode, {[vKey]=vValue})
end

function TypeManager:buildDict(vNode:clazz.IAstNode, vKey:clazz.UAtomUnion, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildStruct(vNode, {[vKey]=vValue}, {__next=vKey})
end

function TypeManager:buildIList(vNode:clazz.IAstNode, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildInterface(vNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer})
end

function TypeManager:buildList(vNode:clazz.IAstNode, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildStruct(vNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer, __next=self.type.Integer})
end

function TypeManager:buildOrNil(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeReference)
	return self:buildUnion(vNode, self.type.Nil, ...)
end

function TypeManager:buildOrFalse(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeReference)
	return self:buildUnion(vNode, self.type.False, ...)
end

function TypeManager:_unifyUnion(vNewType:clazz.IUnionType):Ret(clazz.UAtomUnion)
	local nSign = vNewType:unionSign()
	local nSignToType = self._unionSignToType
	local nOldType = nSignToType[nSign]
	if not nOldType then
		vNewType:initTypeId(self:genTypeId())
		nSignToType[nSign] = vNewType
		return vNewType
	else
		return nOldType
	end
end

function TypeManager:atomRecordTypeUnionSign(vType:clazz.BaseAtomType)
	self._unionSignToType[tostring(vType.id)] = vType
end

function TypeManager:metaNativeOpenFunction(vFn):Ret(clazz.OpenFunction)
	const nOpenFn = self._runtime:getRootStack():newOpenFunction(self._rootNode)
	nOpenFn:lateInitFromMetaNative(vFn)
	return nOpenFn
end

function TypeManager:fixedNativeOpenFunction(vFn):Ret(clazz.OpenFunction)
	const nOpenFn = self._runtime:getRootStack():newOpenFunction(self._rootNode)
	nOpenFn:lateInitFromOperNative(vFn)
	return nOpenFn
end

function TypeManager:stackNativeOpenFunction(vFn):Ret(clazz.OpenFunction)
	const nOpenFn = self._runtime:getRootStack():newOpenFunction(self._rootNode)
	nOpenFn:lateInitFromAutoNative(vFn)
	return nOpenFn
end

function TypeManager:AutoTable(vNode:clazz.IAstNode):Ret(clazz.AutoTable)
	return AutoTable.new(self, vNode)
end

function TypeManager:Literal(vValue:Union(String, Number, Boolean)):Ret(Union(clazz.NumberLiteral, clazz.StringLiteral, clazz.BooleanLiteral))
	const nLiteralDict = self._literalDict
	local nLiteralType = nLiteralDict[vValue]
	if not nLiteralType then
		const t = type(vValue)
		if t == "number" then
			nLiteralType = NumberLiteral.new(self, vValue)
			nLiteralDict[vValue] = nLiteralType
		elseif t == "string" then
			nLiteralType = StringLiteral.new(self, vValue)
			nLiteralDict[vValue] = nLiteralType
		elseif t == "boolean" then
			if vValue then
				nLiteralType = self.type.True
			else
				nLiteralType = self.type.False
			end
			nLiteralDict[vValue] = nLiteralType
		else
			error("literal must take number or string value"..t)
		end
	end
	return nLiteralType
end

function TypeManager:TypeTuple(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeTuple)
	local nTypeList:List(clazz.UAllType) = {}
	for i=1, select("#", ...) do
		local nArg = select(i, ...)
		assert(nArg, "tuple can't take false or nil value")
		if Reference.is(nArg) then
			nTypeList[i] = nArg
		else
			nTypeList[i] = self:assertAllType(nArg)
		end
	end
	return TypeTuple.new(self, vNode, nTypeList)
end

function TypeManager:VoidRetTuples(vNode:clazz.IAstNode):Ret(clazz.RetTuples)
	return RetTuples.new(self, vNode, {self:TypeTuple(self._runtime:getNode())})
end

function TypeManager:SingleRetTuples(vNode:clazz.IAstNode, vTypeTuple:clazz.UTypeTuple):Ret(clazz.RetTuples)
	return RetTuples.new(self, vNode, {vTypeTuple})
end

function TypeManager:buildMfn(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.MemberFunction)
	const nWildFn = self:buildFn(vNode, self.type.Truth, ...)
	const nPolyFn = self:buildPfn(vNode, function(vSelfType:clazz.UAllType):Ret(clazz.TypedFunction)
		const nRetTuples = nWildFn:getRetTuples()
		const nParTuple = nWildFn:getParTuple():replaceFirst(vSelfType)
		return self:TypedFunction(vNode, nParTuple, nRetTuples)
	end)
	return MemberFunction.new(self, vNode, nPolyFn, nWildFn)
end

function TypeManager:buildPfn(vNode:clazz.IAstNode, vFunc:AnyFunction):Ret(clazz.PolyFunction)
	const nInfo = debug.getinfo(vFunc)
	const nPolyParNum=nInfo.nparams
	if nInfo.isvararg then
		error("poly function can't be vararg")
	end
	return PolyFunction.new(self, vNode, vFunc, nPolyParNum)
end

function TypeManager:buildFn(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypedFunction)
	local nParTuple = self:TypeTuple(vNode, ...)
	return TypedFunction.new(self, vNode, nParTuple, false)
end

function TypeManager:checkedFn(...:Truth):Ret(clazz.TypedFunction)
	local nParTuple = self:TypeTuple(self._runtime:getNode(), ...)
	return TypedFunction.new(self, self._runtime:getNode(), nParTuple, false)
end

function TypeManager:PolyFunction(vNode:clazz.IAstNode, vFunc:AnyFunction, vPolyParNum:Integer, vStack:OrNil(clazz.BaseStack)):Ret(clazz.PolyFunction)
	return PolyFunction.new(self, vNode, vFunc, vPolyParNum, vStack)
end

function TypeManager:MemberFunction(vNode:clazz.IAstNode, vPolyFn:clazz.PolyFunction):Ret(clazz.MemberFunction)
	return MemberFunction.new(self, vNode, vPolyFn, false)
end

function TypeManager:TypedFunction(vNode:clazz.IAstNode, vParTuple:clazz.UTypeTuple, vRetTuples:clazz.RetTuples):Ret(clazz.TypedFunction)
	assert(TypeTuple.is(vParTuple) or TypeTupleDots.is(vParTuple))
	assert(RetTuples.is(vRetTuples))
	return TypedFunction.new(self, vNode, vParTuple, vRetTuples)
end

function TypeManager:makeMetaEventCom(vObject:Union(clazz.SealTable, clazz.TypedObject)):Ret(clazz.MetaEventCom)
	return MetaEventCom.new(self, vObject)
end

function TypeManager:buildTemplate(vNode:clazz.IAstNode, vFunc:AnyFunction):Ret(clazz.TypeReference)
	const nInfo = debug.getinfo(vFunc)
	const nParNum = nInfo.nparams
	if nInfo.isvararg then
		error("template's parameter number is undetermined")
	end
	return self:buildTemplateWithParNum(vNode, vFunc, nParNum)
end

function TypeManager:buildTemplateWithParNum(vNode:clazz.IAstNode, vFunc:AnyFunction, vParNum:Integer):Ret(clazz.TypeReference)
	const nRefer = self:Reference(false)
	nRefer:setTemplateAsync(vNode, vFunc, vParNum)
	return nRefer
end

function TypeManager:Reference(vName:Union(String, False)):Ret(clazz.TypeReference)
	const nRefer = Reference.new(self, vName)
	return nRefer
end

function TypeManager:mergePairList@<TValue>(vTypePairList:List(Struct {clazz.UAtomUnion, TValue})):Ret(clazz.UAtomUnion, Dict(clazz.IAtomType, TValue))
	local nCollection = self:TypeCollection()
	for _, nPair in ipairs(vTypePairList) do
		local nFieldType = nPair[1]
		if nFieldType:isReference() then
			nFieldType = nFieldType:checkAtomUnion()
			nPair[1] = nFieldType
		end
		nCollection:put(nFieldType)
	end
	local nKeyUnion = nCollection:mergeToAtomUnion()
	local nTypeDict:Dict(clazz.IAtomType, TValue) = {}
	for _, nPair in ipairs(vTypePairList) do
		local nKey = nPair[1]
		local nValueType = nPair[2]
		nKey:foreach(function(vSubType)
			local nIncludeType = assert(nKeyUnion:includeAtom(vSubType), "merge error")
			local nOldType = nTypeDict[nIncludeType]
			if nOldType then
				nTypeDict[nIncludeType] = nOldType | nValueType
			else
				nTypeDict[nIncludeType] = nValueType
			end
		end)
	end
	return nKeyUnion, nTypeDict
end

function TypeManager:makePair(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(Integer)
	const nLeftId, nRightId = vLeft.id, vRight.id
	assert(nLeftId ~= 0 and nRightId ~=0, "use id ==0")
	return (nLeftId << 32) + nRightId
end

function TypeManager:makeDuPair(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(Boolean, Integer, Integer)
	const nLeftId, nRightId = vLeft.id, vRight.id
	if nLeftId < nRightId then
		return false, (nLeftId << 32) + nRightId, (nRightId << 32) + nLeftId
	else
		return true, (nRightId << 32) + nLeftId, (nLeftId << 32) + nRightId
	end
end

function TypeManager:getTypePairInclude(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(OrNil(clazz.TypeReference))
	const nPair = self:makePair(vLeft, vRight)
	return self._pairToInclude[nPair]
end

function TypeManager:attachPairInclude(vLeft:clazz.TypedObject, vRight:clazz.TypedObject, vWaitCreate:Boolean):Ret(OrNil(clazz.RelationEnum))
	const nInverse, nLRPair, nRLPair = self:makeDuPair(vLeft, vRight)
	if nInverse then
		vRight, vLeft = vLeft, vRight
	end
	local nIncludeRefer = self._pairToInclude[nLRPair]
	local nResultType:OrFalse(clazz.UAtomUnion) = false
	if vWaitCreate then
		if not nIncludeRefer then
			nIncludeRefer = self:Reference(false)
			self._pairToInclude[nLRPair] = nIncludeRefer
			nIncludeRefer:setUnionAsync(self._runtime:getNode(), function()
				const nLRInclude = vLeft:assumeIncludeObject({[nLRPair]=true}, vRight)
				const nRLInclude = vRight:assumeIncludeObject({[nRLPair]=true}, vLeft)
				if nLRInclude and nRLInclude then
					return {self:Literal("=")}
				elseif nLRInclude then
					return {self:Literal(">")}
				elseif nRLInclude then
					return {self:Literal("<")}
				else
					if Interface.is(vLeft) and Interface.is(vRight) then
						const nIntersect = vLeft:assumeIntersectInterface({[nLRPair]=true,[nRLPair]=true}, vRight)
						if nIntersect then
							return {self:Literal("&")}
						end
					end
					return {self:Literal("~")}
				end
			end)
		end
		nResultType = nIncludeRefer:waitTypeCom():getTypeAwait()
	else
		if nIncludeRefer then
			nResultType = nIncludeRefer:waitTypeCom():getResultType()
		end
	end
	if not nResultType then
		return nil
	else
		const nLiteral = nResultType @? clazz.StringLiteral
		const nRelation = nLiteral:getLiteral() @? clazz.RelationEnum
		if nInverse then
			if nRelation == ">" then
				return "<"
			elseif nRelation == "<" then
				return ">"
			else
				return nRelation
			end
		else
			return nRelation
		end
	end
end

function TypeManager:getRuntime():Ret(clazz.Runtime)
	return self._runtime
end

function TypeManager:literal2Primitive(vType:clazz.UAtomUnion):Ret(clazz.UAtomUnion)
	if BooleanLiteral.is(vType) then
		return self.type.Boolean:checkAtomUnion()
	elseif NumberLiteral.is(vType) then
		return self.type.Number
	elseif StringLiteral.is(vType) then
		return self.type.String
	else
		return vType
	end
end

function TypeManager:signTemplateArgs(vTypeList:IList(clazz.UAllType)):Ret(String)
	const nIdList:List(Integer) = {}
	for i=1,#vTypeList do
		nIdList[i] = vTypeList[i]!.id
	end
	return table.concat(nIdList, "-")
end

function TypeManager:genTypeId():Ret(Integer)
	local nNewId = self._typeIdCounter + 1
	self._typeIdCounter = nNewId
	return nNewId
end

function TypeManager:dump()
	for k,v in pairs(self._unionSignToType) do
		print(k, tostring(v))
	end
end

function TypeManager:getScheduleManager():Ret(clazz.ScheduleManager)
	return self._runtime:getScheduleManager()
end

return TypeManager
