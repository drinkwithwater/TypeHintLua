
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local TypeCollection = require "thlua.manager.TypeCollection"
local Node = require "thlua.code.Node"
local Exception = require "thlua.Exception"

local Never = require "thlua.union.Never"
local StringLiteral = require "thlua.type.StringLiteral"
local String = require "thlua.type.String"
local NumberLiteral = require "thlua.type.NumberLiteral"
local Number = require "thlua.type.Number"
local BooleanLiteral= require "thlua.type.BooleanLiteral"
local Nil = require "thlua.type.Nil"
local Truth = require "thlua.type.Truth"
local MetaObject = require "thlua.object.MetaObject"
local LuaTable = require "thlua.object.LuaTable"
local LuaFunction = require "thlua.func.LuaFunction"
local NativeFunction = require "thlua.func.NativeFunction"
local TypeFunction = require "thlua.func.TypeFunction"
local Reference = require "thlua.type.Reference"
local Variable = require "thlua.func.Variable"

local MemberFunction = require "thlua.func.MemberFunction"

local StringLiteralUnion = require "thlua.union.StringLiteralUnion"
local NumberLiteralUnion = require "thlua.union.NumberLiteralUnion"
local ObjectUnion = require "thlua.union.ObjectUnion"
local FuncUnion = require "thlua.union.FuncUnion"
local FalsableUnion = require "thlua.union.FalsableUnion"
local ComplexUnion = require "thlua.union.ComplexUnion"

local RetTuples = require "thlua.tuple.RetTuples"
local TypeTuple = require "thlua.tuple.TypeTuple"
local TypeTupleDots = require "thlua.tuple.TypeTupleDots"
local TermTuple = require "thlua.tuple.TermTuple"
local RefineTerm = require "thlua.term.RefineTerm"

local native = require "thlua.native"

(@do
	let.class = import("thlua.type.TypeClass").class
end)

local TypeManager = {}
TypeManager.__index=TypeManager

function TypeManager.new(vRuntime:class.Runtime)::RetClass(class.TypeManager)
	local self = setmetatable({::Self()
		_runtime=vRuntime,
		type={},
		builtin={},
		coToRefer={} @ Dict(Truth, class.Reference),
		_pairToContain={} @ Dict(Integer, class.Reference),
		_literalDict={}@Struct {[Number]=class.NumberLiteral, [String]=class.StringLiteral},
		_unionSignToType={}@Dict(String, class.UAtomUnion),
		_typeIdCounter=0@Number,
	}, TypeManager)
	self.type.Never = Never.new(self)
	self.type.Nil = Nil.new(self)
	self.type.False = BooleanLiteral.new(self, false)
	self.type.True = BooleanLiteral.new(self, true)
	self.type.Number = Number.new(self)
	self.type.Integer = self.type.Number
	self.type.String = String.new(self)
	self.type.Truth = Truth.new(self)
	for k, nType in pairs(self.type) do
		self:_recordTypeUnionSign(nType)
	end
	self.type.Boolean = self:checkedUnion(self.type.False, self.type.True)
	self.type.Any = self:checkedUnion(self.type.False, self.type.Nil, self.type.Truth)
	self.type.Object = self:buildInterface(self._runtime:getNode(), {}, false)
	self.builtin.string=native.make_string(self)
	self.builtin.next=native.make_next(self)
	self.builtin.inext=native.make_inext(self)
	self.builtin.bop={
		mathematic=native.make_mathematic(self),
		comparison=native.make_comparison(self),
		bitwise=native.make_bitwise(self),
		concat=native.make_concat(self),
	}
	return self
end

local tableToTypeFuncDict = {
	[Nil]=true,
	[Never]=true,
	[String]=true,
	[StringLiteral]=true,
	[Number]=true,
	[NumberLiteral]=true,
	[BooleanLiteral]=true,
	[MetaObject]=true,
	[Truth]=true,
	[LuaTable]=true,

	[NumberLiteralUnion]=true,
	[StringLiteralUnion]=true,
	[FalsableUnion]=true,
	[ObjectUnion]=true,
	[FuncUnion]=true,
	[ComplexUnion]=true,

	[LuaFunction]=true,
	[TypeFunction]=true,
	[NativeFunction]=true,
}

function TypeManager:isValueType(vData)::Ret(Boolean)
	local meta = getmetatable(vData)
	if meta and (tableToTypeFuncDict[meta] or meta == Reference) then
			return true
	else
		return false
	end
end

function TypeManager:assertValueType(vData)::Ret(class.UAllType)
	if self:isValueType(vData) then
		return vData
	else
		error("assertValueType failed, type="..type(vData)..tostring(debug.traceback()))
	end
end

function TypeManager:_toType(vData)::Ret(class.UAtomUnion)
	local t = type(vData)
	if t == "table" then
		local meta = getmetatable(vData)
		if tableToTypeFuncDict[meta] then
			return vData
		else
			error("to type failed")
		end
	elseif t == "number" or t == "string" then
		return self:Literal(vData)
	else
		error("_toType("..t..") todo")
	end
end

function TypeManager:TypeCollection()::Ret(class.TypeCollection)
	return TypeCollection.new(self)
end

function TypeManager:buildIntersect(vNode:class.AstNode, ...:Union(class.Reference, class.MetaObject))::Ret(class.MetaObject)
	local l = {...}
	local nKeyRefer = self:Reference(false)
	local nNewStruct = MetaObject.new(self, nKeyRefer)
	nKeyRefer:setRawAsync(vNode, function()
		local nTypeList:List(class.IAtomType) = {}
		local nAllValueDict = {}
		local nIntersectSet:Dict(class.MetaObject, True) = {}
		for i=1,#l do
			local nMetaObject = l[i]!
			if Reference.is(nMetaObject) then
				nMetaObject = nMetaObject:getTypeAwait()
			end
			if not MetaObject.is(nMetaObject) then
				error("intersect can only take interface")
				break
			end
			nIntersectSet[nMetaObject] = true
			local nValueDict = nMetaObject:getValueDict()
			nMetaObject:getKeyRefer():foreachAwait(function(vKeyType)
				nTypeList[#nTypeList + 1] = vKeyType
				nAllValueDict[vKeyType] = nValueDict[vKeyType]
			end)
		end
		nNewStruct:init(nAllValueDict, false, nIntersectSet)
		return nTypeList
	end, function(vTypeList)
		local nCollection = self:TypeCollection()
		for _, v in ipairs(vTypeList) do
			nCollection:put(v)
		end
		return nCollection:mergeToAtomUnion()
	end)
	return nNewStruct
end

function TypeManager:checkedUnion(...:Truth)::Ret(class.Reference)
	return self:buildUnion(self._runtime:getNode(), ...)
end

function TypeManager:buildUnion(vNode:class.AstNode, ...:Truth)::Ret(class.Reference)
	local l = {...}
	local nNewRefer = self:Reference(false)
	nNewRefer:setRawAsync(vNode, function()
		local nTypeList:List(class.IAtomType) = {}
		for i=1, #l do
			local nItem = l[i]
			if Reference.is(nItem) then
				local nList = nItem:getListAwait()
				table.move(nList, 1, #nList, #nTypeList + 1, nTypeList)
			else
				local nType = self:_toType(nItem)
				nType:foreachAwait(function(vAtomType)
					nTypeList[#nTypeList + 1] = vAtomType
				end)
			end
		end
		return nTypeList
	end, function(vTypeList)
		local nCollection = self:TypeCollection()
		for _, v in ipairs(vTypeList) do
			nCollection:put(v)
		end
		return nCollection:mergeToAtomUnion()
	end)
	return nNewRefer
end

function TypeManager:buildInterface(vNode:class.AstNode, vTable:Dict(Truth,Truth), vNext:Boolean)::Ret(class.MetaObject)
	return self:buildStruct(vNode, vTable, vNext)
end

function TypeManager:buildStruct(vNode:class.AstNode, vTable:Dict(Truth,Truth), vNext:Boolean)::Ret(class.MetaObject)
	local nKeyRefer = self:Reference(false)
	local nNewStruct = MetaObject.new(self, nKeyRefer)
	nKeyRefer:setRawAsync(vNode, function()
		local nTypeList:List(class.IAtomType) = {}
		local nValueDict:Dict(class.UAtomUnion, Union(class.UAllType, class.MemberFunction)) = {}
		for nKey, nValue in pairs(vTable) do
			local nValueType
			if Reference.is(nValue) then
				nValueType = nValue
			elseif MemberFunction.is(nValue) then
				nValueType = nValue
			else
				nValueType = self:_toType(nValue)
			end
			if not Reference.is(nKey) then
				nKey = self:_toType(nKey)
			end
			nKey:foreachAwait(function(vAtomType)
				nTypeList[#nTypeList + 1] = vAtomType
				if vAtomType:isSingleton() then
					nValueDict[vAtomType] = nValueType
				else
					nValueDict[vAtomType] = self:buildUnion(vNode, nValueType, self.type.Nil)
				end
			end)
		end
		nNewStruct:init(nValueDict, true)
		return nTypeList
	end, function(vTypeList)
		local nCollection = self:TypeCollection()
		for _, v in ipairs(vTypeList) do
			nCollection:put(v)
		end
		return nCollection:mergeToAtomUnion()
	end)
	return self:_recordTypeUnionSign(nNewStruct)
end

function TypeManager:buildDict(vNode:class.AstNode, vKey:class.UAtomUnion, vValue:class.UAllType)::Ret(Union(class.MetaObject, class.Reference))
	return self:buildStruct(vNode, {[vKey]=vValue}, true)
end

function TypeManager:buildList(vNode:class.AstNode, vValue)::Ret(class.MetaObject)
	-- TODO struct use meta
	return self:buildStruct(vNode, {[self.type.Number]=vValue}, true)
end

function TypeManager:buildOption(vNode:class.AstNode, vValue)::Ret(class.Reference)
	return self:buildUnion(vNode, vValue, self.type.Nil)
end

function TypeManager:_unifyUnion(vNewType:class.UAtomUnion)::Ret(class.UAtomUnion)
	local nSign = vNewType:unionSign()
	local nSignToType = self._unionSignToType
	local nOldType = nSignToType[nSign]
	if not nOldType then
		assert(vNewType.id == 0, "newunion's id must be 0")
		vNewType.id = self:genTypeId()
		nSignToType[nSign] = vNewType
		return vNewType
	else
		return nOldType
	end
end

function TypeManager:mergePairList(vTypeBorablePairList)::Ret(class.UAtomUnion, Dict(class.IAtomType, class.UAllType))
	local nTypeToBorable = {}
	local nCollection = self:TypeCollection()
	for _, nPair in ipairs(vTypeBorablePairList) do
		local nFieldType = nPair[1]
		if nFieldType:isReference() then
			nFieldType = nFieldType:checkAtomUnion()
			nPair[1] = nFieldType
		end
		nCollection:put(nFieldType)
	end
	local nKeyUnion = nCollection:mergeToAtomUnion()
	local nTypeDict = {}
	for _, nPair in ipairs(vTypeBorablePairList) do
		local nKey = nPair[1]
		local nBorableValue = nPair[2]
		nKey:foreach(function(vSubType)
			local nContainType = assert(nKeyUnion:containAtom(vSubType), "merge error")
			local nOld = nTypeDict[nContainType]
			if nOld then
				nTypeDict[nContainType] = nOld | nBorableValue
			else
				nTypeDict[nContainType] = nBorableValue
			end
		end)
	end
	return nKeyUnion, nTypeDict
end

function TypeManager:_recordTypeUnionSign(vType:class.UAtomUnion)::Ret(class.UAtomUnion)
	self._unionSignToType[vType:unionSign()] = vType
	return vType
end

function TypeManager:NativeFunction(vFunc:class.GenFuncNative)::Ret(class.NativeFunction)
	return self:_recordTypeUnionSign(NativeFunction.new(self, vFunc))
end

function TypeManager:LuaFunction()::Ret(class.LuaFunction)
	return self:_recordTypeUnionSign(LuaFunction.new(self))
end

function TypeManager:LuaTable()::Ret(class.LuaTable)
	return self:_recordTypeUnionSign(LuaTable.new(self))
end

function TypeManager:Boolean(vValue)::Ret(class.BooleanLiteral)
	if vValue then
		return self.type.True
	else
		return self.type.False
	end
end

function TypeManager:Literal(vValue:Union(String, Number))::Ret(class.NumberLiteral):Ret(class.StringLiteral)
	local t = type(vValue)
	local nLiteralDict = self._literalDict
	local nLiteralType = nLiteralDict[vValue]
	if not nLiteralType then
		if t == "number" then
			nLiteralType = NumberLiteral.new(self, vValue)
		elseif t == "string" then
			nLiteralType = StringLiteral.new(self, vValue)
		else
			error("literal must take number or string value"..t)
		end
		self:_recordTypeUnionSign(nLiteralType)
		nLiteralDict[vValue] = nLiteralType
	end
	return nLiteralType
end

function TypeManager:Tuple(...:Truth)::Ret(class.TypeTuple)
	local nTypeList:List(class.UAllType) = {}
	for i=1, select("#", ...) do
		local nArg = select(i, ...)
		if Reference.is(nArg) then
			nTypeList[i] = nArg
		else
			nTypeList[i] = self:assertValueType(nArg)
		end
	end
	return TypeTuple.new(self, nTypeList)
end

function TypeManager:Variable(vIsGeneric:Boolean)::Ret(class.Variable)
	return Variable.new(self, vIsGeneric)
end

function TypeManager:VoidRetTuples()::Ret(class.RetTuples)
	return self:SingleRetTuples(self:Tuple())
end

function TypeManager:SingleRetTuples(vTypeTuple:class.TypeTuple)::Ret(class.RetTuples)
	local nRetTuples = RetTuples.new(self)
	return nRetTuples:Add(vTypeTuple)
end

function TypeManager:buildMfn(vNode:class.AstNode, ...:Truth)::Ret(class.MemberFunction)
	local nArgTuple = self:Tuple(self.type.Truth, ...)
	return MemberFunction.new(self, nArgTuple, false)
end

function TypeManager:buildFn(vNode:class.AstNode, ...:Truth)::Ret(class.TypeFunction)
	local nArgTuple = self:Tuple(...)
	return TypeFunction.new(self, nArgTuple, false, false)
end

function TypeManager:checkedFn(...:Truth)::Ret(class.TypeFunction)
	local nArgTuple = self:Tuple(...)
	return TypeFunction.new(self, nArgTuple, false, false)
end

function TypeManager:Function(vArgTuple:class.UTypeTuple, vRetTuples:class.RetTuples)::Ret(class.TypeFunction)
	assert(TypeTuple.is(vArgTuple) or TypeTupleDots.is(vArgTuple))
	assert(RetTuples.is(vRetTuples))
	local nFunc = TypeFunction.new(self, vArgTuple, vRetTuples, false)
	return nFunc
end

function TypeManager:RefineTerm(vType:class.UAllType)::Ret(class.RefineTerm)
	local nType = vType:checkAtomUnion()
	nType:foreach(function(vSubType)
		if LuaTable.is(vSubType) then
			vSubType:checkDefine()
		end
	end)
	return RefineTerm.new(self, nType)
end

function TypeManager:TermTuple(vTermList:List(class.RefineTerm), vTermTupleOrNil:Option(class.TermTuple))::Ret(class.TermTuple)
	local nTermList:List(class.RefineTerm) = {}
	local nTypeList:List(class.UAtomUnion) = {}
	for _, nTerm in ipairs(vTermList) do
		local i = #nTermList + 1
		nTermList[i] = nTerm
		nTypeList[i] = nTerm:getType()
	end
	local nRepeatType = false
	if vTermTupleOrNil then
		for i1=1, #vTermTupleOrNil do
			local nTerm = vTermTupleOrNil:get(i1)
			local i2 = #nTermList + 1
			nTermList[i2] = nTerm
			nTypeList[i2] = nTerm:getType()
		end
		nRepeatType = vTermTupleOrNil:getRepeatType()
	end
	local nTypeTuple = self:Tuple(table.unpack(nTypeList))
	if nRepeatType then
		nTypeTuple = nTypeTuple:Dots(nRepeatType)
	end
	return TermTuple.new(self, nTermList, nTypeTuple)
end

function TypeManager:Reference(vName:Union(String, False))::Ret(class.Reference)
	return Reference.new(self, vName)
end

function TypeManager:mergeToRefineTerm(vTypeCasePairList:List(class.TypeCasePair))::Ret(class.RefineTerm)
	local nType, nTypeToCase = self:mergePairList(vTypeCasePairList)
	return RefineTerm.new(self, nType, nTypeToCase)
end

function TypeManager:fork(vFunc)
	local nNode = self._runtime:getNode()
	local co, _ = coroutine.running()
	local nCurRefer = self.coToRefer[co]
	if nCurRefer then
		nNode = nCurRefer:getSetNode() or nNode
	end
	local nNewRefer = self:Reference(false)
	nNewRefer:setRawAsync(nNode, function()
		vFunc()
		return {}
	end, function(vTypeList)
		return self.type.Never
	end)
end

function TypeManager:attachObjPairContain(vLeft:class.MetaObject, vRight:class.MetaObject)::Ret(Integer, class.Reference)
	local nPair = (vLeft.id << 32) + vRight.id
	local nContainRefer = self._pairToContain[nPair]
	if not nContainRefer then
		nContainRefer = self:Reference(false)
		self._pairToContain[nPair] = nContainRefer
		self:fork(function()
			local nContain = vLeft:assumeContainObject({[nPair]=true}, vRight)
			self:setContainByPair(nPair, nContain)
		end)
	end
	return nPair, nContainRefer
end

function TypeManager:attachFnPairContain(vLeft:class.TypeFunction, vRight:class.TypeFunction)::Ret(Integer, class.Reference)
	local nPair = (vLeft.id << 32) + vRight.id
	local nContainRefer = self._pairToContain[nPair]
	if not nContainRefer then
		nContainRefer = self:Reference(false)
		self._pairToContain[nPair] = nContainRefer
		self:fork(function()
			local nContain = vLeft:assumeContainFn({[nPair]=true}, vRight)
			self:setContainByPair(nPair, nContain)
		end)
	end
	return nPair, nContainRefer
end

function TypeManager:setContainByPair(vPair:Integer, vContain:Boolean)
	local nContainRefer = self._pairToContain[vPair]!
	local nCurType = nContainRefer:getType()
	local nAssignType = vContain and self.type.True or self.type.False
	if not nCurType then
		nContainRefer:setTypeAsync(self._runtime:getNode(), nAssignType)
	else
		assert(nAssignType == nCurType, "contain set conflict")
	end
end

function TypeManager:getRuntime()::Ret(class.Runtime)
	return self._runtime
end

function TypeManager:genTypeId()::Ret(Number)
	local nNewId = self._typeIdCounter + 1
	self._typeIdCounter = nNewId
	return nNewId
end

function TypeManager:dump()
	for k,v in pairs(self._unionSignToType) do
		print(k, tostring(v))
	end
end

return TypeManager
