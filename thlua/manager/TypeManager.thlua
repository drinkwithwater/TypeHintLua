
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const TypeCollection = require "thlua.manager.TypeCollection"
const Node = require "thlua.code.Node"
const Exception = require "thlua.Exception"

const Never = require "thlua.union.Never"
const StringLiteral = require "thlua.type.StringLiteral"
const String = require "thlua.type.String"
const NumberLiteral = require "thlua.type.NumberLiteral"
const Number = require "thlua.type.Number"
const BooleanLiteral= require "thlua.type.BooleanLiteral"
const Nil = require "thlua.type.Nil"
const Thread = require "thlua.type.Thread"
const Truth = require "thlua.type.Truth"
const TypedObject = require "thlua.object.TypedObject"
const Struct = require "thlua.object.Struct"
const Interface = require "thlua.object.Interface"
const OpenTable = require "thlua.object.OpenTable"
const AutoTable = require "thlua.object.AutoTable"
const SealTable = require "thlua.object.SealTable"
const OpenFunction = require "thlua.func.OpenFunction"
const TypedFunction = require "thlua.func.TypedFunction"
const PolyFunction = require "thlua.func.PolyFunction"
const AnyFunction = require "thlua.func.AnyFunction"
const Reference = require "thlua.refer.Reference"

const MemberFunction = require "thlua.func.MemberFunction"
const AutoMemberFunction = require "thlua.func.AutoMemberFunction"
const TypedMemberFunction = require "thlua.func.TypedMemberFunction"

const StringLiteralUnion = require "thlua.union.StringLiteralUnion"
const NumberLiteralUnion = require "thlua.union.NumberLiteralUnion"
const ObjectUnion = require "thlua.union.ObjectUnion"
const FuncUnion = require "thlua.union.FuncUnion"
const FalsableUnion = require "thlua.union.FalsableUnion"
const ComplexUnion = require "thlua.union.ComplexUnion"

const RetTuples = require "thlua.tuple.RetTuples"
const TypeTuple = require "thlua.tuple.TypeTuple"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"
const ScheduleEvent = require "thlua.manager.ScheduleEvent"

const BaseReadyType = require "thlua.type.BaseReadyType"
const BaseAtomType = require "thlua.type.BaseAtomType"
const BaseUnionType = require "thlua.union.BaseUnionType"
const MetaEventCom = require "thlua.object.MetaEventCom"
const native = require "thlua.native"

const UnionReferCom = require "thlua.refer.UnionReferCom"

const TypeRelation = require "thlua.manager.TypeRelation"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.WaitingInfo = Struct {
		waitSid = Integer,
		dependCo = Thread,
	}
end)

const TypeManager = {}
TypeManager.__index=TypeManager

const function:class(let.BuiltinFunc) makeBuiltinFunc(vManager:clazz.TypeManager)
	const self = {.class
		string=native.make_string(vManager),
		next=native.make_next(vManager),
		inext=native.make_inext(vManager),
		bop={
			mathematic=native.make_mathematic(vManager),
			comparison=native.make_comparison(vManager),
			bitwise=native.make_bitwise(vManager),
			concat=native.make_concat(vManager),
		},
	}
	return self
end

function:class(clazz.TypeManager) TypeManager.new(
	vRuntime:clazz.BaseRuntime,
	vRootNode:clazz.IAstNode,
	vScheduleManager:clazz.ScheduleManager
)
	const function:class(let.BuiltinType) makeBuiltinType(vManager:clazz.TypeManager)
		const self = {.class
			Never = vManager:_unifyUnion(Never.new(vManager)),
			Nil = Nil.new(vManager),
			False = BooleanLiteral.new(vManager, false),
			True = BooleanLiteral.new(vManager, true),
			Thread = Thread.new(vManager),
			Number = Number.new(vManager),
			String = String.new(vManager),
			Truth = Truth.new(vManager),
			AnyFunction = AnyFunction.new(vManager),
			Boolean = nil @! clazz.TypeReference,
			Any = nil @! clazz.TypeReference,
			AnyObject = nil @! clazz.Interface,
		}
		self.Integer = self.Number
		return self
	end
	const self = setmetatable({.class
		_runtime=vRuntime,
		-- type items
		type=nil @! BuiltinType,
		builtin=nil @! BuiltinFunc,
		generic={} @ Dict(String, clazz.TypeReference),
		_pairToRelation={} @ Dict(Integer, clazz.TypeRelation),
		_literalDict={}@Struct {[Number]=clazz.NumberLiteral, [String]=clazz.StringLiteral, [Boolean]=OrNil(clazz.BooleanLiteral)},
		_unionSignToType=setmetatable({}, {__mode="v"}) @ Dict(String, clazz.UAtomUnion),
		_typeIdCounter=0@Integer,
		_rootNode=vRootNode,
		_scheduleManager=vScheduleManager,
	}, TypeManager)
	self.type = makeBuiltinType(self)
	self.type.Boolean = self:buildUnion(vRootNode, self.type.False, self.type.True)
	self.type.Any = self:buildUnion(vRootNode, self.type.False, self.type.Nil, self.type.Truth)
	self.type.AnyObject = self:buildInterface(vRootNode, {})
	self.generic.Dict = self:buildTemplate(vRootNode, function(vKey:clazz.UAllType,vValue:clazz.UAllType)
		assert(vKey and vValue, "key or value can't be nil when build Dict")
		return self:buildStruct(vRootNode, {[vKey]=vValue}, {__next=vKey})
	end)
	self.generic.Cond = self:buildTemplate(vRootNode, function(vCond:clazz.UAllType,v1:clazz.UAllType,v2:clazz.UAllType)
		local nType = vCond
		if Reference.is(vCond) then
			nType = vCond:waitTypeCom():getTypeAwait()
		end
		if nType:isUnion() then
			error("Cond's first value can't be union")
		end
		return (nType == self.type.Nil or nType == self.type.False) and v2 or v1
	end)
	self.generic.IDict = self:buildTemplate(vRootNode, function(vKey:clazz.UAllType,vValue:clazz.UAllType)
		assert(vKey and vValue, "key or value can't be nil when build IDict")
		return self:buildInterface(vRootNode, {[vKey]=vValue}, {__next=vKey})
	end)
	self.generic.List = self:buildTemplate(vRootNode, function(vValue:clazz.UAllType)
		assert(vValue, "value can't be nil when build List")
		return self:buildStruct(vRootNode, {[self.type.Integer]=vValue}, {__next=self.type.Integer, __len=self.type.Integer})
	end)
	self.generic.IList = self:buildTemplate(vRootNode, function(vValue:clazz.UAllType)
		assert(vValue, "value can't be nil when build IList")
		return self:buildInterface(vRootNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer})
	end)
	self.generic.KeyOf = self:buildTemplate(vRootNode, function(vOneType:clazz.UAllType)
		local nObject = vOneType
		if Reference.is(vOneType) then
			nObject = vOneType:waitTypeCom():getTypeAwait()
		end
		if not TypedObject.is(nObject) then
			error("key of can only worked on object function")
		end
		const nKeyRefer, _ = nObject:getKeyTypes()
		const nRefer = self:Reference(false)
		nRefer:setUnionAsync(nObject:getNode(), function()
			return nKeyRefer:getListAwait(), function()
				nKeyRefer:getTypeAwait()
			end
		end)
		return nRefer
	end)
	return self
end

function TypeManager:lateInit()
	self.builtin = makeBuiltinFunc(self)
end

function TypeManager:_checkAllType(vData:Any):Ret(OrFalse(clazz.UAllType))
	if Reference.is(vData) or BaseAtomType.is(vData) or BaseUnionType.is(vData) then
		return vData
	end
	return false
end

function.pass TypeManager:easyToTypeList(...:Any):Ret(List(clazz.UAllType))
	const l = {...}
	for i=1,#l do
		l[i] = self:easyToType(l[i])
	end
	return l
end

function TypeManager:peasyToType(vData:Any):Ret(False, String):Ret(True, clazz.UAllType)
	local t = type(vData)
	if t == "table" then
		if Reference.is(vData) or BaseAtomType.is(vData) or BaseUnionType.is(vData) then
			return true, vData
		else
			return false, "to type failed"
		end
	elseif t == "number" or t == "string" or t == "boolean"then
		return true, self:Literal(vData @> Union(Number, String, Boolean))
	else
		return false, "easyToType("..t..") invalid"
	end
end

function TypeManager:easyToType(vData:Any):Ret(clazz.UAllType)
	const nOkay, nType = self:peasyToType(vData)
	if nOkay then
		return nType
	else
		error(nType)
	end
end

function TypeManager:TypeCollection():Ret(clazz.TypeCollection)
	return TypeCollection.new(self)
end

function TypeManager:UnionReferCom(vNode:clazz.IAstNode, vTask:clazz.ScheduleTask):Ret(clazz.UnionReferCom)
	const nCom = UnionReferCom.new(self, vNode, vTask)
	return nCom
end

function TypeManager:_buildCombineObject(vNode:clazz.IAstNode, vIsInterface:Boolean, vObjectList:List(clazz.UAllType)):Ret(clazz.TypeReference)
	const nObjectRefer = self:Reference(false)
	nObjectRefer:setUnionAsync(vNode, function()
		if vIsInterface then
			assert(#vObjectList>=1, "Intersect must take at least one arguments")
		else
			assert(#vObjectList >= 2, "StructExtend must take at least one interface after struct")
		end
		const nKeyList:List(clazz.IAtomType) = {}
		const nKeyValuePairList:List(Struct {clazz.IAtomType, clazz.UAllType}) = {}
		const nIntersectSet:Dict(clazz.TypedObject, True) = {}
		const nMetaEventComList:List(clazz.MetaEventCom) = {}
		local nIntersectNextKey:OrFalse(clazz.UAllType) = self.type.Any
		for i=1,#vObjectList do
			local nTypedObject = vObjectList[i]!
			if Reference.is(nTypedObject) then
				nTypedObject = nTypedObject:waitTypeCom():getTypeAwait()
			end
			if not TypedObject.is(nTypedObject) then
				error("Interface or Struct is expected here")
				break
			end
			if i == 1 then
				if vIsInterface then
					assert(Interface.is(nTypedObject), "Intersect must take Interface")
					nIntersectSet[nTypedObject] = true
				else
					assert(not Interface.is(nTypedObject), "StructExtend must take Struct as first argument")
				end
			else
				assert(Interface.is(nTypedObject), vIsInterface
					and "Intersect must take Interface as args"
					or "StructExtend must take Interface after first argument")
				nIntersectSet[nTypedObject] = true
			end
			local nValueDict = nTypedObject:getValueDict()
			const nKeyRefer, nNextKey = nTypedObject:getKeyTypes()
			for _, nKeyType in ipairs(nKeyRefer:getListAwait()) do
				nKeyList[#nKeyList + 1] = nKeyType
				nKeyValuePairList[#nKeyValuePairList + 1] = {nKeyType, nValueDict[nKeyType]!}
			end
			nMetaEventComList[#nMetaEventComList + 1] = nTypedObject:getMetaEventCom() or nil
			if nIntersectNextKey then
				if nNextKey then
					const nTypeOrFalse = nIntersectNextKey:safeIntersect(nNextKey)
					if not nTypeOrFalse then
						error("intersect error")
					else
						nIntersectNextKey = nTypeOrFalse
					end
				else
					nIntersectNextKey = false
				end
			end
		end
		const nNewObject = vIsInterface
			and Interface.new(self, vNode, nIntersectNextKey)
			or Struct.new(self, vNode, nIntersectNextKey)
		nNewObject:buildAsync(function(vAsyncKey)
			const _, nFinalValueDict = self:typeMapReduce@<clazz.UAllType>(nKeyValuePairList, function(vList)
				return self:intersectReduceType(vNode, vList)
			end)
			if #nMetaEventComList > 0 then
				const nNewEventCom = self:makeMetaEventCom(nNewObject)
				nNewEventCom:initByMerge(nMetaEventComList)
				nNewObject:lateInit(nIntersectSet, nFinalValueDict, nNewEventCom)
			else
				nNewObject:lateInit(nIntersectSet, nFinalValueDict, false)
			end
			const nKeyAtomUnion = vAsyncKey:setAtomList(nKeyList)
			-- TODO check key's count and intersect valid
			nNewObject:lateCheck()
		end)
		return {nNewObject}
	end)
	return nObjectRefer
end

function TypeManager:buildExtendStruct(vNode:clazz.IAstNode, vFirst:Union(Dict(Truth, Truth), clazz.UAllType),
	...:Union(clazz.TypeReference, clazz.TypedObject)):Ret(clazz.TypeReference)
	const nStruct = self:_checkAllType(vFirst) or self:buildStruct(vNode, vFirst @> Dict(Truth, Truth))
	const l:List(clazz.UAllType) = {nStruct, ...}
	return self:_buildCombineObject(vNode, false, l)
end

function TypeManager:buildExtendInterface(vNode:clazz.IAstNode, ...:Union(clazz.TypeReference, clazz.TypedObject)):Ret(clazz.TypeReference)
	const l:List(clazz.UAllType) = {...}
	return self:_buildCombineObject(vNode, true, l)
end

function TypeManager:checkedUnion(...:clazz.UAllType):Ret(clazz.UAtomUnion)
	const l:List(clazz.UAllType) = {...}
	const nCollection = self:TypeCollection()
	for i=1, select("#", ...) do
		l[i]!:checkAtomUnion():foreach(function(vAtomType)
			nCollection:put(vAtomType)
		end)
	end
	return nCollection:mergeToAtomUnion()
end

function TypeManager:buildUnion(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeReference)
	local l = {...}
	const nLen = select("#", ...)
	local nNewRefer = self:Reference(false)
	nNewRefer:setUnionAsync(vNode, function()
		local nTypeList:List(clazz.IAtomType) = {}
		for i=1, nLen do
			local nItem = l[i]
			if Reference.is(nItem) then
				local nList = nItem:waitTypeCom():getListAwait()
				table.move(nList, 1, #nList, #nTypeList + 1, nTypeList)
			else
				self:easyToType(nItem):foreachAwait(function(vAtom)
					nTypeList[#nTypeList + 1] = vAtom
				end)
			end
		end
		return nTypeList
	end)
	return nNewRefer
end

function TypeManager:buildInterface(vNode:clazz.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType))):Ret(clazz.Interface)
	return self:_buildTypedObject@<True>(vNode, vTable, vMetaEventDict, true)
end

function TypeManager:buildStruct(vNode:clazz.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType))):Ret(clazz.Struct)
	return self:_buildTypedObject@<False>(vNode, vTable, vMetaEventDict, false)
end

function TypeManager:_buildTypedObject@<IsInterface>(vNode:clazz.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType)), vIsInterface:IsInterface):Ret(Cond(IsInterface, clazz.Interface, clazz.Struct))
	const nNewObject = vIsInterface
	and Interface.new(self, vNode, vMetaEventDict and vMetaEventDict.__next or false)
	or Struct.new(self, vNode, vMetaEventDict and vMetaEventDict.__next or false)
	nNewObject:buildAsync(function(vAsyncKey)
		const nKeyList:List(clazz.IAtomType) = {}
		const nValueDict:Dict(clazz.IAtomType, clazz.UAllType) = {}
		for nKey, nValue in pairs(vTable) do
			local nValueType:OrNil(clazz.UAllType, clazz.MemberFunction) = nil
			if MemberFunction.is(nValue) then
				nValueType = nValue
			else
				nValueType = self:easyToType(nValue)
			end
			local nKeyType = self:easyToType(nKey)
			nKeyType:foreachAwait(function(vAtomType)
				nKeyList[#nKeyList + 1] = vAtomType
				if vAtomType:isSingleton() then
					nValueDict[vAtomType] = nValueType
				else
					assert(nValueType and not MemberFunction.is(nValueType), "valuetype with non-singleton key can't be nil or MemberFunction")
					nValueDict[vAtomType] = self:buildUnion(vNode, nValueType, self.type.Nil)
				end
			end)
		end
		if vMetaEventDict then
			const nNewEventCom = self:makeMetaEventCom(nNewObject)
			nNewEventCom:initByEventDict(vMetaEventDict)
			nNewObject:lateInit({}, nValueDict, nNewEventCom)
		else
			nNewObject:lateInit({}, nValueDict, false)
		end
		const nKeyAtomUnion = vAsyncKey:setAtomList(nKeyList)
		nNewObject:lateCheck()
		local nFinalCount = 0
		nKeyAtomUnion:foreach(function(_)
			nFinalCount = nFinalCount + 1
		end)
		if nFinalCount ~= #nKeyList then
			error("Object's key can not has intersect part")
		end
	end)
	return nNewObject
end

function TypeManager:buildIDict(vNode:clazz.IAstNode, vKey:clazz.UAtomUnion, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildInterface(vNode, {[vKey]=vValue})
end

function TypeManager:buildDict(vNode:clazz.IAstNode, vKey:clazz.UAtomUnion, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildStruct(vNode, {[vKey]=vValue}, {__next=vKey})
end

function TypeManager:buildIList(vNode:clazz.IAstNode, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildInterface(vNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer})
end

function TypeManager:buildList(vNode:clazz.IAstNode, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildStruct(vNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer, __next=self.type.Integer})
end

function TypeManager:buildOrNil(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeReference)
	return self:buildUnion(vNode, self.type.Nil, ...)
end

function TypeManager:buildOrFalse(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeReference)
	return self:buildUnion(vNode, self.type.False, ...)
end

function TypeManager:_unifyUnion(vNewType:clazz.IUnionType):Ret(clazz.UAtomUnion)
	local nSign = vNewType:unionSign()
	local nSignToType = self._unionSignToType
	local nOldType = nSignToType[nSign]
	if not nOldType then
		vNewType:initWithTypeId(self:genTypeId())
		nSignToType[nSign] = vNewType
		return vNewType
	else
		return nOldType
	end
end

function TypeManager:atomRecordTypeUnionSign(vType:clazz.BaseAtomType)
	self._unionSignToType[tostring(vType.id)] = vType
end

function TypeManager:metaNativeOpenFunction(vFn):Ret(clazz.OpenFunction)
	const nOpenFn = self._runtime:getRootStack():newOpenFunction(self._rootNode)
	nOpenFn:lateInitFromMetaNative(vFn)
	return nOpenFn
end

function TypeManager:fixedNativeOpenFunction(vFn):Ret(clazz.OpenFunction)
	const nOpenFn = self._runtime:getRootStack():newOpenFunction(self._rootNode)
	nOpenFn:lateInitFromOperNative(vFn)
	return nOpenFn
end

function TypeManager:stackNativeOpenFunction(vFn):Ret(clazz.OpenFunction)
	const nOpenFn = self._runtime:getRootStack():newOpenFunction(self._rootNode)
	nOpenFn:lateInitFromAutoNative(vFn)
	return nOpenFn
end

function TypeManager:Literal(vValue:Union(String, Number, Boolean)):Ret(Union(clazz.NumberLiteral, clazz.StringLiteral, clazz.BooleanLiteral))
	const nLiteralDict = self._literalDict
	local nLiteralType = nLiteralDict[vValue]
	if not nLiteralType then
		const t = type(vValue)
		if t == "number" then
			nLiteralType = NumberLiteral.new(self, vValue)
			nLiteralDict[vValue] = nLiteralType
		elseif t == "string" then
			nLiteralType = StringLiteral.new(self, vValue)
			nLiteralDict[vValue] = nLiteralType
		elseif t == "boolean" then
			if vValue then
				nLiteralType = self.type.True
			else
				nLiteralType = self.type.False
			end
			nLiteralDict[vValue] = nLiteralType
		else
			error("literal must take number or string value"..t)
		end
	end
	return nLiteralType
end

function TypeManager:TypeTuple(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeTuple)
	local nTypeList:List(clazz.UAllType) = {}
	for i=1, select("#", ...) do
		local nArg = select(i, ...)
		assert(nArg, "tuple can't take false or nil value")
		if Reference.is(nArg) then
			nTypeList[i] = nArg
		elseif BaseUnionType.is(nArg) or BaseAtomType.is(nArg) then
			nTypeList[i] = nArg
		else
			error("type expected here...")
		end
	end
	return TypeTuple.new(self, vNode, nTypeList)
end

function TypeManager:VoidRetTuples(vNode:clazz.IAstNode):Ret(clazz.RetTuples)
	return RetTuples.new(self, vNode, {self:TypeTuple(self._rootNode)})
end

function TypeManager:SingleRetTuples(vNode:clazz.IAstNode, vTypeTuple:clazz.UTypeTuple):Ret(clazz.RetTuples)
	return RetTuples.new(self, vNode, {vTypeTuple})
end

function TypeManager:buildMfn(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypedMemberFunction)
	const nWildFn = self:buildFn(vNode, self.type.Truth, ...)
	return TypedMemberFunction.new(self, vNode, nWildFn)
end

function TypeManager:buildPfn(vNode:clazz.IAstNode, vFunc:AnyFunction):Ret(clazz.PolyFunction)
	const nInfo = debug.getinfo(vFunc)
	const nPolyParNum=nInfo.nparams
	if nInfo.isvararg then
		error("poly function can't be vararg")
	end
	return PolyFunction.new(self, vNode, vFunc, nPolyParNum)
end

function TypeManager:buildFn(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypedFunction)
	local nParTuple = self:TypeTuple(vNode, ...)
	return TypedFunction.new(self, vNode, nParTuple, false)
end

function TypeManager:checkedFn(...:Truth):Ret(clazz.TypedFunction)
	local nParTuple = self:TypeTuple(self._rootNode, ...)
	return TypedFunction.new(self, self._rootNode, nParTuple, false)
end

function TypeManager:PolyFunction(vNode:clazz.IAstNode, vFunc:AnyFunction, vPolyParNum:Integer, vStack:OrNil(clazz.BaseStack)):Ret(clazz.PolyFunction)
	return PolyFunction.new(self, vNode, vFunc, vPolyParNum, vStack)
end

function TypeManager:AutoMemberFunction(vNode:clazz.IAstNode, vPolyFn:clazz.PolyFunction):Ret(clazz.AutoMemberFunction)
	return AutoMemberFunction.new(self, vNode, vPolyFn)
end

function TypeManager:TypedFunction(vNode:clazz.IAstNode, vParTuple:clazz.UTypeTuple, vRetTuples:clazz.RetTuples):Ret(clazz.TypedFunction)
	assert(TypeTuple.is(vParTuple) or TypeTupleDots.is(vParTuple))
	assert(RetTuples.is(vRetTuples))
	return TypedFunction.new(self, vNode, vParTuple, vRetTuples)
end

function TypeManager:makeMetaEventCom(vObject:Union(clazz.SealTable, clazz.TypedObject)):Ret(clazz.MetaEventCom)
	return MetaEventCom.new(self, vObject)
end

function TypeManager:buildTemplate(vNode:clazz.IAstNode, vFunc:AnyFunction):Ret(clazz.TypeReference)
	const nInfo = debug.getinfo(vFunc)
	const nParNum = nInfo.nparams
	if nInfo.isvararg then
		error("template's parameter number is undetermined")
	end
	return self:buildTemplateWithParNum(vNode, vFunc, nParNum)
end

function TypeManager:buildTemplateWithParNum(vNode:clazz.IAstNode, vFunc:AnyFunction, vParNum:Integer):Ret(clazz.TypeReference)
	const nRefer = self:Reference(false)
	nRefer:setTemplateAsync(vNode, vFunc, vParNum)
	return nRefer
end

function TypeManager:Reference(vName:Union(String, False)):Ret(clazz.TypeReference)
	const nRefer = Reference.new(self, vName)
	return nRefer
end

function TypeManager:typeMapReduce@<TValue>(
	vTypePairList:IList(Interface {clazz.UAtomUnion, TValue}),
	vReduceFn:Fn(IList(TValue)):Ret(TValue)
):Ret(clazz.UAtomUnion, Dict(clazz.IAtomType, TValue))
	const nCollection = self:TypeCollection()
	for _, nPair in ipairs(vTypePairList) do
		local nFieldType = nPair[1]
		if nFieldType:isReference() then
			nFieldType = nFieldType:checkAtomUnion()
			nPair[1] = nFieldType
		end
		nCollection:put(nFieldType)
	end
	const nKeyUnion = nCollection:mergeToAtomUnion()
	-- step 1: map
	const nTypeToList:Dict(clazz.IAtomType, List(TValue)) = {}
	for _, nPair in ipairs(vTypePairList) do
		local nKey = nPair[1]
		local nValueType = nPair[2]
		nKey:foreach(function(vSubType)
			const nIncludeType = assert(nKeyUnion:includeAtom(vSubType), "merge error")
			const nList = nTypeToList[nIncludeType]
			if not nList then
				nTypeToList[nIncludeType] = {nValueType}
			else
				nList[#nList + 1] = nValueType
			end
		end)
	end
	-- step 2: reduce
	const nTypeDict:Dict(clazz.IAtomType, TValue) = {}
	for k,v in pairs(nTypeToList) do
		nTypeDict[k] = vReduceFn(v)
	end
	return nKeyUnion, nTypeDict
end

function TypeManager:unionReduceType(vList:IList(clazz.UAtomUnion)):Ret(clazz.UAtomUnion)
	if #vList == 1 then
		return vList[1]!
	end
	const nCollection = self:TypeCollection()
	for _, nType in ipairs(vList) do
		nType:foreach(function(vAtomType)
			nCollection:put(vAtomType)
		end)
	end
	return nCollection:mergeToAtomUnion()
end

function TypeManager:intersectReduceType(vNode:clazz.IAstNode, vList:IList(clazz.UAllType)):Ret(clazz.UAllType)
	const nFirst = vList[1]!
	if #vList == 1 then
		return nFirst
	end
	const nRefer = self:Reference(false)
	nRefer:setUnionAsync(vNode, function()
		local nFinalType = nFirst:checkAtomUnion()
		for i=2, #vList do
			const nCurType = vList[i]!
			const nInterType = nFinalType:safeIntersect(nCurType)
			if not nInterType then
				error("unexpected intersect")
			else
				nFinalType = nInterType
			end
		end
		const nAtomList:List(clazz.IAtomType) = {}
		nFinalType:foreach(function(vAtomType)
			nAtomList[#nAtomList + 1] = vAtomType
		end)
		if nFinalType:isNever() then
			error("object intersect can't has never field")
		end
		return nAtomList, function()
			return nFinalType
		end
	end)
	return nRefer
end

function TypeManager:makePair(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(Integer)
	const nLeftId, nRightId = vLeft.id, vRight.id
	assert(nLeftId ~= 0 and nRightId ~=0, "use id ==0")
	return TypeRelation.shiftPair(nLeftId, nRightId)
end

function TypeManager:makeDuPair(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(Boolean, Integer, Integer)
	const nLeftId, nRightId = vLeft.id, vRight.id
	if nLeftId < nRightId then
		return false, TypeRelation.shiftPair(nLeftId, nRightId), TypeRelation.shiftPair(nRightId, nLeftId)
	else
		return true, TypeRelation.shiftPair(nRightId, nLeftId), TypeRelation.shiftPair(nLeftId, nRightId)
	end
end

function TypeManager:attachPairRelation(vLeft:clazz.TypedObject, vRight:clazz.TypedObject, vWaitCreate:Boolean):Ret(OrNil(clazz.RelationEnum))
	const nInverse, nLRPair, nRLPair = self:makeDuPair(vLeft, vRight)
	if nInverse then
		vRight, vLeft = vLeft, vRight
	end
	local nRelation = self._pairToRelation[nLRPair]
	local nResult:OrFalse(clazz.RelationEnum) = false
	if vWaitCreate then
		if not nRelation then
			nRelation = TypeRelation.new(self)
			self._pairToRelation[nLRPair] = nRelation
			nRelation:buildByObject(vLeft, vRight)
		end
		nResult = nRelation:getAwait()
	else
		if nRelation then
			nResult = nRelation:getNoAwait()
		end
	end
	if not nResult then
		return nil
	end
	if nInverse then
		if nResult == ">" then
			return "<"
		elseif nResult == "<" then
			return ">"
		else
			return nResult
		end
	else
		return nResult
	end
end

function TypeManager:getRuntime():Ret(clazz.BaseRuntime)
	return self._runtime
end

function TypeManager:literal2Primitive(vType:clazz.UAtomUnion):Ret(clazz.UAtomUnion)
	if BooleanLiteral.is(vType) then
		return self.type.Boolean:checkAtomUnion()
	elseif NumberLiteral.is(vType) then
		return self.type.Number
	elseif StringLiteral.is(vType) then
		return self.type.String
	else
		return vType
	end
end

function TypeManager:signTemplateArgs(vTypeList:IList(clazz.UAllType)):Ret(String)
	const nIdList:List(Integer) = {}
	for i=1,#vTypeList do
		nIdList[i] = vTypeList[i]!.id
	end
	return table.concat(nIdList, "-")
end

function TypeManager:genTypeId():Ret(Integer)
	local nNewId = self._typeIdCounter + 1
	self._typeIdCounter = nNewId
	return nNewId
end

function TypeManager:dump()
	for k,v in pairs(self._unionSignToType) do
		print(k, tostring(v))
	end
end

function TypeManager:getScheduleManager():Ret(clazz.ScheduleManager)
	return self._scheduleManager
end

return TypeManager
