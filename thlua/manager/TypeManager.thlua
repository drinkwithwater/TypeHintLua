
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const TypeCollection = require "thlua.manager.TypeCollection"
const Node = require "thlua.code.Node"
const Exception = require "thlua.Exception"

const Never = require "thlua.type.union.Never"
const StringLiteral = require "thlua.type.basic.StringLiteral"
const String = require "thlua.type.basic.String"
const FloatLiteral = require "thlua.type.basic.FloatLiteral"
const Number = require "thlua.type.basic.Number"
const IntegerLiteral = require "thlua.type.basic.IntegerLiteral"
const Integer = require "thlua.type.basic.Integer"
const BooleanLiteral= require "thlua.type.basic.BooleanLiteral"
const Nil = require "thlua.type.basic.Nil"
const Thread = require "thlua.type.basic.Thread"
const Enum = require "thlua.type.basic.Enum"
const LightUserdata = require "thlua.type.basic.LightUserdata"
const Truth = require "thlua.type.basic.Truth"
const TypedObject = require "thlua.type.object.TypedObject"
const Struct = require "thlua.type.object.Struct"
const Interface = require "thlua.type.object.Interface"
const OpenTable = require "thlua.type.object.OpenTable"
const AutoTable = require "thlua.type.object.AutoTable"
const SealTable = require "thlua.type.object.SealTable"
const OpenFunction = require "thlua.type.func.OpenFunction"
const TypedFunction = require "thlua.type.func.TypedFunction"
const TypedPolyFunction = require "thlua.type.func.TypedPolyFunction"
const SealPolyFunction = require "thlua.type.func.SealPolyFunction"
const AnyFunction = require "thlua.type.func.AnyFunction"
const Reference = require "thlua.refer.Reference"

const MemberFunction = require "thlua.type.func.MemberFunction"
const AutoMemberFunction = require "thlua.type.func.AutoMemberFunction"
const TypedMemberFunction = require "thlua.type.func.TypedMemberFunction"

const StringLiteralUnion = require "thlua.type.union.StringLiteralUnion"
const MixingNumberUnion = require "thlua.type.union.MixingNumberUnion"
const ObjectUnion = require "thlua.type.union.ObjectUnion"
const FuncUnion = require "thlua.type.union.FuncUnion"
const FalsableUnion = require "thlua.type.union.FalsableUnion"
const ComplexUnion = require "thlua.type.union.ComplexUnion"

const RetTuples = require "thlua.tuple.RetTuples"
const TypeTuple = require "thlua.tuple.TypeTuple"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"
const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const DirtyProcessor = require "thlua.manager.DirtyProcessor"

const BaseReadyType = require "thlua.type.basic.BaseReadyType"
const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const BaseUnionType = require "thlua.type.union.BaseUnionType"
const MetaEventCom = require "thlua.type.object.MetaEventCom"
const native = require "thlua.native"

const AsyncUnion = require "thlua.refer.AsyncUnion"

const TypeRelation = require "thlua.manager.TypeRelation"

(@do
	let.clazz = import("thlua.class").clazz
	let.WaitingInfo = Struct {
		waitSid = Integer,
		dependCo = Thread,
	}
end)

const TypeManager = {}
TypeManager.__index=TypeManager

const function:class(let.BuiltinFunc) makeBuiltinFunc(vManager:clazz.TypeManager)
	const self = {.class
		string=nil@!clazz.IAtomType,
		next=native.make_next(vManager),
		inext=native.make_inext(vManager),
		bop={
			mathematic_notdiv=native.make_mathematic(vManager),
			mathematic_divide=native.make_mathematic(vManager, true),
			comparison=native.make_comparison(vManager),
			bitwise=native.make_bitwise(vManager),
			concat=native.make_concat(vManager),
		},
	}
	return self
end

function:class(clazz.TypeManager) TypeManager.new(
	vRuntime:clazz.BaseRuntime,
	vRootNode:clazz.IBaseNode,
	vScheduleManager:clazz.ScheduleManager
)
	const function:class(let.BuiltinType) makeBuiltinType(vManager:clazz.TypeManager)
		const self = {.class
			Never = vManager:_unifyUnion(Never.new(vManager)),
			Nil = Nil.new(vManager),
			False = BooleanLiteral.new(vManager, false),
			True = BooleanLiteral.new(vManager, true),
			Thread = Thread.new(vManager),
			Number = Number.new(vManager),
			Integer = Integer.new(vManager),
			String = String.new(vManager),
			Truth = Truth.new(vManager),
			LightUserdata = LightUserdata.new(vManager),
			AnyFunction = AnyFunction.new(vManager, vRootNode),
			Boolean = nil @! clazz.TypeReference,
			Any = nil @! clazz.TypeReference,
			AnyObject = nil @! clazz.Interface,
		}
		return self
	end
	const self = setmetatable({.class
		_runtime=vRuntime,
		-- type items
		type=nil @! BuiltinType,
		builtin=nil @! BuiltinFunc,
		generic={} @ Dict(String, clazz.TypeReference),
		_pairToRelation={} @ Dict(Integer, clazz.TypeRelation),
		_floatLiteralDict = {}@Dict(Number, clazz.FloatLiteral),
		_integerLiteralDict = {}@Dict(Integer, clazz.IntegerLiteral),
		_sbLiteralDict={}@Struct {[String]=clazz.StringLiteral, [Boolean]=OrNil(clazz.BooleanLiteral)},
		_unionSignToType=setmetatable({}, {__mode="v"}) @ Dict(String, clazz.UAtomUnion),
		_typeIdCounter=0@Integer,
		_rootNode=vRootNode,
		_scheduleManager=vScheduleManager,
		_dirtyProcessor=nil@!clazz.DirtyProcessor,
	}, TypeManager)
	self._dirtyProcessor = DirtyProcessor.new(self)
	self.type = makeBuiltinType(self)
	self.type.Boolean = self:buildUnion(vRootNode, self.type.False, self.type.True)
	self.type.Any = self:buildUnion(vRootNode, self.type.False, self.type.Nil, self.type.Truth)
	self.type.AnyObject = self:buildInterface(vRootNode, {})
	self.generic.Dict = self:buildTemplate(vRootNode, function(vKey:clazz.UAllType,vValue:clazz.UAllType)
		assert(vKey and vValue, "key or value can't be nil when build Dict")
		return self:buildStruct(vRootNode, {[vKey]=vValue}, {__Next=vKey})
	end)
	self.generic.Cond = self:buildTemplate(vRootNode, function(vCond:clazz.UAllType,v1:clazz.UAllType,v2:clazz.UAllType)
		local nType = vCond
		if Reference.is(vCond) or AsyncUnion.is(vCond) then
			nType = vCond:checkAtomUnion()
		end
		if nType:isUnion() then
			error("Cond's first value can't be union")
		end
		return (nType == self.type.Nil or nType == self.type.False) and v2 or v1
	end)
	self.generic.IDict = self:buildTemplate(vRootNode, function(vKey:clazz.UAllType,vValue:clazz.UAllType)
		assert(vKey and vValue, "key or value can't be nil when build IDict")
		return self:buildInterface(vRootNode, {[vKey]=vValue}, {__Next=vKey})
	end)
	self.generic.List = self:buildTemplate(vRootNode, function(vValue:clazz.UAllType)
		assert(vValue, "value can't be nil when build List")
		return self:buildStruct(vRootNode, {[self.type.Integer]=vValue}, {__Next=self.type.Integer, __len=self.type.Integer})
	end)
	self.generic.IList = self:buildTemplate(vRootNode, function(vValue:clazz.UAllType)
		assert(vValue, "value can't be nil when build IList")
		return self:buildInterface(vRootNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer})
	end)
	self.generic.KeyOf = self:buildTemplate(vRootNode, function(vOneType:clazz.UAllType)
		local nObject = vOneType
		if Reference.is(vOneType) then
			nObject = vOneType:checkAtomUnion()
		end
		if not TypedObject.is(nObject) then
			error("key of can only worked on object function")
		end
		const nKeyRefer, _ = nObject:getKeyTypes()
		const nRefer = self:Reference(false)
		nRefer:setUnionAsync(nObject:getNode(), function()
			return nKeyRefer:getListAwait(), function()
				nKeyRefer:getTypeAwait()
			end
		end)
		return nRefer
	end)
	return self
end

function TypeManager:lateInit()
	self.builtin = makeBuiltinFunc(self)
end

function TypeManager:lateInitStringLib(vStringLib:clazz.IAtomType)
	self.builtin.string = vStringLib
end

function TypeManager:isLiteral(vType:clazz.IAtomType):Ret(Boolean)
	if StringLiteral.is(vType) or FloatLiteral.is(vType) or IntegerLiteral.is(vType) or BooleanLiteral.is(vType) then
		return true
	else
		return false
	end
end

function TypeManager:toAtomUnion(vData:clazz.UAllType):Ret(clazz.UAtomUnion)
	-- TODO
end

function TypeManager:_checkAllType(vData:Any):Ret(OrFalse(clazz.UAllType))
	if Reference.is(vData) or BaseAtomType.is(vData) or BaseUnionType.is(vData) then
		return vData
	end
	return false
end

function TypeManager:TypeCollection():Ret(clazz.TypeCollection)
	return TypeCollection.new(self)
end

function TypeManager:AsyncUnion():Ret(clazz.AsyncUnion)
	return AsyncUnion.new(self)
end

function TypeManager:_buildCombineObject(vNode:clazz.IBaseNode, vIsInterface:Boolean, vObjectList:List(clazz.UAllType)):Ret(clazz.TypedObject)
	const nNewObject = vIsInterface and Interface.new(self, vNode) or Struct.new(self, vNode)
	nNewObject:buildAsync(function(vAsyncKey)
		if vIsInterface then
			assert(#vObjectList>=1, "Intersect must take at least one arguments")
		else
			assert(#vObjectList >= 2, "StructExtend must take at least one interface after struct")
		end
		const nKeyList:List(clazz.IAtomType) = {}
		const nKeyValuePairList:List(Struct {clazz.IAtomType, clazz.UAllType}) = {}
		const nIntersectSet:Dict(clazz.TypedObject, True) = {}
		const nMetaEventComList:List(clazz.MetaEventCom) = {}
		local nIntersectNextKey:OrFalse(clazz.UAllType) = self.type.Any
		for i=1,#vObjectList do
			local nTypedObject = vObjectList[i]!
			if Reference.is(nTypedObject) then
				nTypedObject = nTypedObject:checkAtomUnion()
			end
			if not TypedObject.is(nTypedObject) then
				error("Interface or Struct is expected here")
				break
			end
			if i == 1 then
				if vIsInterface then
					assert(Interface.is(nTypedObject), "Intersect must take Interface")
					nIntersectSet[nTypedObject] = true
				else
					assert(not Interface.is(nTypedObject), "StructExtend must take Struct as first argument")
				end
			else
				assert(Interface.is(nTypedObject), vIsInterface
					and "Intersect must take Interface as args"
					or "StructExtend must take Interface after first argument")
				nIntersectSet[nTypedObject] = true
			end
			local nValueDict = nTypedObject:getValueDict()
			const nKeyRefer, nNextKey = nTypedObject:getKeyTypes()
			for _, nKeyType in ipairs(nKeyRefer:getListAwait()) do
				nKeyList[#nKeyList + 1] = nKeyType
				nKeyValuePairList[#nKeyValuePairList + 1] = {nKeyType, nValueDict[nKeyType]!}
			end
			nMetaEventComList[#nMetaEventComList + 1] = nTypedObject:getMetaEventCom() or nil
			if nIntersectNextKey then
				if nNextKey then
					const nTypeOrFalse = nIntersectNextKey:safeIntersect(nNextKey)
					if not nTypeOrFalse then
						error("intersect error")
					else
						nIntersectNextKey = nTypeOrFalse
					end
				else
					nIntersectNextKey = false
				end
			end
		end
		const _, nFinalValueDict = self:typeMapReduce@<clazz.UAllType>(nKeyValuePairList, function(vList)
			return self:intersectReduceType(vNode, vList)
		end)
		vAsyncKey:setListAsync(vNode, nKeyList)
		const nKeyAtomUnion = vAsyncKey:checkAtomUnion()
		if #nMetaEventComList > 0 then
			const nNewEventCom = self:makeMetaEventCom(nNewObject)
			nNewEventCom:initByMerge(nMetaEventComList)
			nNewObject:lateInit(nIntersectSet, nFinalValueDict, nIntersectNextKey, nNewEventCom)
		else
			nNewObject:lateInit(nIntersectSet, nFinalValueDict, nIntersectNextKey, false)
		end
		-- TODO check key's count and intersect valid
		nNewObject:lateCheck()
	end)
	return nNewObject
end

function TypeManager:buildExtendStruct(vNode:clazz.IBaseNode, vFirst:Union(Dict(Truth, Truth), clazz.UAllType),
	...:Union(clazz.TypeReference, clazz.TypedObject)):Ret(clazz.TypedObject)
	const nStruct = self:_checkAllType(vFirst) or self:buildStruct(vNode, vFirst @> Dict(Truth, Truth))
	const l:List(clazz.UAllType) = {nStruct, ...}
	return self:_buildCombineObject(vNode, false, l)
end

function TypeManager:buildExtendInterface(vNode:clazz.IBaseNode, ...:Union(clazz.TypeReference, clazz.TypedObject)):Ret(clazz.TypedObject)
	const l:List(clazz.UAllType) = {...}
	return self:_buildCombineObject(vNode, true, l)
end

function TypeManager:checkedUnion(...:clazz.UAllType):Ret(clazz.UAtomUnion)
	const l:List(clazz.UAllType) = {...}
	const nCollection = self:TypeCollection()
	for i=1, select("#", ...) do
		l[i]!:checkAtomUnion():foreach(function(vAtomType)
			nCollection:put(vAtomType)
		end)
	end
	return nCollection:mergeToAtomUnion()
end

function TypeManager:buildEnum(vNode:clazz.IBaseNode, vArgType:Truth):Ret(clazz.TypeReference)
	const nNewRefer = self:Reference(false)
	error("build Enum TODO")
	--[[nNewRefer:setUnionAsync(vNode, function()
		const nType = self._dirtyProcessor:easyToType(vNode, vArgType)
		const nSuperType = Reference.is(nType) and nType:waitTypeCom():getTypeAwait() or nType
		return {Enum.new(self, nSuperType)}
	end)]]
	return nNewRefer
end

function TypeManager:addEnum(vNode:clazz.IBaseNode, vEnumType:Truth, ...:Truth)
	-- TODO, put this in an async thread
	const nType = self._dirtyProcessor:easyToType(vNode, vEnumType)
	local nEnumType = nType:checkAtomUnion()
	assert(Enum.is(nEnumType), Exception.new("enum must take Enum as first arg", vNode))
	local l = {...}
	const nLen = select("#", ...)
	for i=1, nLen do
		local nItem = self._dirtyProcessor:easyToType(vNode, l[i])
		nEnumType:addType(nItem)
	end
end

function TypeManager:buildUnion(vNode:clazz.IBaseNode, ...:Truth):Ret(clazz.TypeReference)
	local l = {...}
	const nLen = select("#", ...)
	local nNewRefer = self:Reference(false)
	nNewRefer:setUnionAsync(vNode, function()
		local nTypeList:List(clazz.IAtomType) = {}
		for i=1, nLen do
			local nItem = self._dirtyProcessor:easyToType(vNode, l[i])
			if Reference.is(nItem) then
				const nAsyncType = nItem:waitTypeCom():getTypeNowait()
				if nAsyncType:isAsync() then
					const nList = nAsyncType:getListAwait()
					table.move(nList, 1, #nList, #nTypeList + 1, nTypeList)
				else
					nAsyncType:foreach(function(vAtom)
						nTypeList[#nTypeList + 1] = vAtom
					end)
				end
			elseif AsyncUnion.is(nItem) then
				const nList = nItem:getListAwait()
				table.move(nList, 1, #nList, #nTypeList + 1, nTypeList)
			else
				nItem:foreach(function(vAtom)
					nTypeList[#nTypeList + 1] = vAtom
				end)
			end
		end
		return nTypeList
	end)
	return nNewRefer
end

function TypeManager:buildInterface(vNode:clazz.IBaseNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType))):Ret(clazz.Interface)
	return self:_buildTypedObject@<True>(vNode, vTable, vMetaEventDict, true)
end

function TypeManager:buildStruct(vNode:clazz.IBaseNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType))):Ret(clazz.Struct)
	return self:_buildTypedObject@<False>(vNode, vTable, vMetaEventDict, false)
end

function TypeManager:_buildTypedObject@<IsInterface>(vNode:clazz.IBaseNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType)), vIsInterface:IsInterface):Ret(Cond(IsInterface, clazz.Interface, clazz.Struct))
	const nNextKey = vMetaEventDict and vMetaEventDict.__Next or false
	const nNewObject = vIsInterface and Interface.new(self, vNode) or Struct.new(self, vNode)
	nNewObject:buildAsync(function(vAsyncKey)
		const nIndependentList:List(clazz.UAllType) = {}
		const nKeyList:List(clazz.IAtomType) = {}
		const nValueDict:Dict(clazz.IAtomType, clazz.UAllType) = {}
		for nKey, nValue in pairs(vTable) do
			const nValueType = self._dirtyProcessor:easyToType(vNode, nValue)
			const nKeyType = self._dirtyProcessor:easyToType(vNode, nKey)
			nIndependentList[#nIndependentList + 1] = nKeyType
			nKeyType:checkAtomUnion():foreach(function(vAtomType)
				nKeyList[#nKeyList + 1] = vAtomType
				if vAtomType:isSingleton() then
					nValueDict[vAtomType] = nValueType
				else
					nValueDict[vAtomType] = self:buildUnion(vNode, nValueType, self.type.Nil)
				end
			end)
		end
		vAsyncKey:setListAsync(vNode, nKeyList)
		const nKeyAtomUnion = vAsyncKey:checkAtomUnion()
		if vMetaEventDict then
			const nNewEventCom = self:makeMetaEventCom(nNewObject)
			nNewEventCom:initByEventDict(vMetaEventDict)
			nNewObject:lateInit({}, nValueDict, nNextKey, nNewEventCom)
		else
			nNewObject:lateInit({}, nValueDict, nNextKey, false)
		end
		nNewObject:lateCheck()
		if not self:typeCheckIndependent(nIndependentList, nKeyAtomUnion) then
			error("Object's key must be independent")
		end
	end)
	return nNewObject
end

function TypeManager:buildIDict(vNode:clazz.IBaseNode, vKey:clazz.UAtomUnion, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildInterface(vNode, {[vKey]=vValue})
end

function TypeManager:buildDict(vNode:clazz.IBaseNode, vKey:clazz.UAtomUnion, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildStruct(vNode, {[vKey]=vValue}, {__Next=vKey})
end

function TypeManager:buildIList(vNode:clazz.IBaseNode, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildInterface(vNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer})
end

function TypeManager:buildList(vNode:clazz.IBaseNode, vValue:clazz.UAllType):Ret(clazz.TypedObject)
	return self:buildStruct(vNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer, __Next=self.type.Integer})
end

function TypeManager:buildOrNil(vNode:clazz.IBaseNode, ...:Truth):Ret(clazz.TypeReference)
	return self:buildUnion(vNode, self.type.Nil, ...)
end

function TypeManager:buildOrFalse(vNode:clazz.IBaseNode, ...:Truth):Ret(clazz.TypeReference)
	return self:buildUnion(vNode, self.type.False, ...)
end

function TypeManager:_unifyUnion(vNewType:clazz.IUnionType):Ret(clazz.UAtomUnion)
	local nSign = vNewType:unionSign()
	local nSignToType = self._unionSignToType
	local nOldType = nSignToType[nSign]
	if not nOldType then
		vNewType:initWithTypeId(self:genTypeId())
		nSignToType[nSign] = vNewType
		return vNewType
	else
		return nOldType
	end
end

function TypeManager:atomRecordTypeUnionSign(vType:clazz.BaseAtomType)
	self._unionSignToType[tostring(vType.id)] = vType
end

function TypeManager:metaNativeOpenFunction(vFn):Ret(clazz.OpenFunction)
	const nOpenFn = self._runtime:getRootStack():newOpenFunction(self._rootNode)
	nOpenFn:lateInitFromMetaNative(vFn)
	return nOpenFn
end

function TypeManager:fixedNativeOpenFunction(vFn):Ret(clazz.OpenFunction)
	const nOpenFn = self._runtime:getRootStack():newOpenFunction(self._rootNode)
	nOpenFn:lateInitFromOperNative(vFn)
	return nOpenFn
end

function TypeManager:stackNativeOpenFunction(vFn):Ret(clazz.OpenFunction)
	const nOpenFn = self._runtime:getRootStack():newOpenFunction(self._rootNode)
	nOpenFn:lateInitFromAutoNative(vFn)
	return nOpenFn
end

function TypeManager:Literal(vValue:Union(String, Number, Boolean)):Ret(Union(clazz.FloatLiteral, clazz.IntegerLiteral, clazz.StringLiteral, clazz.BooleanLiteral))
	const t = type(vValue)
	if t == "number" then
		if math.type(vValue) == "integer" then
			const nLiteralDict = self._integerLiteralDict
			local nLiteralType = nLiteralDict[vValue]
			if not nLiteralType then
				nLiteralType = IntegerLiteral.new(self, vValue)
				nLiteralDict[vValue] = nLiteralType
			end
			return nLiteralType
		else
			const nLiteralDict = self._floatLiteralDict
			local nLiteralType = nLiteralDict[vValue]
			if not nLiteralType then
				nLiteralType = FloatLiteral.new(self, vValue)
				nLiteralDict[vValue] = nLiteralType
			end
			return nLiteralType
		end
	else
		const nLiteralDict = self._sbLiteralDict
		local nLiteralType = nLiteralDict[vValue]
		if not nLiteralType then
			if t == "string" then
				nLiteralType = StringLiteral.new(self, vValue)
				nLiteralDict[vValue] = nLiteralType
			elseif t == "boolean" then
				if vValue then
					nLiteralType = self.type.True
				else
					nLiteralType = self.type.False
				end
				nLiteralDict[vValue] = nLiteralType
			else
				error("literal must take boolean or number or string value but got:"..tostring(t))
			end
		end
		return nLiteralType
	end
end

function TypeManager:TypeTuple(vNode:clazz.IBaseNode, vTypeList:List(clazz.UAllType)):Ret(clazz.TypeTuple)
	return TypeTuple.new(self, vNode, vTypeList)
end

function TypeManager:VoidRetTuples(vNode:clazz.IBaseNode, vErrType:OrNil(clazz.UAllType)):Ret(clazz.RetTuples)
	return RetTuples.new(self, vNode, {self:TypeTuple(vNode, {})}, vErrType or false)
end

function TypeManager:SingleRetTuples(vNode:clazz.IBaseNode, vTypeTuple:clazz.UTypeTuple, vErrType:OrNil(clazz.UAllType)):Ret(clazz.RetTuples)
	return RetTuples.new(self, vNode, {vTypeTuple}, vErrType or false)
end

function TypeManager:buildMfn(vNode:clazz.IBaseNode, ...:Truth):Ret(clazz.TypedMemberFunction)
	const nHeadlessFn = self:buildFn(vNode, ...)
	return TypedMemberFunction.new(self, vNode, nHeadlessFn)
end

function TypeManager:buildPfn(vNode:clazz.IBaseNode, vFunc:AnyFunction):Ret(clazz.TypedPolyFunction)
	const nInfo = debug.getinfo(vFunc)
	const nPolyParNum=nInfo.nparams
	if nInfo.isvararg then
		error("poly function can't be vararg")
	end
	return TypedPolyFunction.new(self, vNode, vFunc, nPolyParNum)
end

function TypeManager:buildFn(vNode:clazz.IBaseNode, ...:Any):Ret(clazz.TypedFunction)
	local nParTuple = self:TypeTuple(vNode, self._dirtyProcessor:easyToTypeList(vNode, ...))
	return TypedFunction.new(self, vNode, nParTuple, false)
end

function TypeManager:checkedFn(...:Any):Ret(clazz.TypedFunction)
	local nParTuple = self:TypeTuple(self._rootNode, self._dirtyProcessor:easyToTypeList(self._rootNode, ...))
	return TypedFunction.new(self, self._rootNode, nParTuple, false)
end

function TypeManager:SealPolyFunction(vNode:clazz.IBaseNode, vFunc:AnyFunction, vPolyParNum:Integer, vStack:clazz.BaseStack):Ret(clazz.SealPolyFunction)
	return SealPolyFunction.new(self, vNode, vFunc, vPolyParNum, vStack)
end

function TypeManager:AutoMemberFunction(vNode:clazz.IBaseNode, vPolyFn:clazz.SealPolyFunction):Ret(clazz.AutoMemberFunction)
	return AutoMemberFunction.new(self, vNode, vPolyFn)
end

function TypeManager:TypedFunction(vNode:clazz.IBaseNode, vParTuple:clazz.UTypeTuple, vRetTuples:clazz.RetTuples):Ret(clazz.TypedFunction)
	assert(TypeTuple.is(vParTuple) or TypeTupleDots.is(vParTuple))
	assert(RetTuples.is(vRetTuples))
	return TypedFunction.new(self, vNode, vParTuple, vRetTuples)
end

function TypeManager:makeMetaEventCom(vObject:Union(clazz.SealTable, clazz.TypedObject)):Ret(clazz.MetaEventCom)
	return MetaEventCom.new(self, vObject)
end

function TypeManager:buildTemplate(vNode:clazz.IBaseNode, vFunc:AnyFunction):Ret(clazz.TypeReference)
	const nInfo = debug.getinfo(vFunc)
	const nParNum = nInfo.nparams
	if nInfo.isvararg then
		error("template's parameter number is undetermined")
	end
	return self:buildTemplateWithParNum(vNode, vFunc, nParNum)
end

function TypeManager:buildTemplateWithParNum(vNode:clazz.IBaseNode, vFunc:AnyFunction, vParNum:Integer):Ret(clazz.TypeReference)
	const nRefer = self:Reference(false)
	nRefer:setTemplateAsync(vNode, vFunc, vParNum)
	return nRefer
end

function TypeManager:Reference(vName:Union(String, False)):Ret(clazz.TypeReference)
	const nRefer = Reference.new(self, vName)
	return nRefer
end

function TypeManager:typeCheckIndependent(vList:List(clazz.UAllType), vFinalType:clazz.UAtomUnion):Ret(Boolean)
	local nLeftCount = 0
	for k,v in pairs(vList) do
		v:checkAtomUnion():foreach(function(_)
			nLeftCount = nLeftCount + 1
		end)
	end
	local nRightCount = 0
	vFinalType:foreach(function(_)
		nRightCount = nRightCount + 1
	end)
	return nRightCount == nLeftCount
end

function TypeManager:typeMapReduce@<TValue>(
	vTypePairList:IList(Interface {clazz.UAtomUnion, TValue}),
	vReduceFn:Fn(IList(TValue)):Ret(TValue)
):Ret(clazz.UAtomUnion, Dict(clazz.IAtomType, TValue))
	const nCollection = self:TypeCollection()
	for _, nPair in ipairs(vTypePairList) do
		local nFieldType = nPair[1]
		if nFieldType:isReference() then
			nFieldType = nFieldType:checkAtomUnion()
			nPair[1] = nFieldType
		end
		nCollection:put(nFieldType)
	end
	const nKeyUnion = nCollection:mergeToAtomUnion()
	-- step 1: map
	const nTypeToList:Dict(clazz.IAtomType, List(TValue)) = {}
	for _, nPair in ipairs(vTypePairList) do
		local nKey = nPair[1]
		local nValueType = nPair[2]
		nKey:foreach(function(vSubType)
			const nIncludeType = assert(nKeyUnion:includeAtom(vSubType), "merge error")
			const nList = nTypeToList[nIncludeType]
			if not nList then
				nTypeToList[nIncludeType] = {nValueType}
			else
				nList[#nList + 1] = nValueType
			end
		end)
	end
	-- step 2: reduce
	const nTypeDict:Dict(clazz.IAtomType, TValue) = {}
	for k,v in pairs(nTypeToList) do
		nTypeDict[k] = vReduceFn(v)
	end
	return nKeyUnion, nTypeDict
end

function TypeManager:unionReduceType(vList:IList(clazz.UAtomUnion)):Ret(clazz.UAtomUnion)
	if #vList == 1 then
		return vList[1]!
	end
	const nCollection = self:TypeCollection()
	for _, nType in ipairs(vList) do
		nType:foreach(function(vAtomType)
			nCollection:put(vAtomType)
		end)
	end
	return nCollection:mergeToAtomUnion()
end

function TypeManager:intersectReduceType(vNode:clazz.IBaseNode, vList:IList(clazz.UAllType)):Ret(clazz.UAllType)
	const nFirst = vList[1]!
	if #vList == 1 then
		return nFirst
	end
	const nRefer = self:Reference(false)
	nRefer:setUnionAsync(vNode, function()
		local nFinalType = nFirst:checkAtomUnion()
		for i=2, #vList do
			const nCurType = vList[i]!
			const nInterType = nFinalType:safeIntersect(nCurType)
			if not nInterType then
				error("unexpected intersect")
			else
				nFinalType = nInterType
			end
		end
		const nAtomList:List(clazz.IAtomType) = {}
		nFinalType:foreach(function(vAtomType)
			nAtomList[#nAtomList + 1] = vAtomType
		end)
		if nFinalType:isNever() then
			error("object intersect can't has never field")
		end
		return nAtomList, function()
			return nFinalType
		end
	end)
	return nRefer
end

function TypeManager:makePair(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(Integer)
	const nLeftId, nRightId = vLeft.id, vRight.id
	assert(nLeftId ~= 0 and nRightId ~=0, "use id ==0")
	return TypeRelation.shiftPair(nLeftId, nRightId)
end

function TypeManager:makeDuPair(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(Boolean, Integer, Integer)
	const nLeftId, nRightId = vLeft.id, vRight.id
	if nLeftId < nRightId then
		return false, TypeRelation.shiftPair(nLeftId, nRightId), TypeRelation.shiftPair(nRightId, nLeftId)
	else
		return true, TypeRelation.shiftPair(nRightId, nLeftId), TypeRelation.shiftPair(nLeftId, nRightId)
	end
end

function TypeManager:attachPairRelation(vLeft:clazz.TypedObject, vRight:clazz.TypedObject, vWaitCreate:Boolean):Ret(OrNil(clazz.RelationEnum))
	const nInverse, nLRPair, nRLPair = self:makeDuPair(vLeft, vRight)
	if nInverse then
		vRight, vLeft = vLeft, vRight
	end
	local nRelation = self._pairToRelation[nLRPair]
	local nResult:OrFalse(clazz.RelationEnum) = false
	if vWaitCreate then
		if not nRelation then
			nRelation = TypeRelation.new(self)
			self._pairToRelation[nLRPair] = nRelation
			nRelation:buildByObject(vLeft, vRight)
		end
		nResult = nRelation:getAwait()
	else
		if nRelation then
			nResult = nRelation:getNowait()
		end
	end
	if not nResult then
		return nil
	end
	if nInverse then
		if nResult == ">" then
			return "<"
		elseif nResult == "<" then
			return ">"
		else
			return nResult
		end
	else
		return nResult
	end
end

function TypeManager:getRuntime():Ret(clazz.BaseRuntime)
	return self._runtime
end

function TypeManager:literal2Primitive(vType:clazz.UAtomUnion):Ret(clazz.UAtomUnion)
	if BooleanLiteral.is(vType) then
		return self.type.Boolean:checkAtomUnion()
	elseif FloatLiteral.is(vType) then
		return self.type.Number
	elseif IntegerLiteral.is(vType) then
		return self.type.Integer
	elseif StringLiteral.is(vType) then
		return self.type.String
	else
		return vType
	end
end

function TypeManager:signTemplateArgs(vTypeList:IList(clazz.UAllType)):Ret(String)
	const nIdList:List(Integer) = {}
	for i=1,#vTypeList do
		nIdList[i] = vTypeList[i]!.id
	end
	return table.concat(nIdList, "-")
end

function TypeManager:genTypeId():Ret(Integer)
	local nNewId = self._typeIdCounter + 1
	self._typeIdCounter = nNewId
	return nNewId
end

function TypeManager:dump()
	for k,v in pairs(self._unionSignToType) do
		print(k, tostring(v))
	end
end

function TypeManager:getScheduleManager():Ret(clazz.ScheduleManager)
	return self._scheduleManager
end

function TypeManager:getDirtyProcessor()
	return self._dirtyProcessor
end

return TypeManager
