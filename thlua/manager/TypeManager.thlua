
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const TypeCollection = require "thlua.manager.TypeCollection"
const Node = require "thlua.code.Node"
const Exception = require "thlua.Exception"

const Never = require "thlua.union.Never"
const StringLiteral = require "thlua.type.StringLiteral"
const String = require "thlua.type.String"
const NumberLiteral = require "thlua.type.NumberLiteral"
const Number = require "thlua.type.Number"
const BooleanLiteral= require "thlua.type.BooleanLiteral"
const Nil = require "thlua.type.Nil"
const Thread = require "thlua.type.Thread"
const Truth = require "thlua.type.Truth"
const MetaObject = require "thlua.object.MetaObject"
const LuaTable = require "thlua.object.LuaTable"
const LuaFunction = require "thlua.func.LuaFunction"
const OpenFunction = require "thlua.func.OpenFunction"
const TypeFunction = require "thlua.func.TypeFunction"
const PolyFunction = require "thlua.func.PolyFunction"
const AnyFunction = require "thlua.func.AnyFunction"
const Reference = require "thlua.refer.Reference"

const MemberFunction = require "thlua.func.MemberFunction"

const StringLiteralUnion = require "thlua.union.StringLiteralUnion"
const NumberLiteralUnion = require "thlua.union.NumberLiteralUnion"
const ObjectUnion = require "thlua.union.ObjectUnion"
const FuncUnion = require "thlua.union.FuncUnion"
const FalsableUnion = require "thlua.union.FalsableUnion"
const ComplexUnion = require "thlua.union.ComplexUnion"

const RetTuples = require "thlua.tuple.RetTuples"
const TypeTuple = require "thlua.tuple.TypeTuple"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"

const MetaEventCom = require "thlua.object.MetaEventCom"
const native = require "thlua.native"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.WaitingInfo = Struct {
		waitSid = Integer,
		dependCo = Thread,
	}
end)

const function:class(clazz.CoroutineInterrupt) CoroutineInterrupt()
	return {.class}
end

const TypeManager = {}
TypeManager.__index=TypeManager

function:class(clazz.TypeManager) TypeManager.new(vRuntime:clazz.Runtime)
	const self = setmetatable({.class
		_runtime=vRuntime,
		-- type items
		type={
			Object=nil @ clazz.MetaObject,
		},
		generic={},
		builtin={},
		_pairToInclude={} @ Dict(Integer, clazz.Reference),
		_literalDict={}@Struct {[Number]=clazz.NumberLiteral, [String]=clazz.StringLiteral},
		_unionSignToType=(setmetatable({}, {__mode="v"}) @ Dict(String, clazz.UAtomUnion)),
		_typeIdCounter=0@Integer,
		-- coroutine items
		_coStop=CoroutineInterrupt(),
		_coToRefer={} @ Dict(Thread, clazz.Reference),
		_coToScheduleParam={}@Dict(Thread, Union(True, Fn())),
		_coToWaitingInfo={}@Dict(Thread, WaitingInfo),
		_sessionIdCounter=0@Integer,
		_selfCo=coroutine.running(),
	}, TypeManager)
	self.type.Never = Never.new(self)
	self.type.Nil = Nil.new(self)
	self.type.False = BooleanLiteral.new(self, false)
	self.type.True = BooleanLiteral.new(self, true)
	self.type.Thread = Thread.new(self)
	self.type.Number = Number.new(self)
	self.type.Integer = self.type.Number
	self.type.String = String.new(self)
	self.type.Truth = Truth.new(self)
	self.type.AnyFunction = AnyFunction.new(self)
	for k, nType in pairs(self.type @!! Dict(String, clazz.UAtomUnion)) do
		self:_recordTypeUnionSign(nType)
	end
	const nRootNode = vRuntime:getNode()
	self.type.Boolean = self:buildUnion(nRootNode, self.type.False, self.type.True)
	self.type.Any = self:buildUnion(nRootNode, self.type.False, self.type.Nil, self.type.Truth)
	self.type.AnyObject = self:buildInterface(nRootNode, {})
	self.generic.Dict = self:buildTemplate(nRootNode, function.pass(vKey,vValue)
		assert(vKey and vValue, "key or value can't be nil when build Dict")
		return self:buildStruct(nRootNode, {[vKey]=vValue}, {__next=vKey})
	end)
	self.generic.IDict = self:buildTemplate(nRootNode, function.pass(vKey,vValue)
		assert(vKey and vValue, "key or value can't be nil when build IDict")
		return self:buildInterface(nRootNode, {[vKey]=vValue}, {__next=vKey})
	end)
	self.generic.List = self:buildTemplate(nRootNode, function.pass(vValue)
		assert(vValue, "value can't be nil when build List")
		return self:buildStruct(nRootNode, {[self.type.Integer]=vValue}, {__next=self.type.Integer, __len=self.type.Integer})
	end)
	self.generic.IList = self:buildTemplate(nRootNode, function.pass(vValue)
		assert(vValue, "value can't be nil when build IList")
		return self:buildInterface(nRootNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer})
	end)
	self.generic.KeyOf = self:buildTemplate(nRootNode, function.pass(vOneType)
		local nObject = vOneType
		if Reference.is(vOneType) then
			nObject = vOneType:waitTypeCom():getTypeAwait()
		end
		if not MetaObject.is(nObject) then
			error("key of can only worked on object function")
		end
		const nKeyRefer, _ = nObject:getKeyTypes()
		return nKeyRefer
	end)
	self.builtin.string=native.make_string(self)
	self.builtin.next=native.make_next(self)
	self.builtin.inext=native.make_inext(self)
	self.builtin.bop={
		mathematic=native.make_mathematic(self),
		comparison=native.make_comparison(self),
		bitwise=native.make_bitwise(self),
		concat=native.make_concat(self),
	}
	return self
end

const AtomMetatableSet:Dict(Truth, String) = {
	-- not recursive
	[Nil]="Nil",
	[String]="String",
	[StringLiteral]="StringLiteral",
	[Number]="Number",
	[NumberLiteral]="NumberLiteral",
	[BooleanLiteral]="BooleanLiteral",
	[Thread]="Thread",
	[Truth]="Truth",
	[LuaTable]="LuaTable",
	[MetaObject]="MetaObject",
	[LuaFunction]="LuaFunction",
	[TypeFunction]="TypeFunction",
	[PolyFunction]="PolyFunction",
	[AnyFunction]="AnyFunction",
	[OpenFunction]="OpenFunction",
}

const AtomUnionMetatableSet:Dict(Truth, String) = {
	[Never]="Never",
	[NumberLiteralUnion]="NumberLiteralUnion",
	[StringLiteralUnion]="StringLiteralUnion",
	[FalsableUnion]="FalsableUnion",
	[ObjectUnion]="ObjectUnion",
	[FuncUnion]="FuncUnion",
	[ComplexUnion]="ComplexUnion",
}

for k, v in pairs(AtomMetatableSet) do
	AtomUnionMetatableSet[k] = v
end

function TypeManager:pcheckNamespaceAssigValue(vData:Any):Ret(True, Union(clazz.Reference, clazz.IAtomType)):Ret(False, String)
	local meta = getmetatable(vData)
	if meta and (AtomMetatableSet[meta] or meta == Reference) then
		return true, vData @!! Union(clazz.Reference, clazz.IAtomType)
	else
		return false, "not atom or reference"
	end
end

function TypeManager:tryLuaTable(vType:clazz.UAllType):Ret(False):Ret(True, clazz.LuaTable)
	if Reference.is(vType) then
		vType = vType:checkAtomUnion()
	end
	if not LuaTable.is(vType) then
		return false
	else
		return true, vType
	end
end

function TypeManager:basingByDefault(vType:clazz.UAtomUnion)
	vType:foreach(function(vAtomType)
		if LuaTable.is(vAtomType) then
			vAtomType:checkBaseObjectType()
		end
	end)
end

function TypeManager:assertAllType(vData:Truth):Ret(clazz.UAllType)
	local meta = getmetatable(vData)
	if meta and (AtomUnionMetatableSet[meta] or meta == Reference) then
		return vData @!! clazz.UAllType
	else
		error("assertAllType failed, type="..type(vData)..tostring(debug.traceback()))
	end
end

function.pass TypeManager:_checkAllType(vData:Any):Ret(OrFalse(clazz.UAllType))
	local t = type(vData)
	if t == "table" then
		local meta = getmetatable(vData)
		if AtomMetatableSet[meta] then
			return vData
		end
	end
	if Reference.is(vData) then
		return vData
	end
	return false
end

function.pass TypeManager:_toType(vData:Any):Ret(clazz.IAtomType)
	local t = type(vData)
	if t == "table" then
		local meta = getmetatable(vData)
		if AtomMetatableSet[meta] or AtomUnionMetatableSet[meta] then
			return vData
		else
			error("to type failed")
		end
	elseif t == "number" or t == "string" then
		return self:Literal(vData)
	else
		error("_toType("..t..") todo")
	end
end

function TypeManager:TypeCollection():Ret(clazz.TypeCollection)
	return TypeCollection.new(self)
end

function TypeManager:_buildCombineObject(vNode:clazz.IAstNode, vIsInterface:Boolean, vObjectList:List(clazz.UAllType)):Ret(clazz.Reference)
	const nObjectRefer = self:Reference(false)
	nObjectRefer:setUnionAsync(vNode, function()
		if vIsInterface then
			assert(#vObjectList>=1, "Interface must take at least one arguments")
		else
			assert(#vObjectList >= 2, "StructExtend must take at least one interface after struct")
		end
		const nKeyList:List(clazz.IAtomType) = {}
		const nAllValueDict:clazz.MemberDict = {}
		const nIntersectSet:Dict(clazz.MetaObject, True) = {}
		const nMetaEventComList:List(clazz.MetaEventCom) = {}
		local nIntersectNextKey:OrFalse(clazz.UAllType) = self.type.Truth
		for i=1,#vObjectList do
			local nMetaObject = vObjectList[i]!
			if Reference.is(nMetaObject) then
				nMetaObject = nMetaObject:waitTypeCom():getTypeAwait()
			end
			if not MetaObject.is(nMetaObject) then
				error("Interface or Struct is expected here")
				break
			end
			if i == 1 then
				if vIsInterface then
					assert(nMetaObject:isInterface(), "Intersect must take Interface")
					nIntersectSet[nMetaObject] = true
				else
					assert(not nMetaObject:isInterface(), "StructExtend must take Struct as first argument")
				end
			else
				assert(nMetaObject:isInterface(), vIsInterface
					and "Intersect must take Interface as args"
					or "StructExtend must take Interface after first argument")
				nIntersectSet[nMetaObject] = true
			end
			local nValueDict = nMetaObject:getMemberDict()
			const nKeyRefer, nNextKey = nMetaObject:getKeyTypes()
			for _, nKeyType in ipairs(nKeyRefer:waitTypeCom():getListAwait()) do
				nKeyList[#nKeyList + 1] = nKeyType
				nAllValueDict[nKeyType] = nValueDict[nKeyType]
			end
			nMetaEventComList[#nMetaEventComList + 1] = nMetaObject:getMetaEventCom() or nil
			if nIntersectNextKey then
				if nNextKey then
					const nTypeOrFalse = nIntersectNextKey:safeIntersect(nNextKey)
					if not nTypeOrFalse then
						error("intersect error")
					else
						nIntersectNextKey = nTypeOrFalse
					end
				else
					nIntersectNextKey = false
				end
			end
		end
		const nKeyRefer = self:Reference(false)
		const nNewObject = MetaObject.new(self, vIsInterface, nKeyRefer, nIntersectNextKey)
		if #nMetaEventComList > 0 then
			const nNewEventCom = self:makeMetaEventCom(nNewObject)
			nNewEventCom:initByMerge(nMetaEventComList)
			nNewObject:lateInit(nIntersectSet, nAllValueDict, nNewEventCom)
		else
			nNewObject:lateInit(nIntersectSet, nAllValueDict, false)
		end
		nKeyRefer:setUnionAsync(vNode, function()
			return nKeyList
		end, function(_)
			nNewObject:lateCheck()
			-- TODO check key's count and intersect valid
		end)
		return {self:_recordTypeUnionSign(nNewObject)}
	end)
	return nObjectRefer
end

function TypeManager:buildStructExtend(vNode:clazz.IAstNode, vFirst:Union(Dict(Truth, Truth), clazz.UAllType),
	...:Union(clazz.Reference, clazz.MetaObject)):Ret(clazz.Reference)
	const nStruct = self:_checkAllType(vFirst) or self:buildStruct(vNode, vFirst @ Dict(Truth, Truth))
	const l:List(clazz.UAllType) = {nStruct, ...}
	return self:_buildCombineObject(vNode, false, l)
end

function TypeManager:buildIntersect(vNode:clazz.IAstNode, ...:Union(clazz.Reference, clazz.MetaObject)):Ret(clazz.Reference)
	const l:List(clazz.UAllType) = {...}
	return self:_buildCombineObject(vNode, true, l)
end

function TypeManager:checkedUnion(...:clazz.UAllType):Ret(clazz.UAtomUnion)
	const l:List(clazz.UAllType) = {...}
	const nCollection = self:TypeCollection()
	for i=1, select("#", ...) do
		l[i]!:checkAtomUnion():foreach(function(vAtomType)
			nCollection:put(vAtomType)
		end)
	end
	return nCollection:mergeToAtomUnion()
end

function TypeManager:buildUnion(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.Reference)
	local l = {...}
	const nLen = select("#", ...)
	local nNewRefer = self:Reference(false)
	nNewRefer:setUnionAsync(vNode, function()
		local nTypeList:List(clazz.IAtomType) = {}
		for i=1, nLen do
			local nItem = l[i]
			if Reference.is(nItem) then
				local nList = nItem:waitTypeCom():getListAwait()
				table.move(nList, 1, #nList, #nTypeList + 1, nTypeList)
			else
				self:_toType(nItem):foreach(function(vAtom)
					nTypeList[#nTypeList + 1] = vAtom
				end)
			end
		end
		return nTypeList
	end)
	return nNewRefer
end

function TypeManager:buildInterface(vNode:clazz.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType))):Ret(clazz.MetaObject)
	return self:_buildMetaObject(vNode, vTable, vMetaEventDict, true)
end

function TypeManager:buildStruct(vNode:clazz.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType))):Ret(clazz.MetaObject)
	return self:_buildMetaObject(vNode, vTable, vMetaEventDict, false)
end

function TypeManager:_buildMetaObject(vNode:clazz.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, clazz.UAllType)), vIsInterface:Boolean):Ret(clazz.MetaObject)
	const nKeyRefer = self:Reference(false)
	const nNewObject = MetaObject.new(self, vIsInterface, nKeyRefer, vMetaEventDict and vMetaEventDict.__next or false)
	nKeyRefer:setUnionAsync(vNode, function()
		const nKeyList:List(clazz.IAtomType) = {}
		const nValueDict:Dict(clazz.IAtomType, Union(clazz.UAllType, clazz.MemberFunction)) = {}
		local nKeyCount = 0
		for nKey, nValue in pairs(vTable) do
			local nValueType:OrNil(clazz.UAllType, clazz.MemberFunction)
			if Reference.is(nValue) then
				nValueType = nValue
			elseif MemberFunction.is(nValue) then
				nValueType = nValue
			else
				nValueType = self:_toType(nValue)
			end
			local nKeyType:OrNil(clazz.UAllType)
			if Reference.is(nKey) then
				nKeyType = nKey
			else
				nKeyType = self:_toType(nKey)
			end
			nKeyType:foreachAwait(function(vAtomType)
				nKeyCount = nKeyCount + 1
				nKeyList[#nKeyList + 1] = vAtomType
				if vAtomType:isSingleton() then
					nValueDict[vAtomType] = nValueType
				else
					assert(nValueType and not MemberFunction.is(nValueType), "valuetype with non-singleton key can't be nil or MemberFunction")
					nValueDict[vAtomType] = self:buildUnion(vNode, nValueType, self.type.Nil)
				end
			end)
		end
		if vMetaEventDict then
			const nNewEventCom = self:makeMetaEventCom(nNewObject)
			nNewEventCom:initByEventDict(vMetaEventDict)
			nNewObject:lateInit({}, nValueDict, nNewEventCom)
		else
			nNewObject:lateInit({}, nValueDict, false)
		end
		return nKeyList
	end, function(vKeyAtomUnion)
		nNewObject:lateCheck()
		const nList = nKeyRefer:waitTypeCom():getListAwait()
		local nFinalCount = 0
		vKeyAtomUnion:foreach(function(_)
			nFinalCount = nFinalCount + 1
		end)
		if nFinalCount ~= #nList then
			error("Object's key can not has intersect part")
		end
	end)
	return self:_recordTypeUnionSign(nNewObject)
end

function TypeManager:buildIDict(vNode:clazz.IAstNode, vKey:clazz.UAtomUnion, vValue:clazz.UAllType):Ret(clazz.MetaObject)
	return self:buildInterface(vNode, {[vKey]=vValue})
end

function TypeManager:buildDict(vNode:clazz.IAstNode, vKey:clazz.UAtomUnion, vValue:clazz.UAllType):Ret(clazz.MetaObject)
	return self:buildStruct(vNode, {[vKey]=vValue}, {__next=vKey})
end

function TypeManager:buildIList(vNode:clazz.IAstNode, vValue:clazz.UAllType):Ret(clazz.MetaObject)
	return self:buildInterface(vNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer})
end

function TypeManager:buildList(vNode:clazz.IAstNode, vValue:clazz.UAllType):Ret(clazz.MetaObject)
	return self:buildStruct(vNode, {[self.type.Integer]=vValue}, {__len=self.type.Integer, __next=self.type.Integer})
end

function TypeManager:buildOrNil(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.Reference)
	return self:buildUnion(vNode, self.type.Nil, ...)
end

function TypeManager:buildOrFalse(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.Reference)
	return self:buildUnion(vNode, self.type.False, ...)
end

function TypeManager:_unifyUnion(vNewType:clazz.IUnionType):Ret(clazz.UAtomUnion)
	local nSign = vNewType:unionSign()
	local nSignToType = self._unionSignToType
	local nOldType = nSignToType[nSign]
	if not nOldType then
		vNewType:initTypeId(self:genTypeId())
		nSignToType[nSign] = vNewType
		return vNewType
	else
		return nOldType
	end
end

function.open TypeManager:_recordTypeUnionSign(vType)
	self._unionSignToType[vType:unionSign()] = vType
	return vType
end

function TypeManager:OpenFunction(vFunc:OrNil(clazz.OpenCaller)):Ret(clazz.OpenFunction)
	return self:_recordTypeUnionSign(OpenFunction.new(self, vFunc))
end

function TypeManager:LuaFunction():Ret(clazz.LuaFunction)
	return self:_recordTypeUnionSign(LuaFunction.new(self))
end

function TypeManager:LuaTable(vIsOpen:OrNil(Boolean)):Ret(clazz.LuaTable)
	return self:_recordTypeUnionSign(LuaTable.new(self, vIsOpen))
end

function TypeManager:Boolean(vValue:Boolean):Ret(clazz.BooleanLiteral)
	if vValue then
		return self.type.True
	else
		return self.type.False
	end
end

function TypeManager:Literal(vValue:Union(String, Number)):Ret(Union(clazz.NumberLiteral,clazz.StringLiteral))
	local t = type(vValue)
	local nLiteralDict = self._literalDict
	local nLiteralType = nLiteralDict[vValue]
	if not nLiteralType then
		if t == "number" then
			nLiteralType = NumberLiteral.new(self, vValue)
			nLiteralDict[vValue] = nLiteralType
		elseif t == "string" then
			nLiteralType = StringLiteral.new(self, vValue)
			nLiteralDict[vValue] = nLiteralType
		else
			error("literal must take number or string value"..t)
		end
		self:_recordTypeUnionSign(nLiteralType)
	end
	return nLiteralType
end

function TypeManager:TypeTuple(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeTuple)
	local nTypeList:List(clazz.UAllType) = {}
	for i=1, select("#", ...) do
		local nArg = select(i, ...)
		assert(nArg, "tuple can't take false or nil value")
		if Reference.is(nArg) then
			nTypeList[i] = nArg
		else
			nTypeList[i] = self:assertAllType(nArg)
		end
	end
	return TypeTuple.new(self, vNode, nTypeList)
end

function TypeManager:VoidRetTuples():Ret(clazz.RetTuples)
	const nFirst = self.type.Nil
	return RetTuples.new(self, nFirst, {[nFirst]=self:TypeTuple(self._runtime:getNode())})
end

function TypeManager:SingleRetTuples(vTypeTuple:clazz.UTypeTuple):Ret(clazz.RetTuples)
	const nFirst = vTypeTuple:get(1)
	return RetTuples.new(self, nFirst, {[nFirst]=vTypeTuple})
end

function TypeManager:retConcat(vNode:clazz.IAstNode, vRetTuples:clazz.RetTuples, vTypeTuple:clazz.UTypeTuple):Ret(clazz.RetTuples)
	const nFirstToTuple:Dict(clazz.UAllType, clazz.UTypeTuple) = {}
	vRetTuples:foreachWithFirst(function(vTuple, vFirst)
		nFirstToTuple[vFirst] = vTuple
	end)
	nFirstToTuple[vTypeTuple:get(1)] = vTypeTuple
	const nFirstRefer = self:Reference(false)
	local nTypeList:List(clazz.IAtomType) = {}
	nFirstRefer:setUnionAsync(vNode, function()
		for nFirst, _ in pairs(nFirstToTuple) do
			nFirst:foreachAwait(function(vSubType)
				nTypeList[#nTypeList + 1] = vSubType
			end)
		end
		return nTypeList
	end, function(vAtomUnion)
		local nCount = 0
		vAtomUnion:foreach(function(_)
			nCount = nCount + 1
		end)
		if nCount ~= #nTypeList then
			error("first type has intersect part")
		end
	end)
	return RetTuples.new(self, nFirstRefer, nFirstToTuple)
end

function TypeManager:buildMfn(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.MemberFunction)
	const nWildFn = self:buildFn(vNode, self.type.Truth, ...)
	const nPolyFn = self:buildPfn(vNode, function(vSelfType:clazz.UAllType):Ret(clazz.TypeFunction)
		const nRetTuples = nWildFn:getRetTuples()
		const nParTuple = nWildFn:getParTuple():replaceFirst(vSelfType)
		return self:TypeFunction(vNode, nParTuple, nRetTuples)
	end)
	return MemberFunction.new(self, vNode, nPolyFn, nWildFn)
end

function TypeManager:buildPfn(vNode:clazz.IAstNode, vFunc:AnyFunction):Ret(clazz.PolyFunction)
	const nInfo = debug.getinfo(vFunc)
	const nPolyParNum=nInfo.nparams
	if nInfo.isvararg then
		error("poly function can't be vararg")
	end
	return self:_recordTypeUnionSign(PolyFunction.new(self, vNode, vFunc, nPolyParNum))
end

function TypeManager:buildFn(vNode:clazz.IAstNode, ...:Truth):Ret(clazz.TypeFunction)
	local nParTuple = self:TypeTuple(vNode, ...)
	return self:_recordTypeUnionSign(TypeFunction.new(self, vNode, nParTuple, false))
end

function TypeManager:checkedFn(...:Truth):Ret(clazz.TypeFunction)
	local nParTuple = self:TypeTuple(self._runtime:getNode(), ...)
	return self:_recordTypeUnionSign(TypeFunction.new(self, self._runtime:getNode(), nParTuple, false))
end

function TypeManager:PolyFunction(vNode:clazz.IAstNode, vFunc:AnyFunction, vPolyParNum:Integer):Ret(clazz.PolyFunction)
	return self:_recordTypeUnionSign(PolyFunction.new(self, vNode, vFunc, vPolyParNum))
end

function TypeManager:MemberFunction(vNode:clazz.IAstNode, vPolyFn:clazz.PolyFunction):Ret(clazz.MemberFunction)
	return MemberFunction.new(self, vNode, vPolyFn, false)
end

function TypeManager:TypeFunction(vNode:clazz.IAstNode, vParTuple:clazz.UTypeTuple, vRetTuples:clazz.RetTuples):Ret(clazz.TypeFunction)
	assert(TypeTuple.is(vParTuple) or TypeTupleDots.is(vParTuple))
	assert(RetTuples.is(vRetTuples))
	const nFunc = TypeFunction.new(self, vNode, vParTuple, vRetTuples)
	return self:_recordTypeUnionSign(nFunc)
end

function TypeManager:RefineTerm(vType:clazz.UAllType):Ret(clazz.RefineTerm)
	local nType = vType:checkAtomUnion()
	nType:foreach(function(vSubType)
		if LuaTable.is(vSubType) then
			-- vSubType:checkDefine()
		end
	end)
	return RefineTerm.new(self, nType)
end

function TypeManager:makeMetaEventCom(vObject:Union(clazz.LuaTable, clazz.MetaObject)):Ret(clazz.MetaEventCom)
	return MetaEventCom.new(self, vObject)
end

function TypeManager:buildTemplate(vNode:clazz.IAstNode, vFunc:AnyFunction):Ret(clazz.Reference)
	const nInfo = debug.getinfo(vFunc)
	const nParNum = nInfo.nparams
	if nInfo.isvararg then
		error("template's parameter number is undetermined")
	end
	return self:buildTemplateWithParNum(vNode, vFunc, nParNum)
end

function TypeManager:buildTemplateWithParNum(vNode:clazz.IAstNode, vFunc:AnyFunction, vParNum:Integer):Ret(clazz.Reference)
	const nRefer = self:Reference(false)
	nRefer:setTemplateAsync(vNode, vFunc, vParNum)
	return nRefer
end

function TypeManager:AutoReference(vNode:clazz.IAstNode):Ret(clazz.Reference)
	const nRefer = self:Reference(false)
	nRefer:setAutoSync(vNode)
	return nRefer
end

function TypeManager:Reference(vName:Union(String, False)):Ret(clazz.Reference)
	const nRefer = Reference.new(self, vName)
	self._coToRefer[nRefer:getSelfCo()] = nRefer
	return nRefer
end

function TypeManager:mergePairList@<TValue>(vTypePairList:List(Struct {clazz.UAtomUnion, TValue})):Ret(clazz.UAtomUnion, Dict(clazz.IAtomType, TValue))
	local nCollection = self:TypeCollection()
	for _, nPair in ipairs(vTypePairList) do
		local nFieldType = nPair[1]
		if nFieldType:isReference() then
			nFieldType = nFieldType:checkAtomUnion()
			nPair[1] = nFieldType
		end
		nCollection:put(nFieldType)
	end
	local nKeyUnion = nCollection:mergeToAtomUnion()
	local nTypeDict:Dict(clazz.IAtomType, TValue) = {}
	for _, nPair in ipairs(vTypePairList) do
		local nKey = nPair[1]
		local nValueType = nPair[2]
		nKey:foreach(function(vSubType)
			local nIncludeType = assert(nKeyUnion:containAtom(vSubType), "merge error")
			local nOldType = nTypeDict[nIncludeType]
			if nOldType then
				nTypeDict[nIncludeType] = nOldType | nValueType
			else
				nTypeDict[nIncludeType] = nValueType
			end
		end)
	end
	return nKeyUnion, nTypeDict
end

function TypeManager:mergeToRefineTerm(vTypeCasePairList:List(clazz.TypeCasePair)):Ret(clazz.RefineTerm)
	const nKeyUnion, nTypeDict = self:mergePairList@<clazz.VariableCase>(vTypeCasePairList)
	return RefineTerm.new(self, nKeyUnion, nTypeDict)
end

function TypeManager:coWait(vWaitCo:Thread, vWaitSid:Integer, vDependCo:OrNil(Thread))
	assert(vWaitCo == coroutine.running(), "wait co must be current co")
	if vDependCo then
		const nWaitingRefer = self._coToRefer[vWaitCo]
		if not nWaitingRefer then
			const nDependRefer = self._coToRefer[vDependCo]
			error("can only call coWait in Reference's coroutine, try to get:"..tostring(nDependRefer))
		end
		local nCurCo:OrNil(Thread) = vDependCo
		while nCurCo do
			if nCurCo == vWaitCo then
				break
			else
				const nNextWaitingInfo = self._coToWaitingInfo[nCurCo]
				if nNextWaitingInfo then
					nCurCo = nNextWaitingInfo.dependCo
				else
					nCurCo = nil
					break
				end
			end
		end
		if nCurCo then
			error(Exception.new("recursive build type:"..tostring(self._coToRefer[nCurCo])))
		end
	else
		vDependCo = self._selfCo
	end
	self._coToWaitingInfo[vWaitCo] = {
		waitSid = vWaitSid,
		dependCo = vDependCo,
	}
	const nSucc = coroutine.yield()
	if not nSucc then
		error(self._coStop)
	end
end

function TypeManager:coWakeup(vWaitCo:Thread, vWaitSid:Integer)
	const nWaitingInfo = self._coToWaitingInfo[vWaitCo]
	if not nWaitingInfo then
		-- session is cancel
		print("session is cancel when wakeup")
		return
	elseif vWaitSid ~= nWaitingInfo.waitSid then
		print("wait sid not match when wakeup")
		return
	end
	self._coToWaitingInfo[vWaitCo] = nil
	self._coToScheduleParam[vWaitCo] = true
	if coroutine.running() == self._selfCo then
		self:_schedule()
	end
end

function TypeManager:coStart(vCo:Thread, vFunc:Fn())
	self._coToScheduleParam[vCo] = vFunc
	if coroutine.running() == self._selfCo then
		self:_schedule()
	end
end

function TypeManager:_schedule()
	while true do
		const nCoToParam = self._coToScheduleParam
		if not next(nCoToParam) then
			break
		else
			self._coToScheduleParam = {}@Dict(Thread, Union(True, Fn()))
			for co, param in pairs(nCoToParam) do
				assert(coroutine.resume(co, param))
			end
		end
	end
end

function TypeManager:makePair(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(Integer)
	const nLeftId, nRightId = vLeft.id, vRight.id
	assert(nLeftId ~= 0 and nRightId ~=0, "use id ==0")
	return (nLeftId << 32) + nRightId
end

function TypeManager:makeDuPair(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(Boolean, Integer, Integer)
	const nLeftId, nRightId = vLeft.id, vRight.id
	if nLeftId < nRightId then
		return false, (nLeftId << 32) + nRightId, (nRightId << 32) + nLeftId
	else
		return true, (nRightId << 32) + nLeftId, (nLeftId << 32) + nRightId
	end
end

function TypeManager:getTypePairInclude(vLeft:clazz.IAtomType, vRight:clazz.IAtomType):Ret(OrNil(clazz.Reference))
	const nPair = self:makePair(vLeft, vRight)
	return self._pairToInclude[nPair]
end

function TypeManager:attachPairInclude(vLeft:clazz.MetaObject, vRight:clazz.MetaObject, vWaitCreate:Boolean):Ret(OrNil(clazz.RelationEnum))
	const nInverse, nLRPair, nRLPair = self:makeDuPair(vLeft, vRight)
	if nInverse then
		vRight, vLeft = vLeft, vRight
	end
	local nIncludeRefer = self._pairToInclude[nLRPair]
	local nResultType:OrFalse(clazz.UAtomUnion) = false
	if vWaitCreate then
		if not nIncludeRefer then
			nIncludeRefer = self:Reference(false)
			self._pairToInclude[nLRPair] = nIncludeRefer
			nIncludeRefer:setUnionAsync(self._runtime:getNode(), function()
				const nLRInclude = vLeft:assumeIncludeObject({[nLRPair]=true}, vRight)
				const nRLInclude = vRight:assumeIncludeObject({[nRLPair]=true}, vLeft)
				if nLRInclude and nRLInclude then
					return {self:Literal("=")}
				elseif nLRInclude then
					return {self:Literal(">")}
				elseif nRLInclude then
					return {self:Literal("<")}
				else
					if vLeft:isInterface() and vRight:isInterface() then
						const nIntersect = vLeft:assumeIntersectInterface({[nLRPair]=true,[nRLPair]=true}, vRight)
						if nIntersect then
							return {self:Literal("&")}
						end
					end
					return {self:Literal("~")}
				end
			end)
		end
		nResultType = nIncludeRefer:waitTypeCom():getTypeAwait()
	else
		if nIncludeRefer then
			nResultType = nIncludeRefer:waitTypeCom():getResultType()
		end
	end
	if not nResultType then
		return nil
	else
		const nLiteral = nResultType @!! clazz.StringLiteral
		const nRelation = (nLiteral:getLiteral()) @!! clazz.RelationEnum
		if nInverse then
			if nRelation == ">" then
				return "<"
			elseif nRelation == "<" then
				return ">"
			else
				return nRelation
			end
		else
			return nRelation
		end
	end
end

function TypeManager:getRuntime():Ret(clazz.Runtime)
	return self._runtime
end

function TypeManager:literal2Primitive(vType:clazz.UAtomUnion):Ret(clazz.UAtomUnion)
	if BooleanLiteral.is(vType) then
		return self.type.Boolean:checkAtomUnion()
	elseif NumberLiteral.is(vType) then
		return self.type.Number
	elseif StringLiteral.is(vType) then
		return self.type.String
	else
		return vType
	end
end

function TypeManager:signTemplateArgs(vTypeList:IList(clazz.UAllType)):Ret(String)
	const nIdList:List(Integer) = {}
	for i=1,#vTypeList do
		nIdList[i] = vTypeList[i]!.id
	end
	return table.concat(nIdList, "-")
end

function TypeManager:genTypeId():Ret(Integer)
	local nNewId = self._typeIdCounter + 1
	self._typeIdCounter = nNewId
	return nNewId
end

function TypeManager:genSessionId():Ret(Integer)
	local nNewId = self._sessionIdCounter + 1
	self._sessionIdCounter = nNewId
	return nNewId
end

function TypeManager:dump()
	for k,v in pairs(self._unionSignToType) do
		print(k, tostring(v))
	end
end

return TypeManager
