
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const TypeCollection = require "thlua.manager.TypeCollection"
const Node = require "thlua.code.Node"
const Exception = require "thlua.Exception"

const Never = require "thlua.union.Never"
const StringLiteral = require "thlua.type.StringLiteral"
const String = require "thlua.type.String"
const NumberLiteral = require "thlua.type.NumberLiteral"
const Number = require "thlua.type.Number"
const BooleanLiteral= require "thlua.type.BooleanLiteral"
const Nil = require "thlua.type.Nil"
const Truth = require "thlua.type.Truth"
const MetaObject = require "thlua.object.MetaObject"
const LuaTable = require "thlua.object.LuaTable"
const LuaFunction = require "thlua.func.LuaFunction"
const NativeFunction = require "thlua.func.NativeFunction"
const TypeFunction = require "thlua.func.TypeFunction"
const Reference = require "thlua.type.Reference"
const Variable = require "thlua.func.Variable"

const MemberFunction = require "thlua.func.MemberFunction"

const StringLiteralUnion = require "thlua.union.StringLiteralUnion"
const NumberLiteralUnion = require "thlua.union.NumberLiteralUnion"
const ObjectUnion = require "thlua.union.ObjectUnion"
const FuncUnion = require "thlua.union.FuncUnion"
const FalsableUnion = require "thlua.union.FalsableUnion"
const ComplexUnion = require "thlua.union.ComplexUnion"

const RetTuples = require "thlua.tuple.RetTuples"
const TypeTuple = require "thlua.tuple.TypeTuple"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"

const native = require "thlua.native"

(@do
	let.class = import("thlua.type.TypeClass").class
end)

const function CoroutineInterrupt()::RetClass(class.CoroutineInterrupt)
	return {::Self()}
end

const TypeManager = {}
TypeManager.__index=TypeManager

function TypeManager.new(vRuntime:class.Runtime)::RetClass(class.TypeManager)
	const self = setmetatable({::Self()
		_runtime=vRuntime,
		-- type items
		type={},
		builtin={},
		_pairToContain={} @ Dict(Integer, class.Reference),
		_literalDict={}@Struct {[Number]=class.NumberLiteral, [String]=class.StringLiteral},
		_unionSignToType={}@Dict(String, class.UAtomUnion),
		_typeIdCounter=0@Number,
		-- coroutine items
		_coStop=CoroutineInterrupt(),
		_coToRefer={} @ Dict(Truth, class.Reference),
		_waitCoToSessionId={}@Dict(Truth, Integer),
		_sessionIdToWaitCo={}@Dict(Integer, Truth),
		_resumeCoList={}@List(Truth),
		_stopCoList={}@List(Truth),
		_referDependDict={}@Dict(class.Reference, class.Reference),
		_sessionIdCounter=0@Number,
		_selfCo=coroutine.running(),
	}, TypeManager)
	self.type.Never = Never.new(self)
	self.type.Nil = Nil.new(self)
	self.type.False = BooleanLiteral.new(self, false)
	self.type.True = BooleanLiteral.new(self, true)
	self.type.Number = Number.new(self)
	self.type.Integer = self.type.Number
	self.type.String = String.new(self)
	self.type.Truth = Truth.new(self)
	for k, nType in pairs(self.type @!! Dict(String, class.UAtomUnion)) do
		self:_recordTypeUnionSign(nType)
	end
	self.type.Boolean = self:buildUnion(vRuntime:getNode(), self.type.False, self.type.True)
	self.type.Any = self:buildUnion(vRuntime:getNode(), self.type.False, self.type.Nil, self.type.Truth)
	self.type.Object = (self:buildInterface(self._runtime:getNode(), {}, nil, false):checkAtomUnion()) @!! class.MetaObject
	self.builtin.string=native.make_string(self)
	self.builtin.next=native.make_next(self)
	self.builtin.inext=native.make_inext(self)
	self.builtin.bop={
		mathematic=native.make_mathematic(self),
		comparison=native.make_comparison(self),
		bitwise=native.make_bitwise(self),
		concat=native.make_concat(self),
	}
	return self
end

const BasicAtomMetatableSet:Dict(Truth, String)  = {
	[Nil]="Nil",
	[String]="String",
	[StringLiteral]="StringLiteral",
	[Number]="Number",
	[NumberLiteral]="NumberLiteral",
	[BooleanLiteral]="BooleanLiteral",
	[Truth]="Truth",
}

const AtomMetatableSet:Dict(Truth, String) = {
	[MetaObject]="MetaObject",
	[LuaTable]="LuaTable",
	[LuaFunction]="LuaFunction",
	[TypeFunction]="TypeFunction",
	[NativeFunction]="NativeFunction",
}

for k, v in pairs(BasicAtomMetatableSet) do
	AtomMetatableSet[k] = v
end

const AtomUnionMetatableSet:Dict(Truth, String) = {
	[Never]="Never",
	[NumberLiteralUnion]="NumberLiteralUnion",
	[StringLiteralUnion]="StringLiteralUnion",
	[FalsableUnion]="FalsableUnion",
	[ObjectUnion]="ObjectUnion",
	[FuncUnion]="FuncUnion",
	[ComplexUnion]="ComplexUnion",
}

for k, v in pairs(AtomMetatableSet) do
	AtomUnionMetatableSet[k] = v
end

function TypeManager:pcheckAtomOrReference(vData)::Ret(True, Union(class.Reference, class.IAtomType)):Ret(False, String)
	local meta = getmetatable(vData)
	if meta and (AtomMetatableSet[meta] or meta == Reference) then
		return true, vData @!! Union(class.Reference, class.IAtomType)
	else
		return false, "not atom or reference"
	end
end

function TypeManager:validIndexType(vType:class.UAtomUnion)::Ret(OrFalse(class.UIndexType))
	if LuaTable.is(vType) or TypeFunction.is(vType) or LuaFunction.is(vType) then
		return vType
	else
		return false
	end
end

function TypeManager:tryLuaTable(vType:class.UAllType)::Ret(False):Ret(True, class.LuaTable)
	if Reference.is(vType) then
		vType = vType:checkAtomUnion()
	end
	if not LuaTable.is(vType) then
		return false
	else
		return true, vType
	end
end

function TypeManager:basingByDefault(vType:class.UAtomUnion)
	vType:foreach(function(vAtomType)
		if LuaTable.is(vAtomType) then
			vAtomType:checkBaseObjectType()
		end
	end)
end

function TypeManager:isBasicAtomType(vData:class.IAtomType)::Ret(Boolean):nocheck()
	local meta = getmetatable(vData)
	if meta and BasicAtomMetatableSet[meta] then
		return true
	else
		return false
	end
end

function TypeManager:assertAllType(vData)::Ret(class.UAllType)
	local meta = getmetatable(vData)
	if meta and (AtomUnionMetatableSet[meta] or meta == Reference) then
		return vData @!! class.UAllType
	else
		error("assertAllType failed, type="..type(vData)..tostring(debug.traceback()))
	end
end

function TypeManager:_toType(vData:Any)::Ret(class.IAtomType):nocheck()
	local t = type(vData)
	if t == "table" then
		local meta = getmetatable(vData)
		if AtomMetatableSet[meta] then
			return vData
		else
			error("to type failed")
		end
	elseif t == "number" or t == "string" then
		return self:Literal(vData)
	else
		error("_toType("..t..") todo")
	end
end

function TypeManager:TypeCollection()::Ret(class.TypeCollection)
	return TypeCollection.new(self)
end

function TypeManager:_buildCombineObject(vNode:class.IAstNode, vIsInterface:Boolean, vObjectList:List(class.UAllType))::Ret(class.Reference)
	const nObjectRefer = self:Reference(false)
	nObjectRefer:setRawAsync(vNode, function()
		if vIsInterface then
			assert(#vObjectList>=1, "Interface must take at least one arguments")
		else
			assert(#vObjectList >= 2, "StructExtend must take at least one interface after struct")
		end
		const nMetaEventDict:Dict(String, class.IAtomType) = {}
		const nCollection = self:TypeCollection()
		const nAllValueDict:class.MemberDict = {}
		const nIntersectSet:Dict(class.MetaObject, True) = {}
		local nFirstObject:OrNil(class.MetaObject) = nil
		for i=1,#vObjectList do
			local nMetaObject = vObjectList[i]!
			if Reference.is(nMetaObject) then
				nMetaObject = nMetaObject:getTypeAwait()
			end
			if not MetaObject.is(nMetaObject) then
				error("Interface or Struct is expected here")
				break
			end
			if not nFirstObject then
				nFirstObject = nMetaObject
				if vIsInterface then
					assert(nFirstObject:isInterface(), "Intersect must take Interface")
					nIntersectSet[nMetaObject] = true
				else
					assert(not nFirstObject:isInterface(), "StructExtend must take Struct as first argument")
				end
			else
				assert(nMetaObject:isInterface(), vIsInterface
					and "Intersect must take Interface as args"
					or "StructExtend must take Interface after first argument")
				nIntersectSet[nMetaObject] = true
			end
			local nValueDict = nMetaObject:getMemberDict()
			const nBasicKey = nMetaObject:getKeyTypes()
			nBasicKey:foreach(function(vKeyType)
				nCollection:put(vKeyType)
				nAllValueDict[vKeyType] = nValueDict[vKeyType]
			end)
			for k,v in pairs(nMetaObject:getMetaEventDict()) do
				if nMetaEventDict[k] then
					error("bop "..k.." conflict when intersect")
				else
					nMetaEventDict[k] = v
				end
			end
		end
		const _, nMoreKeyRefer = nFirstObject:getKeyTypes()
		if nMoreKeyRefer then
			const nValueDict = nFirstObject:getMemberDict()
			for i, nType in ipairs(nMoreKeyRefer:getListAwait()) do
				nAllValueDict[nType] = nValueDict[nType]
			end
		end
		const nNewStruct = MetaObject.new(self, nCollection:mergeToAtomUnion(), nMoreKeyRefer)
		nNewStruct:init(nAllValueDict, nMetaEventDict)
		nNewStruct:initIntersectSet(nIntersectSet)
		return {self:_recordTypeUnionSign(nNewStruct)}
	end)
	return nObjectRefer
end

function TypeManager:buildStructExtend(vNode:class.IAstNode, vFirst:Union(Dict(Truth, Truth), class.MetaObject),
	...:Union(class.Reference, class.MetaObject))::Ret(class.Reference)
	const nStruct = MetaObject.is(vFirst) and vFirst or self:buildStruct(vNode, vFirst)
	const l:List(class.UAllType) = {nStruct, ...}
	return self:_buildCombineObject(vNode, false, l)
end

function TypeManager:buildIntersect(vNode:class.IAstNode, ...:Union(class.Reference, class.MetaObject))::Ret(class.Reference)
	const l:List(class.UAllType) = {...}
	return self:_buildCombineObject(vNode, true, l)
end

function TypeManager:checkedUnion(...:class.UAllType)::Ret(class.UAtomUnion)
	const l:List(class.UAllType) = {...}
	const nCollection = self:TypeCollection()
	for i=1, select("#", ...) do
		l[i]!:foreach(function(vAtomType)
			nCollection:put(vAtomType)
		end)
	end
	return nCollection:mergeToAtomUnion()
end

function TypeManager:buildUnion(vNode:class.IAstNode, ...:Truth)::Ret(class.Reference)
	local l = {...}
	const nLen = select("#", ...)
	local nNewRefer = self:Reference(false)
	nNewRefer:setRawAsync(vNode, function()
		local nTypeList:List(class.IAtomType) = {}
		for i=1, nLen do
			local nItem = l[i]
			if Reference.is(nItem) then
				local nList = nItem:getListAwait()
				table.move(nList, 1, #nList, #nTypeList + 1, nTypeList)
			else
				nTypeList[#nTypeList + 1] = self:_toType(nItem)
			end
		end
		return nTypeList
	end)
	return nNewRefer
end

function TypeManager:buildInterface(vNode:class.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, class.IAtomType)))::Ret(class.Reference)
	return self:_buildMetaObject(vNode, vTable, vMetaEventDict, true)
end

function TypeManager:buildStruct(vNode:class.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, class.IAtomType)))::Ret(class.Reference)
	return self:_buildMetaObject(vNode, vTable, vMetaEventDict, false)
end

function TypeManager:_buildMetaObject(vNode:class.IAstNode, vTable:Dict(Truth,Truth), vMetaEventDict:OrNil(Dict(String, class.IAtomType)), vIsInterface:Boolean)::Ret(class.Reference)
	const nObjectRefer = self:Reference(false)
	nObjectRefer:setRawAsync(vNode, function()
		const nBasicCollection = self:TypeCollection()
		const nNonBasicTypeList:List(class.IAtomType) = {}
		const nValueDict:Dict(class.IAtomType, Union(class.UAllType, class.MemberFunction)) = {}
		local nKeyCount = 0
		for nKey, nValue in pairs(vTable) do
			local nValueType:Union(Nil, class.UAllType, class.MemberFunction)
			if Reference.is(nValue) then
				nValueType = nValue
			elseif MemberFunction.is(nValue) then
				nValueType = nValue
			else
				nValueType = self:_toType(nValue)
			end
			if not Reference.is(nKey) then
				nKey = self:_toType(nKey)
			end
			nKey:foreachAwait(function(vAtomType)
				if vIsInterface then
					assert(vAtomType:isStrNumLiteral(), "interface must take string or number literal as key")
				end
				nKeyCount = nKeyCount + 1
				if self:isBasicAtomType(vAtomType) then
					nBasicCollection:put(vAtomType)
				else
					nNonBasicTypeList[#nNonBasicTypeList + 1] = vAtomType
				end
				if vAtomType:isSingleton() then
					nValueDict[vAtomType] = nValueType
				else
					assert(nValueType and not MemberFunction.is(nValueType), "valuetype with non-singleton key can't be nil or MemberFunction")
					nValueDict[vAtomType] = self:buildUnion(vNode, nValueType, self.type.Nil)
				end
			end)
		end
		local nFinalCount = 0
		const nBasicKey = nBasicCollection:mergeToAtomUnion()
		nBasicKey:foreach(function(_)
			nFinalCount = nFinalCount + 1
		end)
		local nNonBasicKeyRefer:OrFalse(class.Reference) = false
		if not vIsInterface then
			nNonBasicKeyRefer = self:Reference(false)
			nNonBasicKeyRefer:setRawAsync(vNode, function()
				return nNonBasicTypeList
			end, function(vMoreKey)
				vMoreKey:foreach(function(_)
					nFinalCount = nFinalCount + 1
				end)
				if nFinalCount ~= nKeyCount then
					error("Struct's key can not has intersect part")
				end
			end)
		else
			if nFinalCount ~= nKeyCount then
				error("Interface's key can not has intersect part")
			end
		end
		const nNewStruct = MetaObject.new(self, nBasicKey, nNonBasicKeyRefer)
		nNewStruct:init(nValueDict, vMetaEventDict)
		return {self:_recordTypeUnionSign(nNewStruct)}
	end)
	return nObjectRefer
end

function TypeManager:buildDict(vNode:class.IAstNode, vKey:class.UAtomUnion, vValue:class.UAllType)::Ret(Union(class.MetaObject, class.Reference))
	return self:buildStruct(vNode, {[vKey]=vValue}, {})
end

function TypeManager:buildList(vNode:class.IAstNode, vValue)::Ret(class.Reference)
	-- TODO struct use meta
	return self:buildStruct(vNode, {[self.type.Number]=vValue}, {})
end

function TypeManager:buildOrNil(vNode:class.IAstNode, ...:Truth)::Ret(class.Reference)
	return self:buildUnion(vNode, self.type.Nil, ...)
end

function TypeManager:buildOrFalse(vNode:class.IAstNode, ...:Truth)::Ret(class.Reference)
	return self:buildUnion(vNode, self.type.False, ...)
end

function TypeManager:_unifyUnion(vNewType:class.IUnionType)::Ret(class.UAtomUnion)
	local nSign = vNewType:unionSign()
	local nSignToType = self._unionSignToType
	local nOldType = nSignToType[nSign]
	if not nOldType then
		vNewType:initTypeId(self:genTypeId())
		nSignToType[nSign] = vNewType
		return vNewType
	else
		return nOldType
	end
end

function TypeManager:_recordTypeUnionSign(vType)::open()
	self._unionSignToType[vType:unionSign()] = vType
	return vType
end

function TypeManager:NativeFunction(vFunc:class.GenNativeFunc)::Ret(class.NativeFunction)
	return self:_recordTypeUnionSign(NativeFunction.new(self, vFunc))
end

function TypeManager:LuaFunction()::Ret(class.LuaFunction)
	return self:_recordTypeUnionSign(LuaFunction.new(self))
end

function TypeManager:LuaTable()::Ret(class.LuaTable)
	return self:_recordTypeUnionSign(LuaTable.new(self))
end

function TypeManager:Boolean(vValue)::Ret(class.BooleanLiteral)
	if vValue then
		return self.type.True
	else
		return self.type.False
	end
end

function TypeManager:Literal(vValue:Union(String, Number))::Ret(Union(class.NumberLiteral,class.StringLiteral))
	local t = type(vValue)
	local nLiteralDict = self._literalDict
	local nLiteralType = nLiteralDict[vValue]
	if not nLiteralType then
		if t == "number" then
			nLiteralType = NumberLiteral.new(self, vValue)
			nLiteralDict[vValue] = nLiteralType
		elseif t == "string" then
			nLiteralType = StringLiteral.new(self, vValue)
			nLiteralDict[vValue] = nLiteralType
		else
			error("literal must take number or string value"..t)
		end
		self:_recordTypeUnionSign(nLiteralType)
	end
	return nLiteralType
end

function TypeManager:Tuple(...:Truth)::Ret(class.TypeTuple)
	local nTypeList:List(class.UAllType) = {}
	for i=1, select("#", ...) do
		local nArg = select(i, ...)
		if Reference.is(nArg) then
			nTypeList[i] = nArg
		else
			nTypeList[i] = self:assertAllType(nArg)
		end
	end
	return TypeTuple.new(self, nTypeList)
end

function TypeManager:Variable(vIsGeneric:Boolean)::Ret(class.Variable)
	return Variable.new(self, vIsGeneric)
end

function TypeManager:VoidRetTuples()::Ret(class.RetTuples)
	return self:SingleRetTuples(self:Tuple())
end

function TypeManager:SingleRetTuples(vTypeTuple:class.TypeTuple)::Ret(class.RetTuples)
	local nRetTuples = RetTuples.new(self)
	return nRetTuples:Add(vTypeTuple)
end

function TypeManager:buildMfn(vNode:class.IAstNode, ...:Truth)::Ret(class.MemberFunction)
	local nArgTuple = self:Tuple(self.type.Truth, ...)
	return MemberFunction.new(self, nArgTuple, false)
end

function TypeManager:buildFn(vNode:class.IAstNode, ...:Truth)::Ret(class.TypeFunction)
	local nArgTuple = self:Tuple(...)
	return self:_recordTypeUnionSign(TypeFunction.new(self, nArgTuple, false, false))
end

function TypeManager:checkedFn(...:Truth)::Ret(class.TypeFunction)
	local nArgTuple = self:Tuple(...)
	return self:_recordTypeUnionSign(TypeFunction.new(self, nArgTuple, false, false))
end

function TypeManager:Function(vArgTuple:class.UTypeTuple, vRetTuples:class.RetTuples)::Ret(class.TypeFunction)
	assert(TypeTuple.is(vArgTuple) or TypeTupleDots.is(vArgTuple))
	assert(RetTuples.is(vRetTuples))
	local nFunc = TypeFunction.new(self, vArgTuple, vRetTuples, false)
	return self:_recordTypeUnionSign(nFunc)
end

function TypeManager:RefineTerm(vType:class.UAllType)::Ret(class.RefineTerm)
	local nType = vType:checkAtomUnion()
	nType:foreach(function(vSubType)
		if LuaTable.is(vSubType) then
			-- vSubType:checkDefine()
		end
	end)
	return RefineTerm.new(self, nType)
end

function TypeManager:TermTuple(vTermList:List(class.RefineTerm), vTermTupleOrNil:OrNil(class.TermTuple))::Ret(class.TermTuple)
	local nTermList:List(class.RefineTerm) = {}
	local nTypeList:List(class.UAtomUnion) = {}
	for _, nTerm in ipairs(vTermList) do
		local i = #nTermList + 1
		nTermList[i] = nTerm
		nTypeList[i] = nTerm:getType()
	end
	local nRepeatType:Union(False, class.UAllType) = false
	if vTermTupleOrNil then
		for i1=1, #vTermTupleOrNil do
			local nTerm = vTermTupleOrNil:get(i1)
			local i2 = #nTermList + 1
			nTermList[i2] = nTerm
			nTypeList[i2] = nTerm:getType()
		end
		nRepeatType = vTermTupleOrNil:getRepeatType()
	end
	const nTypeTuple = self:Tuple(table.unpack(nTypeList))
	if nRepeatType then
		const nTypeTupleDots = nTypeTuple:Dots(nRepeatType)
		return TermTuple.new(self, nTermList, nTypeTupleDots)
	else
		return TermTuple.new(self, nTermList, nTypeTuple)
	end
end

function TypeManager:Reference(vName:Union(String, False))::Ret(class.Reference)
	return Reference.new(self, vName)
end

function TypeManager:mergePairList(vTypePairList:List(Struct {class.UAtomUnion, class.UAtomUnion}))::Ret(class.UAtomUnion, Dict(class.IAtomType, class.UAtomUnion))
	local nCollection = self:TypeCollection()
	for _, nPair in ipairs(vTypePairList) do
		local nFieldType = nPair[1]
		if nFieldType:isReference() then
			nFieldType = nFieldType:checkAtomUnion()
			nPair[1] = nFieldType
		end
		nCollection:put(nFieldType)
	end
	local nKeyUnion = nCollection:mergeToAtomUnion()
	local nTypeDict:Dict(class.IAtomType, class.UAtomUnion) = {}
	for _, nPair in ipairs(vTypePairList) do
		local nKey = nPair[1]
		local nValueType = nPair[2]
		nKey:foreach(function(vSubType)
			local nContainType = assert(nKeyUnion:containAtom(vSubType), "merge error")
			local nOldType = nTypeDict[nContainType]
			if nOldType then
				nTypeDict[nContainType] = nOldType | nValueType
			else
				nTypeDict[nContainType] = nValueType
			end
		end)
	end
	return nKeyUnion, nTypeDict
end

function TypeManager:mergeToRefineTerm(vTypeCasePairList:List(class.TypeCasePair))::Ret(class.RefineTerm)
	local nCollection = self:TypeCollection()
	for _, nPair in ipairs(vTypeCasePairList) do
		local nFieldType = nPair[1]
		if nFieldType:isReference() then
			nFieldType = nFieldType:checkAtomUnion()
			nPair[1] = nFieldType
		end
		nCollection:put(nFieldType)
	end
	local nKeyUnion = nCollection:mergeToAtomUnion()
	local nTypeDict:Dict(class.IAtomType, class.TermCase) = {}
	for _, nPair in ipairs(vTypeCasePairList) do
		local nKey = nPair[1]
		local nCase = nPair[2]
		nKey:foreach(function(vSubType)
			local nContainType = assert(nKeyUnion:containAtom(vSubType), "merge error")
			local nOldCase = nTypeDict[nContainType]
			if nOldCase then
				nTypeDict[nContainType] = nOldCase | nCase
			else
				nTypeDict[nContainType] = nCase
			end
		end)
	end
	return RefineTerm.new(self, nKeyUnion, nTypeDict)
end

function TypeManager:yield(vSessionId:Integer, vDependRefer:class.Reference)
	const co = coroutine.running()
	local nWaitingRefer = self._coToRefer[co]
	if not nWaitingRefer then
		error(tostring(vDependRefer)..",can only call getTypeAwait in Reference's coroutine:")
	end
	local nCurRefer:OrNil(class.Reference) = vDependRefer
	while nCurRefer do
		if nCurRefer == nWaitingRefer then
			break
		else
			nCurRefer = self._referDependDict[nCurRefer]
		end
	end
	if nCurRefer then
		error(Exception.new("recursive build type"))
	end
	self._referDependDict[nWaitingRefer] = vDependRefer
	self._waitCoToSessionId[co] = vSessionId
	self._sessionIdToWaitCo[vSessionId] = co
	const nSucc = coroutine.yield()
	if not nSucc then
		error(self._coStop)
	end
	self._referDependDict[nWaitingRefer] = nil
end

function TypeManager:resume(vWakeupSid:Integer)
	const co = self._sessionIdToWaitCo[vWakeupSid]
	if not co then
		-- session is cancel
		print("error...session is cancel")
		return
	end
	const nWaitSid = self._waitCoToSessionId[co]
	assert(nWaitSid == vWakeupSid, "wait sid & wakeup sid not match")
	self._sessionIdToWaitCo[vWakeupSid] = nil
	self._waitCoToSessionId[co] = nil
	const nList = self._resumeCoList
	nList[#nList + 1] = co
end

function TypeManager:kill(vWaitCo:Truth)
	const nWaitSid = self._waitCoToSessionId[vWaitCo]
	if nWaitSid then
		self._waitCoToSessionId[vWaitCo] = nil
		self._sessionIdToWaitCo[nWaitSid] = nil
		const nList = self._stopCoList
		nList[#nList + 1] = vWaitCo
	else
		-- session is canceled
	end
end

function TypeManager:fork(vRefer:class.Reference, vFunc:Fn())
	const co = coroutine.create(function()
		const ok, nExc = pcall(vFunc)
		if not ok then
			if Exception.is(nExc) then
				nExc:fixNode(vRefer:getAssignNode())
				error(nExc)
			else
				error(Exception.new(tostring(nExc), vRefer:getAssignNode()))
			end
		end
	end)
	self._coToRefer[co] = vRefer
	self._resumeCoList[#self._resumeCoList + 1] = co
	if coroutine.running() == self._selfCo then
		self:_schedule()
	end
end

function TypeManager:_schedule()
	while true do
		const nResumeList = self._resumeCoList
		const nStopList = self._stopCoList
		if #nResumeList == 0 and #nStopList == 0 then
			break
		else
			self._resumeCoList = {} @List(Truth)
			self._stopCoList = {} @List(Truth)
			for i, co in ipairs(nResumeList) do
				assert(coroutine.resume(co, true))
			end
			for i, co in ipairs(nStopList) do
				assert(coroutine.resume(co, false))
			end
		end
	end
end

function TypeManager:attachObjPairContain(vLeft:class.MetaObject, vRight:class.MetaObject)::Ret(Integer, class.Reference)
	local nPair = (vLeft.id << 32) + vRight.id
	local nContainRefer = self._pairToContain[nPair]
	if not nContainRefer then
		nContainRefer = self:Reference(false)
		self._pairToContain[nPair] = nContainRefer
		nContainRefer:setRawAsync(self._runtime:getNode(), function()
			local nContain = vLeft:assumeContainObject({[nPair]=true}, vRight)
			return {nContain and self.type.True or self.type.False}
		end)
	end
	return nPair, nContainRefer
end

function TypeManager:attachFnPairContain(vLeft:class.TypeFunction, vRight:class.TypeFunction)::Ret(Integer, class.Reference)
	local nPair = (vLeft.id << 32) + vRight.id
	local nContainRefer = self._pairToContain[nPair]
	if not nContainRefer then
		nContainRefer = self:Reference(false)
		self._pairToContain[nPair] = nContainRefer
		nContainRefer:setRawAsync(self._runtime:getNode(), function()
			local nContain = vLeft:assumeContainFn({[nPair]=true}, vRight)
			return {nContain and self.type.True or self.type.False}
		end)
	end
	return nPair, nContainRefer
end

function TypeManager:getRuntime()::Ret(class.Runtime)
	return self._runtime
end

function TypeManager:literal2Primitive(vType:class.UAtomUnion)::Ret(class.UAtomUnion)
	if BooleanLiteral.is(vType) then
		return self.type.Boolean:checkAtomUnion()
	elseif NumberLiteral.is(vType) then
		return self.type.Number
	elseif StringLiteral.is(vType) then
		return self.type.String
	else
		return vType
	end
end

function TypeManager:genTypeId()::Ret(Integer)
	local nNewId = self._typeIdCounter + 1
	self._typeIdCounter = nNewId
	return nNewId
end

function TypeManager:genSessionId()::Ret(Integer)
	local nNewId = self._sessionIdCounter + 1
	self._sessionIdCounter = nNewId
	return nNewId
end

function TypeManager:dump()
	for k,v in pairs(self._unionSignToType) do
		print(k, tostring(v))
	end
end

return TypeManager
