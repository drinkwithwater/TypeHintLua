
local TypeFunction = require "thlua.func.TypeFunction"
local BaseTable = require "thlua.object.BaseTable"
local Truth = require "thlua.type.Truth"
local StringLiteral = require "thlua.type.StringLiteral"
local NumberLiteral = require "thlua.type.NumberLiteral"
local Number = require "thlua.type.Number"
local Exception = require "thlua.Exception"
local VariableCase = require "thlua.term.VariableCase"

local native = {}

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.StringToAtomUnion = Dict(String, clazz.UAtomUnion)
end)

function native._toTable(vManager:clazz.TypeManager, vTable:StringToAtomUnion):Ret(clazz.BaseTable)
	local nPairList:List(Struct{clazz.UAtomUnion, clazz.UAtomUnion}) = {}
	for k,v in pairs(vTable) do
		nPairList[#nPairList + 1] = {
			vManager:Literal(k), v
		}
	end
  local nKeyUnion, nTypeDict = vManager:mergePairList@<clazz.UAtomUnion>(nPairList)
	local nTable = vManager:AutoTable()
	nTable:initByKeyValue(nKeyUnion, nTypeDict)
	return nTable
end

function native.make(vRuntime:clazz.Runtime):Ret(clazz.BaseTable)
	const nManager = vRuntime:getTypeManager()
	const global:StringToAtomUnion = {
		--- meta_native
		setmetatable=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nTerm1 = vTermTuple:get(vContext, 1)
			local nType1 = nTerm1:getType()
			local nType2 = vTermTuple:get(vContext, 2):getType()
			if nType1:isUnion() or nType2:isUnion() then
				vContext:error("set metatable can't take union")
			else
				nType1 = nType1:checkAtomUnion()
				nType2 = nType2:checkAtomUnion()
				if BaseTable.is(nType2) then
					nManager:basingByDefault(nType2)
					nType1:native_setmetatable(vContext, nType2)
				else
					vContext:error("metatable must be table")
				end
				return nTerm1
			end
		end),
		getmetatable=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nTerm1 = vTermTuple:get(vContext, 1)
			local nTypeCaseList:List(clazz.TypeCasePair) = {}
			nTerm1:foreach(function(vType1, vVariableCase)
				nTypeCaseList[#nTypeCaseList + 1] = {
					vType1:native_getmetatable(vContext),
					vVariableCase,
				}
			end)
			return vContext:mergeToRefineTerm(nTypeCaseList)
		end),
		next=nManager.builtin.next,
		ipairs=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nType1 = vTermTuple:get(vContext, 1):getType()
			assert(not nType1:isUnion(), "ipairs for union type TODO")
			local nTypeTuple = nType1:meta_ipairs(vContext) or nManager:TypeTuple(vContext:getNode(), nManager.builtin.inext, nType1, nManager:Literal(0))
			return nTypeTuple:makeTermTuple(vContext)
		end),
		pairs=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			const nType1 = vTermTuple:get(vContext, 1):getType()
			assert(not nType1:isUnion(), "pairs for union type TODO")
			const nTypeTuple = nType1:meta_pairs(vContext) or nManager:TypeTuple(vContext:getNode(), nManager.builtin.next, nType1, nManager.type.Nil)
			return nTypeTuple:makeTermTuple(vContext)
		end),
		rawequal=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			--self:argnum_warn(2, vTermTuple)
			--return self:check_call(vTermTuple)
			print("rawequal TODO")
			return vContext:RefineTerm(nManager.type.Boolean)
		end),
		rawget=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			const nType1 = vTermTuple:get(vContext, 1):getType()
			const nType2 = vTermTuple:get(vContext, 2):getType()
			assert(not nType1:isUnion(), "rawget for union type TODO")
			assert(not nType2:isUnion(), "rawget for union type TODO")
			return vContext:RefineTerm(nType1:native_rawget(vContext, nType2))
		end),
		rawset=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			--self:argnum_warn(3, vTermTuple)
			--return self:check_call(vTermTuple)
			print("rawset TODO")
			return vContext:FixedTermTuple({})
		end),
		tostring=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			return vContext:RefineTerm(nManager.type.String)
		end),
		type=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nTerm = vTermTuple:get(vContext, 1)
			local nTypeCaseList:List(clazz.TypeCasePair) = {}
			nTerm:foreach(function(vType, vVariableCase)
				nTypeCaseList[#nTypeCaseList + 1] = {
					vType:native_type(), vVariableCase
				}
			end)
			return vContext:mergeToRefineTerm(nTypeCaseList)
		end),
		--- not meta_native
		select=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			const nFirstType = vTermTuple:get(vContext, 1):getType()
			if nFirstType == nManager:Literal("#") then
				return vContext:RefineTerm(nManager.type.Integer)
			else
				if NumberLiteral.is(nFirstType) then
					local nStart = nFirstType:getLiteral()
					if nStart > 0 then
						return vTermTuple:select(vContext, nStart + 1)
					elseif nStart < 0 then
						vContext:error("select first < 0 TODO")
						return vContext:FixedTermTuple({})
					else
						vContext:error("select's first arguments is zero")
						return vContext:FixedTermTuple({})
					end
				else
					if Number.is(nFirstType) then
						const nCollection = nManager:TypeCollection()
						for i=2, #vTermTuple do
							const nType = vTermTuple:get(vContext, i):getType()
							nCollection:put(nType)
						end
						const nRepeatType = vTermTuple:getRepeatType()
						if nRepeatType then
							nCollection:put(nRepeatType)
						end
						const nFinalType = nCollection:mergeToAtomUnion()
						if nRepeatType then
							return nManager:TypeTuple(vContext:getNode()):Dots(nRepeatType):makeTermTuple(vContext)
						else
							const nReList:List(clazz.UAtomUnion) = {}
							for i=2, #vTermTuple do
								nReList[#nReList + 1] = nFinalType
							end
							return nManager:TypeTuple(vContext:getNode(), table.unpack(nReList)):makeTermTuple(vContext)
						end
					else
						vContext:error("select's first value must be number or number-literal")
						return vContext:FixedTermTuple({})
					end
				end
			end
		end),
		print=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			return vContext:FixedTermTuple({})
		end),
		tprint=nManager:autoNativeOpenFunction(function(vContext, vTermTuple)
			vContext:info(vTermTuple)
			return vContext:getTailContext():FixedTermTuple({})
		end),
		ttprint=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			vContext:info(vTermTuple:checkTypeTuple())
			return vContext:FixedTermTuple({})
		end),
		tonumber=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			--self:argnum_warn(1, vTermTuple)
			--local nData = vTermTuple:get(1)
			print("tonumber TODO")
			return vContext:RefineTerm(nManager:checkedUnion(nManager.type.False, nManager.type.Number))
		end),
		require=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFileName = vTermTuple:get(vContext, 1):getType()
			if StringLiteral.is(nFileName) then
				local nPath = nFileName:getLiteral()
				return vRuntime:require(nPath)
			else
				vContext:error("TODO require take non-StringLiteral type ")
			end
		end),
		-- function take open context, not oper context
		pcall=nManager:autoNativeOpenFunction(function(vContext, vTermTuple)
			const nHeadContext = vContext:getHeadContext()
			const nFunc = vTermTuple:get(nHeadContext, 1):checkRefineTerm(nHeadContext)
			const nArgs = vTermTuple:select(nHeadContext, 2)
			const nTermTuple = vContext:getParentContext():META_CALL(vContext:getNode(), nFunc, function() return nArgs end)
			const nRetFirst = nHeadContext:RefineTerm(nManager.type.True)
			-- TODO combine first & second
			return vContext:operContext():UTermTupleByAppend({nRetFirst}, nTermTuple)
		end),
		xpcall=nManager:autoNativeOpenFunction(function(vContext, vTermTuple)
			const nHeadContext = vContext:getHeadContext()
			const nFunc = vTermTuple:get(nHeadContext, 1):checkRefineTerm(nHeadContext)
			const nArgs = vTermTuple:select(nHeadContext, 3)
			const nTermTuple = vContext:getParentContext():META_CALL(vContext:getNode(), nFunc, function() return nArgs end)
			const nRetFirst = nHeadContext:RefineTerm(nManager.type.True)
			-- TODO combine first & second
			return vContext:operContext():UTermTupleByAppend({nRetFirst}, nTermTuple)
		end),
		error=nManager:autoNativeOpenFunction(function(vContext, vTermTuple)
			const nRegion = vContext:getParentContext():getRegion()
			assert(nRegion, "error in a context without region")
			nRegion:nativeError()
			return vContext:getTailContext():FixedTermTuple({})
		end),
		assert=nManager:autoNativeOpenFunction(function(vContext, vTermTuple)
			const nRegion = vContext:getParentContext():getRegion()
			assert(nRegion, "error in a context without region")
			const nHeadContext = vContext:getHeadContext()
			const nFirst = vTermTuple:get(nHeadContext, 1):checkRefineTerm(nHeadContext)
			nRegion:nativeAssert(nFirst)
			const nLogicContext = vContext:newLogicContext(vContext:getNode())
			return vContext:getTailContext():FixedTermTuple({nLogicContext:logicTrueTerm(nFirst)})
		end),
	}
	for k,v in pairs(global @ Dict(String, clazz.OpenFunction)) do
		v:set_name(k)
	end

	global.string=nManager.builtin.string

	global.os=native.make_os(nManager)
	global.math=native.make_math(nManager)
	global.debug=native.make_debug(nManager)
	global.table=native.make_table(nManager)
	global.io=native.make_io(nManager)
	global.coroutine=native.make_coroutine(nManager)

	-- global.next = vRuntime.func.next
	const nGlobalTable = native._toTable(vRuntime:getTypeManager(), global)
    nGlobalTable:setName("_G")

	return nGlobalTable
end

function native.make_math(vManager:clazz.TypeManager):Ret(clazz.BaseTable)
	const type = vManager.type
	const math:StringToAtomUnion = {
		random=vManager:checkedFn():Dots(type.Number):Ret(type.Number),
		max=vManager:checkedFn(type.Number):Dots(type.Number):Ret(type.Number),
		min=vManager:checkedFn(type.Number):Dots(type.Number):Ret(type.Number),
		tointeger=vManager:checkedFn(type.Any):Ret(vManager:checkedUnion(type.Number, type.Nil)),
	}
	const nTable = native._toTable(vManager, math)
	nTable:setName("math")
	return nTable
end

function native.make_debug(vManager:clazz.TypeManager):Ret(clazz.BaseTable)
	-- debug.traceback's arguments TODO
	const type = vManager.type
	const nInfo = vManager:buildStruct(vManager:getRuntime():getNode(), {
		namewhat=type.String,
		isvararg=type.Boolean,
		ntransfer=type.Integer,
		nups=type.Integer,
		currentline=type.Integer,
		func=type.Truth,
		nparams=type.Integer,
		short_src=type.String,
		ftransfer=type.Integer,
		istailcall=type.Boolean,
		lastlinedefined=type.Integer,
		linedefined=type.Integer,
		source=type.String,
		what=type.String,
	})
	const debug:StringToAtomUnion = {
		traceback=vManager:checkedFn():Ret(type.String),
		getinfo=vManager:checkedFn(vManager:checkedUnion(vManager.type.Integer, type.AnyFunction)):Ret(nInfo),
	}
	const nTable = native._toTable(vManager, debug)
	nTable:setName("debug")
	return nTable
end

function native.make_io(vManager:clazz.TypeManager):Ret(clazz.BaseTable)
	const type = vManager.type
	const io:StringToAtomUnion = {
		read=vManager:checkedFn(vManager:checkedUnion(type.String, type.Number)):Ret(vManager:checkedUnion(type.String, type.Nil)),
		write=vManager:checkedFn(type.String),
		flush=vManager:checkedFn(),
	}
	const nTable = native._toTable(vManager, io)
	nTable:setName("io")
	return nTable
end

function native.make_coroutine(vManager:clazz.TypeManager):Ret(clazz.BaseTable)
	const type = vManager.type
	const nStatusUnion = vManager:checkedUnion(
		vManager:Literal("running"),
		vManager:Literal("suspended"),
		vManager:Literal("normal"),
		vManager:Literal("dead")
	)
	const co:StringToAtomUnion = {
		create=vManager:checkedFn(type.AnyFunction):Ret(type.Thread),
		running=vManager:checkedFn():Ret(type.Thread, type.Boolean),
		resume=vManager:checkedFn(type.Thread):Dots(type.Any):Ret(type.True):Ret(type.False,type.String),
		yield=vManager:checkedFn():Ret(type.Truth),
		status=vManager:checkedFn(type.Thread):Ret(nStatusUnion),
	}
	local nTable = native._toTable(vManager, co)
	nTable:setName("coroutine")
	return nTable
end

function native.make_os(vManager:clazz.TypeManager):Ret(clazz.BaseTable)
	const type = vManager.type
	const string:StringToAtomUnion = {
		clock=vManager:checkedFn():Ret(type.Number),
	}
	const nTable = native._toTable(vManager, string)
	nTable:setName("os")
	return nTable
end

function native.make_string(vManager:clazz.TypeManager):Ret(clazz.BaseTable)
	const type = vManager.type
	const string:StringToAtomUnion = {
		rep=vManager:checkedFn(type.String, type.Integer, vManager:checkedUnion(type.String, type.Integer, type.Nil)):Ret(type.String),
		upper=vManager:checkedFn(type.String):Ret(type.String),
		format=vManager:checkedFn(type.String):Dots(type.Any):Ret(type.String),
		gmatch=vManager:checkedFn(type.String, type.String):Ret(
			vManager:checkedFn():Ret(vManager:checkedUnion(type.String, type.Nil))
		),
		sub=vManager:checkedFn(type.String, type.Integer, vManager:checkedUnion(type.Integer, type.Nil)):Ret(type.String, type.Integer),
		gsub=vManager:checkedFn(type.String, type.String, type.String):Ret(type.String, type.Integer),
		match=vManager:checkedFn(type.String, type.String):Ret():Ret(type.String),
		find=vManager:checkedFn(type.String, type.String, type.Integer, vManager:checkedUnion(type.True, type.Nil)):Ret(type.Nil):Ret(type.Integer, type.Integer),
	}
	const nTable = native._toTable(vManager, string)
	nTable:setName("string")
	return nTable
end

function native.make_table(vManager:clazz.TypeManager):Ret(clazz.BaseTable)
	const function checkList(vContext:clazz.OperContext, vType:clazz.UAtomUnion, vKey:String):Ret(clazz.UAtomUnion)
		const nNumber = vManager.type.Number
		const nElementCollection = vManager:TypeCollection()
		vType:foreach(function(vSubType)
			const nLenType = vSubType:meta_len(vContext)
			if not Number.is(nLenType) then
				vContext:error("table."..vKey.." must take list-like variable")
				return
			end
			const nValue = vSubType:meta_get(vContext, nNumber)
			nElementCollection:put(nValue)
		end)
		return nElementCollection:mergeToAtomUnion()
	end
	const table:StringToAtomUnion = {
		sort=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			checkList(vContext, nType, "sort")
			return vManager:TypeTuple(vContext:getNode()):makeTermTuple(vContext)
		end),
		concat=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			checkList(vContext, nType, "concat")
			return vContext:FixedTermTuple({vContext:RefineTerm(vManager.type.String)})
		end),
		insert=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			checkList(vContext, nType, "insert")
			return vContext:FixedTermTuple({})
		end),
		remove=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			const nRetType = checkList(vContext, nType, "remove")
			return vContext:FixedTermTuple({vContext:RefineTerm(nRetType)})
		end),
		unpack=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			local nNumber = vManager.type.Number
			local nCollection = vManager:TypeCollection()
			nType:foreach(function(vSubType)
				local nLenType = vSubType:meta_len(vContext)
				if not (Number.is(nLenType) or NumberLiteral.is(nLenType)) then
					vContext:error("__len must return number when concat")
					return
				end
				local nValueType = vSubType:meta_get(vContext, nNumber)
				nCollection:put(nValueType)
			end)
			local nRetType = nCollection:mergeToAtomUnion()
			return vManager:TypeTuple(vContext:getNode()):Dots(nRetType:notnilType()):makeTermTuple(vContext)
		end),
		move=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			-- move TODO
			-- vContext:error("table move")
			return vTermTuple:get(vContext, 5)
		end)
	}
	local nTable = native._toTable(vManager, table)
	nTable:setName("table")
	return nTable
end

function native.make_inext(vManager:clazz.TypeManager):Ret(clazz.IAtomType)
	local nNumber = vManager.type.Number
	local nNil = vManager.type.Nil
	return vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
		local nType1 = vTermTuple:get(vContext, 1):getType()
		nType1 = nType1:trueType()
		if nType1:isUnion() then
			error(Exception.new("TODO: next Union type"))
		else
			local nNotNilValue = nType1:meta_get(vContext, nNumber):notnilType()
			local nValueTerm = vContext:RefineTerm(vManager:checkedUnion(nNotNilValue, nNil))
			local nKeyValue:Dict(clazz.IAtomType, clazz.UAtomUnion) = {
				[nNumber]=nNotNilValue,
				[nNil]=nNil,
			}
			local nTypeCaseList:List(clazz.TypeCasePair) = {}
			for nOneKey, nOneValue in pairs(nKeyValue) do
				local nCase = VariableCase.new()
				nCase:put_and(nValueTerm:attachImmutVariable(), nOneValue)
				nTypeCaseList[#nTypeCaseList + 1] = {
					nOneKey, nCase
				}
			end
			local nKeyTerm = vContext:mergeToRefineTerm(nTypeCaseList)
			return vContext:FixedTermTuple({nKeyTerm, nValueTerm})
		end
	end)
end

function native.make_next(vManager:clazz.TypeManager):Ret(clazz.IAtomType)
	return vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
		local nType1 = vTermTuple:get(vContext, 1):getType()
		nType1 = nType1:trueType()
		local nType2 = vTermTuple:get(vContext, 2):getType()
		if nType1:isUnion() then
			error(Exception.new("TODO: next Union type"))
		else
			local nValueType, nKeyValue = nType1:native_next(vContext, nType2)
			local nValueTerm = vContext:RefineTerm(nValueType)
			local nTypeCaseList:List(clazz.TypeCasePair) = {}
			for nOneKey, nOneValue in pairs(nKeyValue) do
				local nCase = VariableCase.new()
				nCase:put_and(nValueTerm:attachImmutVariable(), nOneValue)
				nTypeCaseList[#nTypeCaseList + 1] = {
					nOneKey, nCase
				}
			end
			local nKeyTerm = vContext:mergeToRefineTerm(nTypeCaseList)
			return vContext:FixedTermTuple({nKeyTerm, nValueTerm})
		end
	end)
end

function native.make_mathematic(vManager:clazz.TypeManager):Ret(clazz.IAtomType)
	local nNumber = vManager.type.Number
	return vManager:checkedFn(nNumber, nNumber):Ret(nNumber)
end

function native.make_comparison(vManager:clazz.TypeManager):Ret(clazz.IAtomType)
	local nNumber = vManager.type.Number
	return vManager:checkedFn(nNumber, nNumber):Ret(vManager.type.Boolean)
end

function native.make_bitwise(vManager:clazz.TypeManager):Ret(clazz.TypeFunction)
	local nNumber = vManager.type.Number
	return vManager:checkedFn(nNumber, nNumber):Ret(nNumber)
end

function native.make_concat(vManager:clazz.TypeManager):Ret(clazz.TypeFunction)
	local nType = vManager:checkedUnion(vManager.type.String, vManager.type.Number)
	return vManager:checkedFn(nType, nType):Ret(vManager.type.String)
end

return native

