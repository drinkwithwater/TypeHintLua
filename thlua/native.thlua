
const TermTuple = require "thlua.tuple.TermTuple"
local TypedFunction = require "thlua.func.TypedFunction"
local SealTable = require "thlua.object.SealTable"
local OpenTable = require "thlua.object.OpenTable"
local AutoTable = require "thlua.object.AutoTable"
local Truth = require "thlua.type.Truth"
local StringLiteral = require "thlua.type.StringLiteral"
local NumberLiteral = require "thlua.type.NumberLiteral"
local Number = require "thlua.type.Number"
local Exception = require "thlua.Exception"
local VariableCase = require "thlua.term.VariableCase"

local native = {}

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.StringToAtomUnion = Dict(String, clazz.UAtomUnion)
end)

function native._toTable(vManager:clazz.TypeManager, vTable:StringToAtomUnion):Ret(clazz.AutoTable)
	const nPairList:List(Struct{clazz.UAtomUnion, clazz.UAtomUnion}) = {}
	for k,v in pairs(vTable) do
		nPairList[#nPairList + 1] = {
			vManager:Literal(k), v
		}
	end
  const nKeyUnion, nTypeDict = vManager:typeMapReduce@<clazz.UAtomUnion>(nPairList, function(vList)
		return vManager:unionReduceType(vList)
	end)
	const nTable = AutoTable.new(vManager, vManager:getRuntime():getNode(), vManager:getRuntime():getRootStack())
	nTable:initByKeyValue(vManager:getRuntime():getNode(), nKeyUnion, nTypeDict)
	return nTable
end

function native.make(vRuntime:clazz.BaseRuntime):Ret(clazz.AutoTable)
	const nManager = vRuntime:getTypeManager()
	const global:StringToAtomUnion = {
		--- meta_native
		setmetatable=nManager:stackNativeOpenFunction(function(vStack, vTermTuple)
			return vStack:withOnePushContext(vStack:getNode(), function(vContext)
				const nTerm1 = vTermTuple:checkFixed(vContext, 1)
				local nType1 = nTerm1:getType()
				local nType2 = vTermTuple:checkFixed(vContext, 2):getType()
				if nType1:isUnion() or nType2:isUnion() then
					vContext:error("setmetatable can't take union type")
				else
					nType1 = nType1:checkAtomUnion()
					nType2 = nType2:checkAtomUnion()
					if SealTable.is(nType2) or OpenTable.is(nType2) then
						nType2:setAssigned(vContext)
						nType1:native_setmetatable(vContext, nType2)
					else
						vContext:error("metatable must be table but get:"..tostring(nType2))
					end
				end
				vContext:openPushReturn(nTerm1)
			end):mergeFirst()
		end),
		getmetatable=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nTerm1 = vTermTuple:get(vContext, 1)
			local nTypeCaseList:List(clazz.TypeCasePair) = {}
			nTerm1:foreach(function(vType1, vVariableCase)
				nTypeCaseList[#nTypeCaseList + 1] = {
					vType1:native_getmetatable(vContext),
					vVariableCase,
				}
			end)
			return vContext:mergeToRefineTerm(nTypeCaseList)
		end),
		next=nManager.builtin.next,
		ipairs=nManager:metaNativeOpenFunction(function(vContext, vType)
			const nTypeTuple = vType:meta_ipairs(vContext) or nManager:TypeTuple(vContext:getNode(), nManager.builtin.inext, vType, nManager:Literal(0))
			vContext:pushFirstAndTuple(nTypeTuple:get(1):checkAtomUnion(), nTypeTuple)
		end),
		pairs=nManager:metaNativeOpenFunction(function(vContext, vType)
			const nTypeTuple = vType:meta_pairs(vContext) or nManager:TypeTuple(vContext:getNode(), nManager.builtin.next, vType, nManager.type.Nil)
			vContext:pushFirstAndTuple(nTypeTuple:get(1):checkAtomUnion(), nTypeTuple)
		end),
		rawequal=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			--self:argnum_warn(2, vTermTuple)
			--return self:check_call(vTermTuple)
			print("rawequal TODO")
			return vContext:RefineTerm(nManager.type.Boolean)
		end),
		rawget=nManager:stackNativeOpenFunction(function(vStack, vTermTuple)
			return vStack:withOnePushContext(vStack:getNode(), function(vContext)
				const nType1 = vTermTuple:checkFixed(vContext, 1):getType()
				const nType2 = vTermTuple:checkFixed(vContext, 2):getType()
				assert(not nType1:isUnion(), "rawget for union type TODO")
				assert(not nType2:isUnion(), "rawget for union type TODO")
				vContext:openPushReturn(vContext:RefineTerm(nType1:native_rawget(vContext, nType2)))
			end):mergeFirst()
		end),
		rawset=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			--self:argnum_warn(3, vTermTuple)
			--return self:check_call(vTermTuple)
			print("rawset TODO")
			return vContext:FixedTermTuple({})
		end),
		collectgarbage=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			return vContext:FixedTermTuple({})
		end),
		tostring=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			return vContext:RefineTerm(nManager.type.String)
		end),
		type=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nTerm = vTermTuple:get(vContext, 1)
			local nTypeCaseList:List(clazz.TypeCasePair) = {}
			nTerm:foreach(function(vType, vVariableCase)
				nTypeCaseList[#nTypeCaseList + 1] = {
					vType:native_type(), vVariableCase
				}
			end)
			return vContext:mergeToRefineTerm(nTypeCaseList)
		end),
		--- not meta_native
		select=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			const nFirstType = vTermTuple:get(vContext, 1):getType()
			if nFirstType == nManager:Literal("#") then
				return vContext:RefineTerm(nManager.type.Integer)
			else
				if NumberLiteral.is(nFirstType) then
					local nStart = nFirstType:getLiteral()
					if nStart > 0 then
						return vTermTuple:select(vContext, nStart + 1)
					elseif nStart < 0 then
						vContext:error("select first < 0 TODO")
						return vContext:FixedTermTuple({})
					else
						vContext:error("select's first arguments is zero")
						return vContext:FixedTermTuple({})
					end
				else
					if Number.is(nFirstType) then
						const nCollection = nManager:TypeCollection()
						for i=2, #vTermTuple do
							const nType = vTermTuple:get(vContext, i):getType()
							nCollection:put(nType)
						end
						const nRepeatType = vTermTuple:getRepeatType()
						if nRepeatType then
							nCollection:put(nRepeatType)
						end
						const nFinalType = nCollection:mergeToAtomUnion()
						if nRepeatType then
							return nManager:TypeTuple(vContext:getNode()):Dots(nRepeatType):makeTermTuple(vContext)
						else
							const nReList:List(clazz.UAtomUnion) = {}
							for i=2, #vTermTuple do
								nReList[#nReList + 1] = nFinalType
							end
							return nManager:TypeTuple(vContext:getNode(), table.unpack(nReList)):makeTermTuple(vContext)
						end
					else
						vContext:error("select's first value must be number or number-literal")
						return vContext:FixedTermTuple({})
					end
				end
			end
		end),
		print=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			return vContext:FixedTermTuple({})
		end),
		tprint=nManager:stackNativeOpenFunction(function(vStack, vTermTuple)
			const nTailContext = vStack:inplaceOper()
			nTailContext:info(vTermTuple)
			return nTailContext:FixedTermTuple({})
		end),
		ttprint=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			vContext:info(vTermTuple:checkTypeTuple())
			return vContext:FixedTermTuple({})
		end),
		tonumber=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			--self:argnum_warn(1, vTermTuple)
			--local nData = vTermTuple:get(1)
			print("tonumber TODO")
			return vContext:RefineTerm(nManager:checkedUnion(nManager.type.False, nManager.type.Number))
		end),
		require=nManager:stackNativeOpenFunction(function(vStack, vTermTuple)
			return vStack:withOnePushContext(vStack:getNode(), function(vContext)
				local nFileName = vTermTuple:get(vContext, 1):getType()
				if StringLiteral.is(nFileName) then
					local nPath = nFileName:getLiteral()
					const nRetTerm, nOpenFn = vRuntime:require(nPath)
					vContext:addLookupNode(nRetTerm:getNode(), nOpenFn)
					vContext:openPushReturn(nRetTerm)
				else
					vContext:warn("TODO require take non-StringLiteral type ")
					vContext:openPushReturn(vContext:FixedTermTuple({}))
				end
			end):mergeFirst()
		end),
		load=nManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			return vContext:RefineTerm(nManager.type.AnyFunction)
		end),
		-- function take open context, not oper context
		pcall=nManager:stackNativeOpenFunction(function(vStack, vTermTuple)
			const nHeadContext = vStack:inplaceOper()
			const nFunc = vTermTuple:get(nHeadContext, 1):checkRefineTerm(nHeadContext)
			const nArgs = vTermTuple:select(nHeadContext, 2)
			const nCallContext = vStack:getApplyStack():prepareMetaCall(vStack:getNode(), nFunc, function() return nArgs end)
			const nTermTuple = nCallContext:mergeReturn()
			const nRetFirst = nHeadContext:RefineTerm(nManager.type.True)
			-- TODO combine first & second
			const nRetTermTuple = nHeadContext:UTermTupleByAppend({nRetFirst}, nTermTuple)
			assert(TermTuple.isFixed(nRetTermTuple))
			return nRetTermTuple
		end),
		xpcall=nManager:stackNativeOpenFunction(function(vStack, vTermTuple)
			const nHeadContext = vStack:inplaceOper()
			const nFunc = vTermTuple:get(nHeadContext, 1):checkRefineTerm(nHeadContext)
			const nArgs = vTermTuple:select(nHeadContext, 3)
			const nCallContext = vStack:getApplyStack():prepareMetaCall(vStack:getNode(), nFunc, function() return nArgs end)
			const nTermTuple = nCallContext:mergeReturn()
			const nRetFirst = nHeadContext:RefineTerm(nManager.type.True)
			-- TODO combine first & second
			const nRetTermTuple = nHeadContext:UTermTupleByAppend({nRetFirst}, nTermTuple)
			assert(TermTuple.isFixed(nRetTermTuple))
			return nRetTermTuple
		end),
		error=nManager:stackNativeOpenFunction(function(vStack, vTermTuple)
			const nOperCtx = vStack:inplaceOper()
			vStack:getApplyStack():nativeError(nOperCtx, vTermTuple:checkFixed(nOperCtx, 1))
			return nOperCtx:FixedTermTuple({})
		end),
		assert=nManager:stackNativeOpenFunction(function(vStack, vTermTuple)
			const nHeadContext = vStack:inplaceOper()
			const nFirst = vTermTuple:checkFixed(nHeadContext, 1)
			const nSecond = vTermTuple:rawget(2)
			vStack:getApplyStack():nativeAssert(nHeadContext, nFirst, nSecond and nSecond:checkRefineTerm(nHeadContext))
			const nLogicContext = vStack:newLogicContext(vStack:getNode())
			return vStack:inplaceOper():FixedTermTuple({nLogicContext:logicTrueTerm(nFirst)})
		end),
	}
	for k,v in pairs(global @? Dict(String, clazz.OpenFunction)) do
		-- v:set_name(k)
	end

	global.string=nManager.builtin.string

	global.os=native.make_os(nManager)
	global.math=native.make_math(nManager)
	global.debug=native.make_debug(nManager)
	global.table=native.make_table(nManager)
	global.io=native.make_io(nManager)
	global.coroutine=native.make_coroutine(nManager)
	global.package=native.make_package(nManager)

	-- global.next = vRuntime.func.next
	const nGlobalTable = native._toTable(vRuntime:getTypeManager(), global)
    nGlobalTable:setName("_G")

	return nGlobalTable
end

function native.make_package(vManager:clazz.TypeManager):Ret(clazz.AutoTable)
	const type = vManager.type
	const package:StringToAtomUnion = {
		searchpath=vManager:checkedFn(type.String, type.String):Ret(type.Nil, type.String):Ret(type.String),
		config=type.String,
	}
	const nTable = native._toTable(vManager, package)
	nTable:setName("package")
	return nTable
end

function native.make_math(vManager:clazz.TypeManager):Ret(clazz.AutoTable)
	const type = vManager.type
	const math:StringToAtomUnion = {
		random=vManager:checkedFn():Dots(type.Number):Ret(type.Number),
		max=vManager:checkedFn(type.Number):Dots(type.Number):Ret(type.Number),
		min=vManager:checkedFn(type.Number):Dots(type.Number):Ret(type.Number),
		tointeger=vManager:checkedFn(type.Any):Ret(vManager:checkedUnion(type.Number, type.Nil)),
	}
	const nTable = native._toTable(vManager, math)
	nTable:setName("math")
	return nTable
end

function native.make_debug(vManager:clazz.TypeManager):Ret(clazz.AutoTable)
	-- debug.traceback's arguments TODO
	const type = vManager.type
	const nInfo = vManager:buildStruct(vManager:getRuntime():getNode(), {
		namewhat=type.String,
		isvararg=type.Boolean,
		ntransfer=type.Integer,
		nups=type.Integer,
		currentline=type.Integer,
		func=type.Truth,
		nparams=type.Integer,
		short_src=type.String,
		ftransfer=type.Integer,
		istailcall=type.Boolean,
		lastlinedefined=type.Integer,
		linedefined=type.Integer,
		source=type.String,
		what=type.String,
	})
	const debug:StringToAtomUnion = {
		traceback=vManager:checkedFn():Ret(type.String),
		getinfo=vManager:checkedFn(vManager:checkedUnion(vManager.type.Integer, type.AnyFunction)):Ret(nInfo),
	}
	const nTable = native._toTable(vManager, debug)
	nTable:setName("debug")
	return nTable
end

function native.make_io(vManager:clazz.TypeManager):Ret(clazz.AutoTable)
	const type = vManager.type
	const io:StringToAtomUnion = {
		read=vManager:checkedFn(vManager:checkedUnion(type.String, type.Number)):Ret(vManager:checkedUnion(type.String, type.Nil)),
		write=vManager:checkedFn(type.String),
		flush=vManager:checkedFn(),
	}
	const nTable = native._toTable(vManager, io)
	nTable:setName("io")
	return nTable
end

function native.make_coroutine(vManager:clazz.TypeManager):Ret(clazz.AutoTable)
	const type = vManager.type
	const nStatusUnion = vManager:checkedUnion(
		vManager:Literal("running"),
		vManager:Literal("suspended"),
		vManager:Literal("normal"),
		vManager:Literal("dead")
	)
	const co:StringToAtomUnion = {
		create=vManager:checkedFn(type.AnyFunction):Ret(type.Thread),
		running=vManager:checkedFn():Ret(type.Thread, type.Boolean),
		resume=vManager:checkedFn(type.Thread):Dots(type.Any):Ret(type.True):Ret(type.False,type.String),
		yield=vManager:checkedFn():Ret(type.Truth),
		status=vManager:checkedFn(type.Thread):Ret(nStatusUnion),
	}
	local nTable = native._toTable(vManager, co)
	nTable:setName("coroutine")
	return nTable
end

function native.make_os(vManager:clazz.TypeManager):Ret(clazz.AutoTable)
	const type = vManager.type
	const string:StringToAtomUnion = {
		clock=vManager:checkedFn():Ret(type.Number),
		exit=vManager:checkedFn(),
	}
	const nTable = native._toTable(vManager, string)
	nTable:setName("os")
	return nTable
end

function native.make_string(vManager:clazz.TypeManager):Ret(clazz.AutoTable)
	const type = vManager.type
	const string:StringToAtomUnion = {
		rep=vManager:checkedFn(type.String, type.Integer, vManager:checkedUnion(type.String, type.Integer, type.Nil)):Ret(type.String),
		upper=vManager:checkedFn(type.String):Ret(type.String),
		format=vManager:checkedFn(type.String):Dots(type.Any):Ret(type.String),
		gmatch=vManager:checkedFn(type.String, type.String):Ret(
			vManager:checkedFn():Ret(vManager:checkedUnion(type.String, type.Nil))
		),
		sub=vManager:checkedFn(type.String, type.Integer, vManager:checkedUnion(type.Integer, type.Nil)):Ret(type.String, type.Integer),
		gsub=vManager:checkedFn(type.String, type.String, type.String):Ret(type.String, type.Integer),
		match=vManager:checkedFn(type.String, type.String):Ret():Ret(type.String),
		find=vManager:checkedFn(type.String, type.String, vManager:checkedUnion(type.Nil, type.Integer), vManager:checkedUnion(type.True, type.Nil)):Ret(type.Nil):Ret(type.Integer, type.Integer),
	}
	const nTable = native._toTable(vManager, string)
	nTable:setName("string")
	return nTable
end

function native.make_table(vManager:clazz.TypeManager):Ret(clazz.AutoTable)
	const function checkList(vContext:clazz.OperContext, vType:clazz.UAtomUnion, vKey:String):Ret(clazz.UAtomUnion)
		--[[
		const nNumber = vManager.type.Number
		const nElementCollection = vManager:TypeCollection()
		vType:foreach(function(vSubType)
			const nLenType = vSubType:meta_len(vContext)
			if not Number.is(nLenType) then
				vContext:error("table."..vKey.." must take list-like variable")
				return
			end
			const nValue = vSubType:meta_get(vContext, nNumber)
			nElementCollection:put(nValue)
		end)
		return nElementCollection:mergeToAtomUnion()]]
		-- checkList TODO
		return vContext:getTypeManager().type.Never
	end
	const table:StringToAtomUnion = {
		sort=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			checkList(vContext, nType, "sort")
			return vManager:TypeTuple(vContext:getNode()):makeTermTuple(vContext)
		end),
		concat=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			checkList(vContext, nType, "concat")
			return vContext:FixedTermTuple({vContext:RefineTerm(vManager.type.String)})
		end),
		insert=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			checkList(vContext, nType, "insert")
			return vContext:FixedTermTuple({})
		end),
		remove=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			-- const nRetType = checkList(vContext, nType, "remove")
			-- return vContext:FixedTermTuple({vContext:RefineTerm(nRetType)})
			return vContext:FixedTermTuple({})
		end),
		unpack=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			--[[local nFirstTerm = vTermTuple:get(vContext, 1)
			local nType = nFirstTerm:getType()
			local nNumber = vManager.type.Number
			local nCollection = vManager:TypeCollection()
			nType:foreach(function(vSubType)
				local nLenType = vSubType:meta_len(vContext)
				if not (Number.is(nLenType) or NumberLiteral.is(nLenType)) then
					vContext:error("__len must return number when concat")
					return
				end
				local nValueType = vSubType:meta_get(vContext, nNumber)
				nCollection:put(nValueType)
			end)
			local nRetType = nCollection:mergeToAtomUnion()
			return vManager:TypeTuple(vContext:getNode()):Dots(nRetType:notnilType()):makeTermTuple(vContext)]]
			return vContext:FixedTermTuple({})
		end),
		move=vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
			-- move TODO
			-- vContext:error("table move")
			return vTermTuple:get(vContext, 5)
		end)
	}
	local nTable = native._toTable(vManager, table)
	nTable:setName("table")
	return nTable
end

function native.make_inext(vManager:clazz.TypeManager):Ret(clazz.IAtomType)
	local nNumber = vManager.type.Number
	local nNil = vManager.type.Nil
	return vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
		const nFirstTerm = vTermTuple:get(vContext, 1)
		--local nNotNilValue = nType1:meta_get(vContext, nNumber):notnilType()
		local nNotNilValue = vContext:getInstStack():META_GET(vContext:getNode(), nFirstTerm, vContext:RefineTerm(nNumber), true):getType()
		local nValueTerm = vContext:RefineTerm(vManager:checkedUnion(nNotNilValue, nNil))
		local nKeyValue:Dict(clazz.IAtomType, clazz.UAtomUnion) = {
			[nNumber]=nNotNilValue,
			[nNil]=nNil,
		}
		local nTypeCaseList:List(clazz.TypeCasePair) = {}
		for nOneKey, nOneValue in pairs(nKeyValue) do
			local nCase = VariableCase.new()
			nCase:put_and(nValueTerm:attachImmutVariable(), nOneValue)
			nTypeCaseList[#nTypeCaseList + 1] = {
				nOneKey, nCase
			}
		end
		local nKeyTerm = vContext:mergeToRefineTerm(nTypeCaseList)
		return vContext:FixedTermTuple({nKeyTerm, nValueTerm})
	end)
end

function native.make_next(vManager:clazz.TypeManager):Ret(clazz.IAtomType)
	return vManager:fixedNativeOpenFunction(function(vContext, vTermTuple)
		local nType1 = vTermTuple:get(vContext, 1):getType()
		nType1 = nType1:trueType()
		local nType2 = vTermTuple:get(vContext, 2):getType()
		if nType1:isUnion() then
			if nType1:isNever() then
				vContext:error("next must take table as first type")
			else
				vContext:error("TODO: next Union type")
			end
			return vContext:FixedTermTuple({vContext:NilTerm(), vContext:NilTerm()})
		else
			local nValueType, nKeyValue = nType1:native_next(vContext, nType2)
			local nValueTerm = vContext:RefineTerm(nValueType)
			local nTypeCaseList:List(clazz.TypeCasePair) = {}
			for nOneKey, nOneValue in pairs(nKeyValue) do
				local nCase = VariableCase.new()
				nCase:put_and(nValueTerm:attachImmutVariable(), nOneValue)
				nTypeCaseList[#nTypeCaseList + 1] = {
					nOneKey, nCase
				}
			end
			local nKeyTerm = vContext:mergeToRefineTerm(nTypeCaseList)
			return vContext:FixedTermTuple({nKeyTerm, nValueTerm})
		end
	end)
end

function native.make_mathematic(vManager:clazz.TypeManager):Ret(clazz.IAtomType)
	local nNumber = vManager.type.Number
	return vManager:checkedFn(nNumber, nNumber):Ret(nNumber)
end

function native.make_comparison(vManager:clazz.TypeManager):Ret(clazz.IAtomType)
	local nNumber = vManager.type.Number
	return vManager:checkedFn(nNumber, nNumber):Ret(vManager.type.Boolean)
end

function native.make_bitwise(vManager:clazz.TypeManager):Ret(clazz.TypedFunction)
	local nNumber = vManager.type.Number
	return vManager:checkedFn(nNumber, nNumber):Ret(nNumber)
end

function native.make_concat(vManager:clazz.TypeManager):Ret(clazz.TypedFunction)
	local nType = vManager:checkedUnion(vManager.type.String, vManager.type.Number)
	return vManager:checkedFn(nType, nType):Ret(vManager.type.String)
end

return native

