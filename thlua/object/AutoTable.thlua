
const StringLiteral = require "thlua.type.StringLiteral"
const TypedObject = require "thlua.object.TypedObject"
const Struct = require "thlua.object.Struct"
const TypedFunction = require "thlua.func.TypedFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const AutoFunction = require "thlua.func.AutoFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"

const SealTable = require "thlua.object.SealTable"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const AutoTable = class@<clazz.AutoTable, false>(SealTable)

function.open AutoTable:ctor(...)
	self._typedObject=false@OrFalse(clazz.TypedObject)
	self._name = false @OrFalse(String)
	self._firstAssign = false@OrFalse(clazz.AssignContext)
	self._castDict = {} @ Dict(clazz.TypedObject, True)
end

function AutoTable:detailString(v, vVerbose)
	if not self._firstAssign then
		return "AutoTable@castable@"..tostring(self._node)
	elseif next(self._castDict) then
		return "AutoTable@casted@"..tostring(self._node)
	else
		return "AutoTable@"..tostring(self._node)
	end
end

function AutoTable:setName(vName:String)
	self._name = vName
end

function AutoTable:cast(vContext:clazz.AssignContext, vObjectAtomUnion:clazz.UAtomUnion):Ret(OrFalse(clazz.TypedObject))
	const nOldStruct = self._typedObject
	if nOldStruct then
		local nMatchStruct:OrNil(clazz.TypedObject) = nil
		vObjectAtomUnion:foreach(function(vAtomType)
			if not nMatchStruct and TypedObject.is(vAtomType)
				and vAtomType:includeAll(nOldStruct) and nOldStruct:includeAll(vAtomType) then
				nMatchStruct = vAtomType
			end
		end)
		if not nMatchStruct then
			vContext:error("table can't cast to multi struct type")
			return false
		end
		return nMatchStruct
	end
	const nMatchStruct = self:castStruct(vContext, vObjectAtomUnion)
	if not nMatchStruct then
		return false
	end
	self._typedObject = nMatchStruct
	return nMatchStruct
end

function AutoTable:castStruct(vContext:clazz.AssignContext, vObjectAtomUnion:clazz.UAtomUnion):Ret(OrFalse(clazz.TypedObject))
	if self._firstAssign then
		vContext:error("can't cast assigned AutoTable")
		return false
	end
	local nFinalMatchStruct:OrFalse(clazz.TypedObject) = false
	local nFinalMatchCastList:List(Struct {clazz.AutoTable, clazz.UAllType}) = {}
	vObjectAtomUnion:foreach(function(vAtomType)
		if not Struct.is(vAtomType) then
			return
		end
		const nCopyValueDict = vAtomType:copyValueDict()
		local nMatchSucc = true
		const nCastList:List(Struct {clazz.AutoTable, clazz.UAllType}) = {}
		self._keyType:foreach(function(vTableKey)
			const vTableValue = self._fieldDict[vTableKey]!.rawValueType
			if not nMatchSucc then
				return
			end
			local nMatchKey, nMatchValue = vAtomType:indexKeyValue(vTableKey)
			if not nMatchKey then
				nMatchSucc = false
				return
			end
			if not AutoTable.is(vTableValue) then
				const nOneMatchSucc = vContext:castLuaType(vTableValue, nMatchValue) or nMatchValue:includeAll(vTableValue)
				if not nOneMatchSucc then
					nMatchSucc = false
					return
				end
			else
				nCastList[#nCastList + 1] = {vTableValue, nMatchValue}
			end
			nCopyValueDict[nMatchKey] = nil
		end)
		if not nMatchSucc then
			return
		end
		for k,v in pairs(nCopyValueDict) do
			if not v:checkAtomUnion():isNilable() then
				nMatchSucc = false
				break
			end
		end
		if nMatchSucc and not nFinalMatchStruct then
			nFinalMatchStruct = vAtomType
			nFinalMatchCastList = nCastList
		else
			vContext:error("table cast error, table may match more than one struct")
		end
	end)
	for _, nPair in ipairs(nFinalMatchCastList) do
		vContext:castLuaType(nPair[1], nPair[2])
	end
	return nFinalMatchStruct
end

function AutoTable:checkTypedObject()
	return self._manager.type.AnyObject
end

function AutoTable:isCastable()
	return not self._firstAssign
end

function AutoTable:setAssigned(vContext)
	if not self._firstAssign then
		if next(self._castDict) then
			vContext:error("AutoTable is casted to some TypedObject")
		end
		self._firstAssign = vContext
		for k, v in pairs(self._fieldDict) do
			v.rawValueType:setAssigned(vContext)
		end
	end
end

return AutoTable
