
const StringLiteral = require "thlua.type.StringLiteral"
const TypedObject = require "thlua.object.TypedObject"
const Struct = require "thlua.object.Struct"
const TypedFunction = require "thlua.func.TypedFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const AutoFunction = require "thlua.func.AutoFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"

const SealTable = require "thlua.object.SealTable"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const AutoTable = class@<clazz.AutoTable, false>(SealTable)

function.open AutoTable:ctor(...)
	self._typedObject=false@OrFalse(clazz.TypedObject)
	self._name = false @OrFalse(String)
	self._firstAssign = false@OrFalse(clazz.AssignContext)
	self._castDict = {} @ Dict(clazz.TypedObject, Boolean)
end

function AutoTable:detailString(v, vVerbose)
	if not self._firstAssign then
		return "AutoTable@castable@"..tostring(self._node)
	elseif next(self._castDict) then
		return "AutoTable@casted@"..tostring(self._node)
	else
		return "AutoTable@"..tostring(self._node)
	end
end

function AutoTable:setName(vName:String)
	self._name = vName
end

function AutoTable:_castMatchOne(
	vContext:clazz.AssignContext,
	vStruct:clazz.Struct
):Ret(OrFalse(Dict(clazz.AutoFunction, List(clazz.UAtomUnion))))
	const nFnCastDict:Dict(clazz.AutoFunction, List(clazz.UAtomUnion)) = {}
	const nCopyValueDict = vStruct:copyValueDict()
	local nMatchSucc = true
	self._keyType:foreach(function(vTableKey)
		const vTableValue = self._fieldDict[vTableKey]!.rawValueType
		if not nMatchSucc then
			return
		end
		local nMatchKey, nMatchValue = vStruct:indexKeyValue(vTableKey)
		if not nMatchKey then
			nMatchSucc = false
			return
		end
		if not vContext:tryIncludeCast(nFnCastDict, nMatchValue:checkAtomUnion(), vTableValue) then
			nMatchSucc = false
			return
		end
		nCopyValueDict[nMatchKey] = nil
	end)
	if not nMatchSucc then
		return false
	end
	for k,v in pairs(nCopyValueDict) do
		if not v:checkAtomUnion():isNilable() then
			return false
		end
	end
	return nFnCastDict
end

function AutoTable:tryCast(
	vContext:clazz.AssignContext,
	vFnCastDict:Dict(clazz.AutoFunction, List(clazz.UAtomUnion)),
	vObjectAtomUnion:clazz.UAtomUnion
):Ret(OrFalse(clazz.TypedObject))
	if self._firstAssign then
		vContext:error("can't cast assigned AutoTable")
		return false
	end
	local nFinalMatchStruct:OrFalse(clazz.TypedObject) = false
	vObjectAtomUnion:foreach(function(vAtomType)
		if not Struct.is(vAtomType) then
			return
		end
		const nCurFnCastDict = self:_castMatchOne(vContext, vAtomType)
		if nCurFnCastDict then
			for nAutoFn, nList in pairs(nCurFnCastDict) do
				const nOldList = vFnCastDict[nAutoFn]
				if nOldList then
					for i=1,#nList do
						nOldList[#nOldList + 1] = nList[i]
					end
				else
					vFnCastDict[nAutoFn] = nList
				end
			end
		end
	end)
	return nFinalMatchStruct
end

function AutoTable:checkTypedObject()
	return self._manager.type.AnyObject
end

function AutoTable:isCastable()
	return not self._firstAssign
end

function AutoTable:setAssigned(vContext)
	if not self._firstAssign then
		if next(self._castDict) then
			vContext:error("AutoTable is casted to some TypedObject")
		end
		self._firstAssign = vContext
		for k, v in pairs(self._fieldDict) do
			v.rawValueType:setAssigned(vContext)
		end
	end
end

return AutoTable
