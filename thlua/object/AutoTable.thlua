
const StringLiteral = require "thlua.type.StringLiteral"
const TypedObject = require "thlua.object.TypedObject"
const Struct = require "thlua.object.Struct"
const TypedFunction = require "thlua.func.TypedFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const AutoFunction = require "thlua.func.AutoFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"

const SealTable = require "thlua.object.SealTable"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const AutoTable = class@<clazz.AutoTable, false>(SealTable)

function AutoTable:detailString(v, vVerbose)
	return "AutoTable@"..tostring(self._node)
end

function.open AutoTable:ctor(...)
	self._name = false @OrFalse(String)
end

function AutoTable:lockAndGet():Ret(clazz.UAtomUnion, Dict(clazz.IAtomType, clazz.UAtomUnion))
	const nDict:Dict(clazz.IAtomType, clazz.UAtomUnion) = {}
	for k, nField in pairs(self._fieldDict) do
		nDict[k] = nField.castValueType or nField.rawValueType
	end
	return self._keyType, nDict
end

function AutoTable:setName(vName:String)
	self._name = vName
end

function AutoTable:lockAsMetaIndex()
	return self:lockAndGet()
end

function AutoTable:lockAsMetaNewIndex()
	return self:lockAndGet()
end

function AutoTable:cast(vContext:clazz.AssignContext, vObjectAtomUnion:clazz.UObjectAtomUnion):Ret(OrFalse(clazz.TypedObject))
	const nOldStruct = self._interface
	if nOldStruct then
		local nMatchStruct:OrNil(clazz.TypedObject) = nil
		vObjectAtomUnion:foreach(function(vAtomType)
			if not nMatchStruct and TypedObject.is(vAtomType)
				and vAtomType:includeAll(nOldStruct) and nOldStruct:includeAll(vAtomType) then
				nMatchStruct = vAtomType
			end
		end)
		if not nMatchStruct then
			vContext:error("table can't cast to multi struct type")
			return false
		end
		return nMatchStruct
	end
	const nMatchStruct = self:castStruct(vContext, vObjectAtomUnion)
	if not nMatchStruct then
		return false
	end
	self._interface = nMatchStruct
	return nMatchStruct
end

function AutoTable:castStruct(vContext:clazz.AssignContext, vObjectAtomUnion:clazz.UObjectAtomUnion):Ret(OrFalse(clazz.TypedObject))
	if self._isBasingDefault then
		return false
	end
	local nFinalMatchStruct:OrFalse(clazz.TypedObject) = false
	local nFinalMatchCastList:List(Struct {clazz.AutoTable, clazz.UAllType}) = {}
	vObjectAtomUnion:foreach(function(vAtomType)
		if not Struct.is(vAtomType) then
			return
		end
		const nCopyValueDict = vAtomType:copyValueDict()
		local nMatchSucc = true
		const nCastList:List(Struct {clazz.AutoTable, clazz.UAllType}) = {}
		self._keyType:foreach(function(vTableKey)
			const vTableValue = self._fieldDict[vTableKey]!.rawValueType
			if not nMatchSucc then
				return
			end
			local nMatchKey, nMatchValue = vAtomType:indexKeyValue(vTableKey)
			if not nMatchKey then
				nMatchSucc = false
				return
			end
			if not AutoTable.is(vTableValue) then
				const nOneMatchSucc = vContext:castLuaType(vTableValue, nMatchValue) or nMatchValue:includeAll(vTableValue)
				if not nOneMatchSucc then
					nMatchSucc = false
					return
				end
			else
				nCastList[#nCastList + 1] = {vTableValue, nMatchValue}
			end
			nCopyValueDict[nMatchKey] = nil
		end)
		if not nMatchSucc then
			return
		end
		for k,v in pairs(nCopyValueDict) do
			if not v:checkAtomUnion():isNilable() then
				nMatchSucc = false
				break
			end
		end
		if nMatchSucc and not nFinalMatchStruct then
			nFinalMatchStruct = vAtomType
			nFinalMatchCastList = nCastList
		else
			vContext:error("table cast error, table may match more than one struct")
		end
	end)
	for _, nPair in ipairs(nFinalMatchCastList) do
		vContext:castLuaType(nPair[1], nPair[2])
	end
	return nFinalMatchStruct
end

return AutoTable
