
const Exception = require "thlua.Exception"
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const StringLiteral = require "thlua.type.StringLiteral"
const Nil = require "thlua.type.Nil"
const TypedFunction = require "thlua.func.TypedFunction"

const BaseAtomType = require "thlua.type.BaseAtomType"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const BaseObject = class@<clazz.BaseObject, false>(BaseAtomType)

function.open BaseObject:ctor(vManager:clazz.TypeManager, vNode:clazz.IAstNode, ...)
	self.bits=TYPE_BITS.OBJECT
	self._metaEventCom=false@OrFalse(clazz.MetaEventCom)
	self._node=vNode
end

function BaseObject:getMetaEventCom():Ret(OrFalse(clazz.MetaEventCom))
	return self._metaEventCom
end

function BaseObject:detailString(v, vVerbose)
	return "BaseObject..."
end

function BaseObject:meta_uop_some(vContext, vOper)
	vContext:error("meta uop not implement:")
	return self._manager.type.Never
end

function BaseObject:meta_bop_func(vContext, vOper)
	vContext:error("meta bop not implement:")
	return false, nil
end

function BaseObject:isSingleton()
	return false
end

function BaseObject:objectPartType()
	return self
end

function BaseObject:native_type()
	return self._manager:Literal("table")
end

return BaseObject
