
const Exception = require "thlua.Exception"
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const StringLiteral = require "thlua.type.StringLiteral"
const Nil = require "thlua.type.Nil"
const TypeFunction = require "thlua.func.TypeFunction"
const MetaEventCom = require "thlua.object.MetaEventCom"
const MetaObject = require "thlua.object.MetaObject"

const BaseAtomType = require "thlua.type.BaseAtomType"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const BaseTable = class@<clazz.BaseTable, false>(BaseAtomType)

function.open BaseTable:ctor(vManager:clazz.TypeManager, ...)
	self._name="Table"@String
	self.bits=TYPE_BITS.OBJECT
	self._metaEventCom=false@OrFalse(clazz.MetaEventCom)
end

function BaseTable:initByKeyValue(vKeyType:clazz.UAtomUnion, vValueDict:Dict(clazz.IAtomType, clazz.UAtomUnion))
	error("base table init by key value not implement")
end

function BaseTable:getMetaEventCom():Ret(OrFalse(clazz.MetaEventCom))
	return self._metaEventCom
end

function BaseTable:detailString(v, vVerbose)
	return "BaseTable-"..self._name
end

function BaseTable:setName(vName:String)
	self._name = vName
end

function BaseTable:native_type()
	return self._manager:Literal("table")
end

function BaseTable:meta_len(vContext)
	-- TODO
	return self._manager.type.Number
end

function BaseTable:meta_uop_some(vContext, vOper)
	vContext:error("meta uop not implement:")
	return self._manager.type.Never
end

function BaseTable:meta_bop_func(vContext, vOper)
	vContext:error("meta bop not implement:")
	return false, nil
end

function BaseTable:isSingleton()
	return false
end

function BaseTable:assumeIncludeAtom(vAssumeSet, vType)
	if BaseTable.is(vType) then
		return vType == self and self or false
	else
		-- TODO check struct
		return false
	end
end

function BaseTable:objectPartType()
	return self
end

function BaseTable:mayRecursive()
	return true
end

return BaseTable
