
local TypeFunction = require "thlua.func.TypeFunction"
local LuaFunction = require "thlua.func.LuaFunction"
local Nil = require "thlua.type.Nil"

(@var.class = import("thlua.type.TypeClass").class)

local ClassCom = {}

ClassCom.__index=ClassCom

function ClassCom.new(vManager:class.TypeManager, vLuaTable:class.LuaTable)::RetNew(class.ClassCom)
    local self = setmetatable({::New()
        _manager=vManager,
        _luaTable=vLuaTable,
        _valueDict={},
        _keyType=false,
    }, ClassCom)
    return self
end

function ClassCom:meta_get(vContext, vKeyType)::Ret(class.IKeyType)
    if self._keyType:contain(vKeyType) then
        return self._valueDict[vKeyType]
    else
        vContext:error("key not found", tostring(vKeyType))
        return self._manager.type.Nil
    end
end

function ClassCom:implement(vContext, vImplType:Union(class.Struct,False))
    local nMeta = self._luaTable:native_getmetatable(vContext)
    if Nil.is(nMeta) then
        vContext:warn("class table need metatable")
        return
    end
    local nCollection = self._manager:TypeCollection()
    self._luaTable:foreachGetPair(function(vKey, vValue)
        nCollection:put(vKey)
        self._valueDict[vKey] = vValue
    end)
    local nIndexTable = nMeta:native_rawget(vContext, self._manager:Literal("__index"))
    if nIndexTable:native_type() ~= self._manager:Literal("table") then
        vContext:warn("class table 's __index is not table or struct")
    else
        nIndexTable:foreachGetPair(function(vKey, vValue)
            if LuaFunction.is(vValue) and vValue:isMember() then
                nCollection:put(vKey)
                self._valueDict[vKey] = vValue:asMemberFunction(vContext, self._luaTable)
            elseif TypeFunction.is(vValue) then
                print("TypeFunction as indexing member TODO")
            end
        end)
    end
    self._keyType = nCollection:mergeToType()
end

return ClassCom