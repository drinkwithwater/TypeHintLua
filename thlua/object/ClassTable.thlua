
const VariableCase = require "thlua.term.VariableCase"
const StringLiteral = require "thlua.type.StringLiteral"
const TypedFunction = require "thlua.func.TypedFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const AutoFunction = require "thlua.func.AutoFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"

const SealTable = require "thlua.object.SealTable"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ClassTable = class@<clazz.ClassTable, false>(SealTable)

function.open ClassTable:ctor(
	vManager:clazz.TypeManager,
	vNode:clazz.IAstNode,
	vFnCom:clazz.ClassFactory
)
	self._factory = vFnCom
	const nTask = self._manager:getScheduleManager():newTask()
	self._task = nTask
	self._initEvent = nTask:makeEvent()
	self._baseClass = false@OrFalse(clazz.ClassTable)
	self._interface = nil@clazz.Interface
end

function ClassTable:detailString(v, vVerbose)
	return "ClassTable@"..tostring(self._node)
end

function ClassTable:waitInit()
	self._initEvent:wait()
end

function ClassTable:initAsync(vBaseGetter:Fn():Ret(OrFalse(clazz.ClassTable), clazz.Interface))
	self._task:runAsync(function()
		self._baseClass, self._interface = vBaseGetter()
		self._initEvent:wakeup()
	end)
end

function ClassTable:onSetMetaTable(vContext:clazz.OperContext)
	self._factory:wakeupTableBuild()
	const nInterface = self._interface
	if nInterface then
		self:implInterface(vContext, nInterface)
	end
end

function ClassTable:getWhenImplement(vOperCtx:clazz.OperContext, vKeyType:clazz.IAtomType):Ret(clazz.UAtomUnion)
	return vOperCtx:getStack():withOnePushContext(vOperCtx:getNode(), function(vContext)
		vContext:withCase(VariableCase.new(), function()
			self:meta_get(vContext, vKeyType)
		end)
	end):getType()
end

function ClassTable:implInterface(vContext:clazz.OperContext, vInterface:clazz.Interface)
	const nInterfaceKeyValue = vInterface:copyValueDict(self)
	const nSelfKey = self._keyType
	const nSelfFieldDict = self._fieldDict
	for nKeyAtom, nValue in pairs(nInterfaceKeyValue) do
		const nSelfValue = self:getWhenImplement(vContext, nKeyAtom)
		if MemberFunction.is(nSelfValue) then
			if TypedFunction.is(nValue) then
				nSelfValue:indexAutoFn(self):checkWhenCast(vContext, nValue)
			end
		else
			if not nValue:includeAll(nSelfValue) then
				vContext:error("interface's field must be supertype for table's field, key="..tostring(nKeyAtom))
			end
		end
	end
	for _, nField in pairs(nSelfFieldDict) do
		if not nField.castValueType then
			const nSelfValue = nField.rawValueType
			if MemberFunction.is(nSelfValue) then
				if not nSelfValue:needPolyArgs() then
					nSelfValue:indexAutoFn(self)
				end
			elseif AutoFunction.is(nSelfValue) then
			end
		end
	end
end

function ClassTable:ctxWait(vContext:clazz.OperContext)
	self._factory:waitTableBuild()
end

function ClassTable:getBaseClass()
	return self._baseClass
end

function ClassTable:getInterface()
	return self._interface
end

function ClassTable:checkTypedObject()
	return self._interface
end

function ClassTable:assumeIncludeAtom(vAssumeSet, vType)
	if ClassTable.is(vType) then
		local nMatchTable = vType
		while nMatchTable ~= self do
			const nBaseClass = nMatchTable:getBaseClass()
			if not nBaseClass then
				break
			else
				nMatchTable = nBaseClass
			end
		end
		return nMatchTable == self and self or false
	else
		-- TODO check struct
		return false
	end
end

return ClassTable
