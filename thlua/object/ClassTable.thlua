
const StringLiteral = require "thlua.type.StringLiteral"
const MetaObject = require "thlua.object.MetaObject"
const TypeFunction = require "thlua.func.TypeFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const AutoFunction = require "thlua.func.AutoFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"

const BaseTable = require "thlua.object.BaseTable"
const SealTable = require "thlua.object.SealTable"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ClassTable = class@<clazz.ClassTable, false>(SealTable)

function.open ClassTable:ctor(
	vManager:clazz.TypeManager,
	vFnCom:clazz.ClassFactory
)
	self._factory = vFnCom
	const nTask = self._manager:getScheduleManager():newTask()
	self._task = nTask
	self._initEvent = nTask:makeEvent()
	self._baseClass = false@OrFalse(clazz.ClassTable)
	self._interface = nil@clazz.MetaObject
end

function ClassTable:waitInit()
	self._initEvent:wait()
end

function ClassTable:initAsync(vBaseGetter:Fn():Ret(OrFalse(clazz.ClassTable), clazz.MetaObject))
	self._task:runAsync(function()
		self._baseClass, self._interface = vBaseGetter()
		self._initEvent:wakeup()
	end)
end

function ClassTable:onSetMetaTable(vContext:clazz.OperContext)
	self._factory:wakeupTableBuild()
	const nInterface = self._interface
	if nInterface then
		self:implInterface(vContext, nInterface)
	end
end

function ClassTable:implInterface(vContext:clazz.OperContext, vInterface:clazz.MetaObject)
	const nInterfaceKeyValue = vInterface:copyValueDict(self)
	const nSelfKey = self._keyType
	const nSelfFieldDict = self._fieldDict
	for nKeyAtom, nValue in pairs(nInterfaceKeyValue) do
		const nSelfKeyAtom = nSelfKey:includeAtom(nKeyAtom)
		if nSelfKeyAtom then
			const nField = nSelfFieldDict[nSelfKeyAtom]!
			const nSelfValue = nField.rawValueType
			if MemberFunction.is(nSelfValue) then
				if TypeFunction.is(nValue) then
					nSelfValue:indexAutoFn(self):checkWhenCast(vContext, nValue)
					nField.castValueType = nValue
				end
			else
				if not nValue:includeAll(nSelfValue) then
					vContext:error("interface's field must be supertype for table's field, key="..tostring(nKeyAtom))
				end
			end
		else
			vContext:error("interface has field not implement, key="..tostring(nKeyAtom))
		end
	end
	for _, nField in pairs(nSelfFieldDict) do
		if not nField.castValueType then
			const nSelfValue = nField.rawValueType
			if MemberFunction.is(nSelfValue) then
				if not nSelfValue:needPolyArgs() then
					nSelfValue:indexAutoFn(self)
				end
			elseif AutoFunction.is(nSelfValue) then
			end
		end
	end
end


function ClassTable:ctxWait(vContext:clazz.OperContext)
	self._factory:waitTableBuild()
end

function ClassTable:getBaseClass()
	return self._baseClass
end

function ClassTable:getInterface()
	return self._interface
end

function ClassTable:assumeIncludeAtom(vAssumeSet, vType)
	if ClassTable.is(vType) then
		local nMatchTable = vType
		while nMatchTable ~= self do
			const nBaseClass = nMatchTable:getBaseClass()
			if not nBaseClass then
				break
			else
				nMatchTable = nBaseClass
			end
		end
		return nMatchTable == self and self or false
	else
		-- TODO check struct
		return false
	end
end

return ClassTable
