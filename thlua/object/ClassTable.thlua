
const StringLiteral = require "thlua.type.StringLiteral"
const MetaObject = require "thlua.object.MetaObject"
const TypeFunction = require "thlua.func.TypeFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const AutoFunction = require "thlua.func.AutoFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"

const BaseTable = require "thlua.object.BaseTable"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ClassTable = class@<clazz.ClassTable, false>(BaseTable)

function.open ClassTable:ctor(vManager:clazz.TypeManager)
end

function ClassTable:_checkComOrStruct(vContext:clazz.OperContext):Ret(clazz.IMetaNative)
	self:_lockOrWaitClass(vContext)
	if self._classCom then
		return self._tableCom
	else
		const nCastStruct = self._objectType
		if nCastStruct then
			vContext:warn("table has been cast to other type")
			return nCastStruct
		else
			return self._tableCom
		end
	end
end

function ClassTable:_lockOrWaitClass(vContext:clazz.OperContext)
	const nClassCom = self._classCom
	if nClassCom then
		nClassCom:waitBuild()
	else
		const nCastStruct = self._objectType
		if nCastStruct then
			vContext:warn("table has been cast to other type")
			return
		end
	end
end

--[[
function ClassTable:ctxWait(vContext:clazz.OperContext)
end

function ClassTable:initByClassCom(vFnCom:clazz.ClassFactory, vBaseClass:OrFalse(clazz.BaseTable), vInterface:clazz.MetaObject)
	self._classCom = vFnCom
	self._baseClass = vBaseClass
	self._objectType = vInterface
end

function ClassTable:assumeIncludeAtom(vAssumeSet, vType)
	if ClassTable.is(vType) then
		local nMatchTable = vType
		while nMatchTable ~= self do
			const nBaseClass = nMatchTable:getBaseClass()
			if not nBaseClass then
				break
			else
				nMatchTable = nBaseClass
			end
		end
		return nMatchTable == self and self or false
	else
		-- TODO check struct
		return false
	end
end
]]

return ClassTable
