
const StringLiteral = require "thlua.type.StringLiteral"
const TypeFunction = require "thlua.func.TypeFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const LuaFunction = require "thlua.func.LuaFunction"
const Nil = require "thlua.type.Nil"
const TableComClass = require "thlua.object.TableComClass"

(@let.class = import("thlua.type.TypeClass").class)

const ClassTableCom = TableComClass()

-- TODO vImplType can be struct, class
function ClassTableCom.new(vManager:class.TypeManager, vRefer:class.Reference, vLuaTable:class.LuaTable, vFnCom:class.ClassFnCom,
	vBaseClass:Union(class.LuaTable, False), vInterface:class.MetaObject)::RetClass(class.ClassTableCom, class.ITableCom)
	const self = setmetatable({::Self()
		_manager=vManager,
		_luaTable=vLuaTable,
		_refer=vRefer,
		_defaultCom=vLuaTable:getDefaultCom(),
		_baseClass=vBaseClass,
		_interface=vInterface,
		_fnCom=vFnCom,
		_waitCoToSid={}@Dict(Thread, Integer),
		_buildReady=false@Boolean,
		_calledSelf=false@Boolean,
	}, ClassTableCom)
	return self
end

function ClassTableCom:longHintSelf()
	self._calledSelf = true
end

function ClassTableCom:waitBuild()
	self._fnCom:startBuild()
	const nCurCo = coroutine.running()
	const nSelfCo = self._refer:getSelfCo()
	if nCurCo ~= nSelfCo then
		if not self._buildReady then
			const nSessionId = self._manager:genSessionId()
			self._waitCoToSid[nCurCo] = nSessionId
			self._manager:coWait(nCurCo, nSessionId, nSelfCo)
		end
	else
		assert(self._calledSelf, "build a ClassTable with {Self()} before use it")
	end
end

function ClassTableCom:native_rawset(vContext, vKeyType, vValueType, vIsOverride)
	self:waitBuild()
	self._defaultCom:native_rawset(vContext, vKeyType, vValueType, vIsOverride)
end

function ClassTableCom:native_rawget(vContext, vKeyType)
	self:waitBuild()
	return self._defaultCom:native_rawget(vContext, vKeyType)
end

function ClassTableCom:meta_set(vContext, vKeyType, vValueType)
	self:waitBuild()
	self._defaultCom:meta_set(vContext, vKeyType, vValueType)
end

function ClassTableCom:meta_get(vContext, vKeyType)::Ret(class.UAtomUnion)
	self:waitBuild()
	return self._defaultCom:meta_get(vContext, vKeyType)
end

function ClassTableCom:meta_bop_func(vContext, vOper)
	self:waitBuild()
	return self._defaultCom:meta_bop_func(vContext, vOper)
end

function ClassTableCom:native_next(vContext, vInitType)
	self:waitBuild()
	return self._defaultCom:native_next(vContext, vInitType)
end

function ClassTableCom:setmetatable_finish()
	-- TODO, can only set once in ClassFn's context
	assert(coroutine.running() == self._refer:getSelfCo(), "can only setmetatable in constructor thread")
	self._buildReady=true
	for co, sid in pairs(self._waitCoToSid) do
		self._manager:coWakeup(co, sid)
	end
end

function ClassTableCom:getBase()::Ret(class.MetaObject)
	return self._interface
end

function ClassTableCom:finishBuild(vContext:class.Context)
	--[[if self._sealed then
		vContext:error("class table try seal more than once")
		return
	end
	self._sealed = true
	const nCollection = self._manager:TypeCollection()
	if self._keyType then
		nCollection:put(self._keyType)
	end
	const nDefaultCom:class.DefaultTableCom = self._defaultCom
	nDefaultCom:foreachGetPair(function(vKey, vValue)
		nCollection:put(vKey)
		self._valueDict[vKey] = vValue
	end)
	self._keyType = nCollection:mergeToAtomUnion()]]
end

function ClassTableCom:getLuaTable()::Ret(class.LuaTable)
	return self._luaTable
end

function ClassTableCom:getRefer()::Ret(class.Reference)
	return self._refer
end

function ClassTableCom:getCompletion()
	local nDict:Dict(String, True) = {}
	self._defaultCom:foreachGetPair(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function ClassTableCom.is(vType)::isguard(class.ClassTableCom)
	return getmetatable(vType) == ClassTableCom
end

return ClassTableCom
