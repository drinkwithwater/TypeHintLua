
const StringLiteral = require "thlua.type.StringLiteral"
const TypeFunction = require "thlua.func.TypeFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const LuaFunction = require "thlua.func.LuaFunction"
const Nil = require "thlua.type.Nil"
const TableComClass = require "thlua.object.TableComClass"

(@do
	let.class = import("thlua.type.TypeClass").class
end)

const ClassTableCom = {}
ClassTableCom.__index = ClassTableCom

-- TODO vImplType can be struct, class
function ClassTableCom.new(vManager:class.TypeManager,
	vRefer:class.Reference,
	vLuaTable:class.LuaTable,
	vFnCom:class.ClassFnCom,
	vBaseClass:OrFalse(class.LuaTable),
	vInterface:class.MetaObject)::RetClass(class.ClassTableCom)
	const self = setmetatable({::Self()
		_manager=vManager,
		_luaTable=vLuaTable,
		_refer=vRefer,
		_baseClass=vBaseClass,
		_interface=vInterface,
		_fnCom=vFnCom,
	}, ClassTableCom)
	return self
end

function ClassTableCom:waitBuild()
	self._fnCom:waitBuild()
end

function ClassTableCom:finishSetMetaTable()
	self._fnCom:finishSetMetaTable()
end

function ClassTableCom:getBase()::Ret(class.MetaObject)
	return self._interface
end

function ClassTableCom:finishBuild(vContext:class.Context)
	-- TODO seal table
end

function ClassTableCom:getLuaTable()::Ret(class.LuaTable)
	return self._luaTable
end

function ClassTableCom.is(vType)::isguard(class.ClassTableCom)
	return getmetatable(vType) == ClassTableCom
end

return ClassTableCom
