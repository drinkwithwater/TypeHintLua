
const StringLiteral = require "thlua.type.StringLiteral"
const TypeFunction = require "thlua.func.TypeFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const LuaFunction = require "thlua.func.LuaFunction"
const Nil = require "thlua.type.Nil"
const TableComClass = require "thlua.object.TableComClass"

(@let.class = import("thlua.type.TypeClass").class)

const ClassTableCom = TableComClass()


-- TODO vImplType can be struct, class
function ClassTableCom.new(vManager:class.TypeManager, vLuaTable:class.LuaTable, vFnCom:class.ClassFnCom,
	vBaseClass:Union(class.LuaTable, False), vInterface:Union(class.MetaObject, False))::RetClass(class.ClassTableCom, class.ITableCom)
	const self = setmetatable({::Self()
		_manager=vManager,
		_luaTable=vLuaTable,
		_defaultCom=vLuaTable:getDefaultCom(),
		_valueDict={}@Dict(class.IAtomType, class.UAtomUnion),
		_keyType=false@class.UAtomUnion,
		_sealed=false@Boolean,
		_baseClass=vBaseClass,
		_interface=(vInterface or vManager.type.Object) @ class.MetaObject,
		_fnCom=vFnCom,
	}, ClassTableCom)
	return self
end

function ClassTableCom:meta_set(vContext, vKeyType, vValueType)
	self._fnCom:checkDefine()
	if not self._sealed then
		self._defaultCom:meta_set(vContext, vKeyType, vValueType)
		return
	end
	const nContainKey = self._keyType:containAtom(vKeyType)
	if not nContainKey then
		vContext:error("key not found", tostring(vKeyType))
	else
		local nValue = self._valueDict[nContainKey]!
		if not nValue:containAll(vValueType) then
			vContext:error("field not match", tostring(vKeyType))
		end
	end
end

function ClassTableCom:meta_get(vContext, vKeyType)::Ret(class.UAtomUnion)
	self._fnCom:checkDefine()
	if not self._sealed then
		return self._defaultCom:meta_get(vContext, vKeyType)
	end
	const nContainKey = self._keyType:containAtom(vKeyType)
	if nContainKey then
		return self._valueDict[nContainKey]!
	else
		vContext:error("key not found", tostring(vKeyType))
		return self._manager.type.Nil
	end
end

function ClassTableCom:meta_bop_func(vContext, vOper)
	self._fnCom:checkDefine()
	return self._defaultCom:meta_bop_func(vContext, vOper)
end

function ClassTableCom:native_next(vContext, vInitType)
	self._fnCom:checkDefine()
	return self._defaultCom:native_next(vContext, vInitType)
end

function ClassTableCom:native_getmetatable(vContext)
	self._fnCom:checkDefine()
	return self._defaultCom:native_getmetatable(vContext)
end

function ClassTableCom:native_setmetatable(vContext, vMetaTable)
	-- TODO, can only set once in ClassFn's context
	self._fnCom:checkDefine()
	return self._defaultCom:native_setmetatable(vContext, vMetaTable)
end

function ClassTableCom:getBase()::Ret(class.MetaObject)
	return self._interface
end

function ClassTableCom:implement(vContext:class.Context)
	if self._sealed then
		vContext:error("class table try seal more than once")
		return
	end
	self._sealed = true
	const nCollection = self._manager:TypeCollection()
	const nDefaultCom:class.DefaultTableCom = self._defaultCom
	nDefaultCom:foreachGetPair(function(vKey, vValue)
		nCollection:put(vKey)
		self._valueDict[vKey] = vValue
	end)
	local nIndexTable = nDefaultCom.__indexType
	if nIndexTable then
		if LuaFunction.is(nIndexTable) or TypeFunction.is(nIndexTable) then
			-- TODO
		else
			nIndexTable:getDefaultCom():foreachGetPair(function(vKey, vValue)
				if LuaFunction.is(vValue) then
					if vValue:isMember() then
						nCollection:put(vKey)
						local nInterfaceValue = self._interface:getValueDict()[vKey]
						if nInterfaceValue then
							if MemberFunction.is(nInterfaceValue) then
								const nTypeFn = nInterfaceValue:indexTypeFn(self._luaTable)
								self._valueDict[vKey] = vValue:specialize(vContext, self._luaTable, nTypeFn)
								return
							end
						end
						self._valueDict[vKey] = vValue:specialize(vContext, self._luaTable)
					else
						nCollection:put(vKey)
						self._valueDict[vKey] = vValue
					end
				elseif TypeFunction.is(vValue) then
					print("TypeFunction as indexing member TODO")
				end
			end)
		end
	end
	self._keyType = nCollection:mergeToAtomUnion()
	const nLenFn = nDefaultCom:getMetaEventDict()["__len"]
	if LuaFunction.is(nLenFn) then
		const nFn = self._manager:checkedFn(self._luaTable):Ret(self._manager.type.Integer)
		nLenFn:specialize(vContext, self._luaTable, nFn)
	end
	const nStringFn = nDefaultCom:getMetaEventDict()["__tostring"]
	if LuaFunction.is(nStringFn) then
		const nFn = self._manager:checkedFn(self._luaTable):Ret(self._manager.type.String)
		nStringFn:specialize(vContext, self._luaTable, nFn)
	end
end

function ClassTableCom:getCompletion()
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function ClassTableCom.is(vType)::isguard(class.ClassTableCom)
	return getmetatable(vType) == ClassTableCom
end

return ClassTableCom
