
local StringLiteral = require "thlua.type.StringLiteral"
local TypeFunction = require "thlua.func.TypeFunction"
local MemberFunction = require "thlua.func.MemberFunction"
local LuaFunction = require "thlua.func.LuaFunction"
local Nil = require "thlua.type.Nil"

(@let.class = import("thlua.type.TypeClass").class)

local ClassTableCom = {}

ClassTableCom.__index=ClassTableCom

-- TODO vImplType can be struct, class
function ClassTableCom.new(vManager:class.TypeManager, vLuaTable:class.LuaTable, vFnCom:class.ClassFnCom,
	vBaseClass:Union(class.LuaTable, False), vInterface:Union(class.MetaObject, False))::RetClass(class.ClassTableCom)
	local self = setmetatable({::Self()
		_manager=vManager,
		_luaTable=vLuaTable,
		_defaultCom=vLuaTable:getDefaultCom(),
		_valueDict={},
		_keyType=false,
		_baseClass=vBaseClass,
		_interface=vInterface or vManager.type.Object,
		_fnCom=vFnCom,
	}, ClassTableCom)
	return self
end

function ClassTableCom:checkDefine()
	self._fnCom:checkDefine()
end

function ClassTableCom:meta_set(vContext, vKeyType, vValueType)
	local nContainKey = self._keyType:containAtom(vKeyType)
	if not nContainKey then
		vContext:error("key not found", tostring(vKeyType))
	else
		local nValue = self._valueDict[nContainKey]
		if not nValue:containAll(vValueType) then
			vContext:error("field not match", tostring(vKeyType))
		end
	end
end

function ClassTableCom:meta_get(vContext, vKeyType)::Ret(class.UAtomUnion)
	local nContainKey = self._keyType:containAtom(vKeyType)
	if nContainKey then
		return self._valueDict[nContainKey]
	else
		vContext:error("key not found", tostring(vKeyType))
		return self._manager.type.Nil
	end
end

function ClassTableCom:meta_bop_func(vContext, vOper)::Ret(False, Nil):Ret(True, Union(class.TypeFunction, class.LuaFunction))
	return self._luaTable:getDefaultCom():meta_bop_func(vContext, vOper)
end

function ClassTableCom:checkStruct()
	return self._interface
end

function ClassTableCom:implement(vContext)
	local nCollection = self._manager:TypeCollection()
	self._defaultCom:foreachGetPair(function(vKey, vValue)
		nCollection:put(vKey)
		self._valueDict[vKey] = vValue
	end)
	local nIndexTable = self._defaultCom.__indexType
	if nIndexTable then
		nIndexTable:foreachGetPair(function(vKey, vValue)
			if LuaFunction.is(vValue) then
				if vValue:isMember() then
					nCollection:put(vKey)
					local nInterfaceValue = self._interface:getValueDict()[vKey]
					if nInterfaceValue then
						if MemberFunction.is(nInterfaceValue) then
							self._valueDict[vKey] = vValue:implement(vContext, self._luaTable, nInterfaceValue:indexTypeFn(self._luaTable))
							return
						end
					end
					self._valueDict[vKey] = vValue:implement(vContext, self._luaTable)
				else
					nCollection:put(vKey)
					self._valueDict[vKey] = vValue
				end
			elseif TypeFunction.is(vValue) then
				print("TypeFunction as indexing member TODO")
			end
		end)
	end
	self._keyType = nCollection:mergeToAtomUnion()
end

function ClassTableCom:getCompletion()
	local nDict = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function ClassTableCom.is(vType)::isguard(class.ClassTableCom)
	return getmetatable(vType) == ClassTableCom
end

return ClassTableCom
