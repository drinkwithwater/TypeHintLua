
const StringLiteral = require "thlua.type.StringLiteral"
const TypeFunction = require "thlua.func.TypeFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const LuaFunction = require "thlua.func.LuaFunction"
const Nil = require "thlua.type.Nil"
const TableComClass = require "thlua.object.TableComClass"

(@let.class = import("thlua.type.TypeClass").class)

const ClassTableCom = TableComClass()

-- TODO vImplType can be struct, class
function ClassTableCom.new(vManager:class.TypeManager, vRefer:class.Reference, vLuaTable:class.LuaTable, vFnCom:class.ClassFnCom,
	vBaseClass:Union(class.LuaTable, False), vInterface:class.MetaObject)::RetClass(class.ClassTableCom, class.ITableCom)
	const self = setmetatable({::Self()
		_manager=vManager,
		_luaTable=vLuaTable,
		_refer=vRefer,
		_defaultCom=vLuaTable:getDefaultCom(),
		_valueDict={}@Dict(class.IAtomType, class.UAtomUnion),
		_keyType=false@class.UAtomUnion,
		_sealed=false@Boolean,
		_baseClass=vBaseClass,
		_interface=vInterface,
		_fnCom=vFnCom,
		_waitCoToSid={}@Dict(Thread, Integer),
		_buildReady=false@Boolean,
		_calledSelf=false@Boolean,
	}, ClassTableCom)
	return self
end

function ClassTableCom:longHintSelf()
	self._calledSelf = true
end

function ClassTableCom:waitBuild()
	self._fnCom:startBuild()
	const nCurCo = coroutine.running()
	const nSelfCo = self._refer:getSelfCo()
	if nCurCo ~= nSelfCo then
		if not self._buildReady then
			const nSessionId = self._manager:genSessionId()
			self._waitCoToSid[nCurCo] = nSessionId
			self._manager:coWait(nCurCo, nSessionId, nSelfCo)
		end
	else
		assert(self._calledSelf, "build a ClassTable with {Self()} before use it")
	end
end

function ClassTableCom:meta_set(vContext, vKeyType, vValueType)
	self:waitBuild()
	if not self._sealed then
		self._defaultCom:meta_set(vContext, vKeyType, vValueType)
		return
	end
	const nContainKey = self._keyType:containAtom(vKeyType)
	if not nContainKey then
		vContext:error("key not found", tostring(vKeyType))
	else
		local nValue = self._valueDict[nContainKey]!
		if not nValue:containAll(vValueType) then
			vContext:error("field not match", tostring(vKeyType))
		end
	end
end

function ClassTableCom:meta_get(vContext, vKeyType)::Ret(class.UAtomUnion)
	self:waitBuild()
	if not self._sealed then
		return self._defaultCom:meta_get(vContext, vKeyType)
	end
	const nContainKey = self._keyType:containAtom(vKeyType)
	if nContainKey then
		return self._valueDict[nContainKey]!
	else
		vContext:error("key not found", tostring(vKeyType))
		return self._manager.type.Nil
	end
end

function ClassTableCom:meta_bop_func(vContext, vOper)
	self:waitBuild()
	return self._defaultCom:meta_bop_func(vContext, vOper)
end

function ClassTableCom:native_next(vContext, vInitType)
	self:waitBuild()
	return self._defaultCom:native_next(vContext, vInitType)
end

function ClassTableCom:native_getmetatable(vContext)
	self:waitBuild()
	return self._defaultCom:native_getmetatable(vContext)
end

function ClassTableCom:native_setmetatable(vContext, vMetaTable)
	-- TODO, can only set once in ClassFn's context
	assert(coroutine.running() == self._refer:getSelfCo(), "can only setmetatable in constructor thread")
	const nRe = self._defaultCom:native_setmetatable(vContext, vMetaTable)
	--self:implement(vContext)
	const nCollection = self._manager:TypeCollection()
	const nDefaultCom:class.DefaultTableCom = self._defaultCom
	local nIndexTable = nDefaultCom.__indexType
	if nIndexTable then
		if LuaFunction.is(nIndexTable) or TypeFunction.is(nIndexTable) then
			print("TODO, __index's value is function")
			-- TODO
		else
			const nInterfaceKeyValue = self._interface:copyValueDict(self._luaTable)
			nIndexTable:getDefaultCom():foreachGetPair(function(vKey, vValue)
				local nInterfaceValue = nInterfaceKeyValue[vKey]
				if LuaFunction.is(vValue) then
					if vValue:isMember() then
						nCollection:put(vKey)
						if nInterfaceValue then
							if TypeFunction.is(nInterfaceValue) then
								self._valueDict[vKey] = vValue:specialize(vContext, self._luaTable, nInterfaceValue)
								return
							end
						end
						self._valueDict[vKey] = vValue:specialize(vContext, self._luaTable)
					else
						nCollection:put(vKey)
						self._valueDict[vKey] = vValue
					end
				elseif TypeFunction.is(vValue) then
					print("TypeFunction as indexing member TODO")
				end
			end)
		end
	end
	self._keyType = nCollection:mergeToAtomUnion()
	const nLenFn = nDefaultCom:getMetaEventDict()["__len"]
	if LuaFunction.is(nLenFn) then
		const nFn = self._manager:checkedFn(self._luaTable):Ret(self._manager.type.Integer)
		nLenFn:specialize(vContext, self._luaTable, nFn)
	end
	const nStringFn = nDefaultCom:getMetaEventDict()["__tostring"]
	if LuaFunction.is(nStringFn) then
		const nFn = self._manager:checkedFn(self._luaTable):Ret(self._manager.type.String)
		nStringFn:specialize(vContext, self._luaTable, nFn)
	end
	self._buildReady=true
	for co, sid in pairs(self._waitCoToSid) do
		self._manager:coWakeup(co, sid)
	end
	return nRe
end

function ClassTableCom:getBase()::Ret(class.MetaObject)
	return self._interface
end

function ClassTableCom:finishBuild(vContext:class.Context)
	if self._sealed then
		vContext:error("class table try seal more than once")
		return
	end
	self._sealed = true
	const nCollection = self._manager:TypeCollection()
	if self._keyType then
		nCollection:put(self._keyType)
	end
	const nDefaultCom:class.DefaultTableCom = self._defaultCom
	nDefaultCom:foreachGetPair(function(vKey, vValue)
		nCollection:put(vKey)
		self._valueDict[vKey] = vValue
	end)
	self._keyType = nCollection:mergeToAtomUnion()
end

function ClassTableCom:getLuaTable()::Ret(class.LuaTable)
	return self._luaTable
end

function ClassTableCom:getRefer()::Ret(class.Reference)
	return self._refer
end

function ClassTableCom:getCompletion()
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function ClassTableCom.is(vType)::isguard(class.ClassTableCom)
	return getmetatable(vType) == ClassTableCom
end

return ClassTableCom
