
const StringLiteral = require "thlua.type.StringLiteral"
const MetaObject = require "thlua.object.MetaObject"
const TypeFunction = require "thlua.func.TypeFunction"
const LuaFunction = require "thlua.func.LuaFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"
const TableComClass = require "thlua.object.TableComClass"

(@do
	let.class = import("thlua.type.TypeClass").class
	let.TableField = Struct {
		rawValueType = class.UAtomUnion,
		castValueType = OrFalse(class.UAtomUnion),
		kind = Union("property", "override", "getter"),
	}
end)

const DefaultTableCom = TableComClass()

function DefaultTableCom.new(vManager:class.TypeManager,
	vLuaTable:class.LuaTable)::RetClass(class.DefaultTableCom, class.ITableCom)
	const self = setmetatable({::Self()
		_manager=vManager,
		_keyType=vManager.type.Never @class.UAtomUnion,
		_fieldDict={}@Dict(class.IAtomType, let.TableField),
		_nextValue=false@Union(False, class.UAtomUnion),
		_nextDict=false@Union(False, Dict(class.IAtomType, class.UAtomUnion)),
		_luaTable=vLuaTable,
		_metaTable=false@OrFalse(class.LuaTable),
		__indexType=false@OrFalse(class.UIndexType),
		__newindexType=false@OrFalse(class.UIndexType),
		_metaEventDict={}@Dict(String, class.IAtomType),
		_isBasingDefault=false@Boolean,
	}, DefaultTableCom)
	return self
end

function DefaultTableCom:initByKeyValue(vKeyType:class.UAtomUnion, vValueDict:Dict(class.IAtomType, class.UAtomUnion))::Ret()
	self._keyType = vKeyType
	for k,v in pairs(vValueDict) do
		self._fieldDict[k] = {
			rawValueType = v,
			castValueType = false,
			kind = "property",
		}
	end
end

function DefaultTableCom:_setMeta(vIndexType:OrFalse(class.UIndexType), vNewIndexType:OrFalse(class.UIndexType), vMetaEventDict:Dict(String, class.IAtomType))
	self.__indexType = vIndexType
	self.__newindexType = vNewIndexType
	self._metaEventDict = vMetaEventDict
end

function DefaultTableCom:foreachGetPair(vFunc:Fn(class.IAtomType, class.UAtomUnion))
	self._keyType:foreach(function(vType)
		vFunc(vType, self._fieldDict[vType]!.rawValueType)
	end)
end

function DefaultTableCom:meta_set(vContext, vKeyType, vValueType)
	self:meta_set_ifoverride(vContext, vKeyType, vValueType, false)
end

function DefaultTableCom:meta_set_ifoverride(vContext:class.Context, vKeyType:class.IAtomType, vValueType:class.UAtomUnion, vOverride:Union(Nil,Boolean))
	if self._isBasingDefault then
		self._manager:basingByDefault(vValueType)
	end
	local nKeyContainType = self._keyType:containAtom(vKeyType)
	if nKeyContainType then
		const nTableField = self._fieldDict[nKeyContainType]!
		const nFieldType = nTableField.castValueType or nTableField.rawValueType
		if not nFieldType:containAll(vValueType) then
			if nTableField.kind == "override" then
				nTableField.rawValueType = vValueType
				if not vOverride then
					nTableField.kind = "property"
				end
			else
				vContext:error("wrong value type when set key:"..tostring(nKeyContainType))
			end
		end
		return
	end
	local nNewIndexType = self.__newindexType
	if not nNewIndexType then
		self:native_rawset(vContext, vKeyType, vValueType, vOverride)
		return
	else
		if vOverride then
			vContext:error("can't set override when trigger meta __newindex")
		end
		nNewIndexType:meta_set(vContext, vKeyType, vValueType)
		return
	end
end

function DefaultTableCom:_pmeta_get(vContext:class.Context, vKeyType:class.IAtomType)::Ret(Boolean, class.UAtomUnion)
	local nKeyContainType = self._keyType:containAtom(vKeyType)
	if nKeyContainType then
		const nField = self._fieldDict[nKeyContainType]!
		return true, nField.castValueType or nField.rawValueType
	end
	local nIndexType = self.__indexType
	if not nIndexType then
		return false, self._manager.type.Nil
	else
		if not LuaFunction.is(nIndexType) and not TypeFunction.is(nIndexType) then
			-- TODO if nIndexType is Function, call it...
			return nIndexType:getDefaultCom():_pmeta_get(vContext, vKeyType)
		else
			return false, self._manager.type.Nil
		end
	end
end

function DefaultTableCom:meta_get(vContext, vKeyType:class.IAtomType)
	local nOkay, nReType = self:_pmeta_get(vContext, vKeyType)
	if not nOkay then
		vContext:error("index error, key=", tostring(vKeyType))
	end
	return nReType
end

function DefaultTableCom:getMetaEventDict()::Ret(Dict(String, class.IAtomType))
	return self._metaEventDict
end

function DefaultTableCom:meta_bop_func(vContext, vOper)
	local nMethodEvent = OPER_ENUM.all[vOper]!
	local nMethodType = self._metaEventDict[nMethodEvent]
	if not nMethodType then
		return false, nil
	else
		return true, nMethodType
	end
end

function DefaultTableCom:native_rawset(vContext, vKeyType, vValueType, vOverride)
	if self._isBasingDefault then
		self._manager:basingByDefault(vValueType)
	end
	local nContainType = self._keyType:containAtom(vKeyType)
	if not nContainType then
		if vKeyType:isSingleton() and not vKeyType:isNilable() then
			-- TODO thinking when to lock this
			self._keyType = self._manager:checkedUnion(self._keyType, vKeyType)
			self._fieldDict[vKeyType] = {
				rawValueType = vValueType,
				castValueType = false,
				kind = vOverride and "override" or "property",
			}
		else
			vContext:error("set("..tostring(vKeyType)..","..tostring(vValueType)..") error")
		end
	else
		assert(not vOverride, "unexcepted case, rawset take override=true")
		const nTableField = self._fieldDict[nContainType]!
		const nFieldType = nTableField.castValueType or nTableField.rawValueType
		if not nFieldType:containAll(vValueType) then
			vContext:error("wrong value type when set, key:"..tostring(nContainType))
		else
			if nTableField.kind == "override" then
				nTableField.kind = "property"
			end
		end
	end
end

function DefaultTableCom:native_rawget(vContext, vKeyType)::Ret(class.UAtomUnion)
	local nKeyContainType = self._keyType:containAtom(vKeyType)
	if nKeyContainType then
		const nField = self._fieldDict[nKeyContainType]!
		return nField.castValueType or nField.rawValueType
	else
		return self._manager.type.Nil
	end
end

function DefaultTableCom:native_getmetatable(vContext)
	return self._metaTable or self._manager.type.Nil
end

function DefaultTableCom:native_setmetatable(vContext, vMetaTableType)
	-- TODO thinking when to lock this ?
	assert(not self._metaTable, "meta table can be only set once")
	self._metaTable = vMetaTableType
	local nManager = self._manager
	const nIndexType = nManager:validIndexType(vMetaTableType:native_rawget(vContext, nManager:Literal("__index")))
	const nNewIndexType = nManager:validIndexType(vMetaTableType:native_rawget(vContext, nManager:Literal("__newindex")))
	local nMetaEventToType:Dict(String, class.IAtomType) = {}
	for nOper, nEvent in pairs(OPER_ENUM.all) do
		const nMethodType = vMetaTableType:native_rawget(vContext, nManager:Literal(nEvent))
		if TypeFunction.is(nMethodType) or LuaFunction.is(nMethodType) then
			nMetaEventToType[nEvent] = nMethodType
		end
	end
	const nSomeEvents:List(String) = {"__len", "__tostring"}
	for _, nEvent in pairs(nSomeEvents) do
		const nMethodType = vMetaTableType:native_rawget(vContext, nManager:Literal(nEvent))
		if TypeFunction.is(nMethodType) or LuaFunction.is(nMethodType) then
			nMetaEventToType[nEvent] = nMethodType
		end
	end
	self:_setMeta(nIndexType, nNewIndexType, nMetaEventToType)
	if nIndexType then
		if LuaFunction.is(nIndexType) or TypeFunction.is(nIndexType) then
			-- print("TODO, __index's value is function")
			-- TODO
		else
			const nMetaIndexKey, nMetaIndexValueDict = nIndexType:getDefaultCom():lockAndGetKV()
			const nSelfKey, nSelfFieldDict = self._keyType, self._fieldDict
			const nMergedKeyType = self._manager:checkedUnion(nMetaIndexKey, nSelfKey)
			const nFinalFieldDict:Dict(class.IAtomType, let.TableField) = {}
			const nNever = self._manager.type.Never
			nMergedKeyType:foreach(function(vKeyAtom)
				const nSelfInter = nSelfKey:intersectAtom(vKeyAtom) or nNever
				const nMetaInter = nMetaIndexKey:intersectAtom(vKeyAtom) or nNever
				assert(type(nSelfInter) == "table")
				assert(type(nMetaInter) == "table")
				const nCollection = self._manager:TypeCollection()
				local nSetter = false
				local nMemberCount = 0
				local nNotMemberCount = 0
				nSelfInter:foreach(function(vAtom)
					const nValue = nSelfFieldDict[vAtom]!.rawValueType
					nCollection:put(nValue)
					nSetter = true
					if LuaFunction.is(nValue) and nValue:isMember() then
						nMemberCount = nMemberCount + 1
					else
						nNotMemberCount = nNotMemberCount + 1
					end
				end)
				nMetaInter:foreach(function(vAtom)
					const nValue = nMetaIndexValueDict[vAtom]!
					nCollection:put(nValue)
					if LuaFunction.is(nValue) and nValue:isMember() then
						nMemberCount = nMemberCount + 1
					else
						nNotMemberCount = nNotMemberCount + 1
					end
				end)
				if nMemberCount > 0 then
					if not (nMemberCount == 1 and nNotMemberCount == 0) then
						vContext:error("member function must be isolate field in table, key="..tostring(vKeyAtom))
						return
					end
				end
				nFinalFieldDict[vKeyAtom] = {
					rawValueType = nCollection:mergeToAtomUnion(),
					castValueType = false,
					kind = nSetter and "property" or "getter",
				}
			end)
		end
	end
end

function DefaultTableCom:native_next(vContext, vInitType)
	local nNextDict = self._nextDict
	local nValueType = self._nextValue
	if not nNextDict or not nValueType then
		nNextDict = {}
		for k,v in pairs(self._fieldDict) do
			nNextDict[k] = v.castValueType or v.rawValueType
		end
		local nNil = self._manager.type.Nil
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneField in pairs(self._fieldDict) do
			const nValueType = nOneField.castValueType or nOneField.rawValueType
			const nNotnilType = nValueType:notnilType()
			nNextDict[nOneKey] = nNotnilType
			nCollection:put(nNotnilType)
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		nNextDict[nNil] = nNil
		self._nextValue = nValueType
		self._nextDict = nNextDict
	end
	return nValueType, nNextDict
end

function DefaultTableCom:lockAndGetKV()::Ret(class.UAtomUnion, Dict(class.IAtomType, class.UAtomUnion))
	const nDict:Dict(class.IAtomType, class.UAtomUnion) = {}
	for k,v in pairs(self._fieldDict) do
		nDict[k] = v.rawValueType
	end
	return self._keyType, nDict
end

function DefaultTableCom:basingByDefault()
	if not self._isBasingDefault then
		self._isBasingDefault = true
		for k, v in pairs(self._fieldDict) do
			self._manager:basingByDefault(v.rawValueType)
		end
	end
end

function DefaultTableCom:getCompletion()
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function DefaultTableCom:implInterface(vContext:class.Context, vInterface:class.MetaObject)
end

function DefaultTableCom:castStruct(vContext:class.Context, vObjectAtomUnion:class.UObjectAtomUnion)::Ret(OrFalse(class.MetaObject))
	if self._isBasingDefault then
		return false
	end
	local nFinalMatchStruct:OrFalse(class.MetaObject) = false
	local nFinalMatchCastList:List(Struct {class.LuaTable, class.UAllType}) = {}
	vObjectAtomUnion:foreach(function(vAtomType)
		if not MetaObject.is(vAtomType) then return end
		if vAtomType:isInterface() then return end
		const nCopyValueDict = vAtomType:copyValueDict()
		local nMatchSucc = true
		const nCastList:List(Struct {class.LuaTable, class.UAllType}) = {}
		self:foreachGetPair(function(vTableKey, vTableValue)
			if not nMatchSucc then
				return
			end
			local nMatchKey, nMatchValue = vAtomType:indexKeyValue(vTableKey)
			if not nMatchKey then
				nMatchSucc = false
				return
			end
			const nIsTable, nTableToCast = self._manager:tryLuaTable(vTableValue)
			if not nIsTable then
				const nOneMatchSucc = vContext:castLuaType(vTableValue, nMatchValue) or nMatchValue:containAll(vTableValue)
				if not nOneMatchSucc then
					nMatchSucc = false
					return
				end
			else
				nCastList[#nCastList + 1] = {nTableToCast, nMatchValue}
			end
			nCopyValueDict[nMatchKey] = nil
		end)
		if not nMatchSucc then
			return
		end
		for k,v in pairs(nCopyValueDict) do
			if not v:isNilable() then
				nMatchSucc = false
				break
			end
		end
		if nMatchSucc and not nFinalMatchStruct then
			nFinalMatchStruct = vAtomType
			nFinalMatchCastList = nCastList
		else
			vContext:error("table cast error, table may match more than one struct")
		end
	end)
	for _, nPair in ipairs(nFinalMatchCastList) do
		vContext:castLuaType(nPair[1], nPair[2])
	end
	return nFinalMatchStruct
end

return DefaultTableCom
