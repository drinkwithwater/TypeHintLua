
const StringLiteral = require "thlua.type.StringLiteral"
const TypeFunction = require "thlua.func.TypeFunction"
const LuaFunction = require "thlua.func.LuaFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"
const TableComClass = require "thlua.object.TableComClass"

(@let.class = import("thlua.type.TypeClass").class)

const DefaultTableCom = TableComClass()

function DefaultTableCom.new(vManager:class.TypeManager,
	vLuaTable:class.LuaTable)::RetClass(class.DefaultTableCom, class.ITableCom)
	const self = setmetatable({::Self()
		_manager=vManager,
		_keyType=vManager.type.Never @class.UAtomUnion,
		_valueDict={}@Dict(class.IAtomType, class.UAtomUnion),
		_nextValue=false@Union(False, class.UAtomUnion),
		_nextDict=false@Union(False, Dict(class.IAtomType, class.UAtomUnion)),
		_overrideLiteralSet={} @Dict(class.IAtomType, True),
		_luaTable=vLuaTable,
		_metaTable=false@OrFalse(class.LuaTable),
		__indexType=false@OrFalse(class.UIndexType),
		__newindexType=false@OrFalse(class.UIndexType),
		_metaEventDict={}@Dict(String, class.IAtomType),
		_baseStruct=false@Union(False, class.MetaObject),
	}, DefaultTableCom)
	return self
end

function DefaultTableCom:initByKeyValue(vKeyType:class.UAtomUnion, vValueDict:Dict(class.IAtomType, class.UAtomUnion))::Ret()
	self._keyType = vKeyType
	self._valueDict = vValueDict
end

function DefaultTableCom:_setMeta(vIndexType:OrFalse(class.UIndexType), vNewIndexType:OrFalse(class.UIndexType), vMetaEventDict:Dict(String, class.IAtomType))
	self.__indexType = vIndexType
	self.__newindexType = vNewIndexType
	self._metaEventDict = vMetaEventDict
end

function DefaultTableCom:foreachGetPair(vFunc:Fn(class.IAtomType, class.UAtomUnion))
	self._keyType:foreach(function(vType)
		vFunc(vType, self._valueDict[vType]!)
	end)
end

function DefaultTableCom:meta_set(vContext, vKeyType:class.IAtomType, vValueType:class.UAtomUnion)
	self:_meta_set(vContext, vKeyType, vValueType, false)
end

function DefaultTableCom:meta_set_override(vContext, vKeyType:class.IAtomType, vValueType:class.UAtomUnion)
	self:_meta_set(vContext, vKeyType, vValueType, true)
end

function DefaultTableCom:_meta_set(vContext:class.Context, vKeyType:class.IAtomType, vValueType:class.UAtomUnion, vOverride:Union(Nil,Boolean))
	local nKeyContainType = self._keyType:containAtom(vKeyType)
	if nKeyContainType then
		local nCurValueType = self._valueDict[nKeyContainType]!
		if not nCurValueType:containAll(vValueType) then
			if vKeyType:isSingleton() and not vKeyType:isNilable() and self._overrideLiteralSet[vKeyType] then
				self._valueDict[vKeyType] = vValueType
				if vOverride then
					self._overrideLiteralSet[vKeyType] = true
				end
			else
				vContext:error("wrong value type when set, value:"..tostring(vValueType).." !<= "..tostring(nCurValueType)..", key:"..tostring(nKeyContainType))
			end
		end
		return
	end
	local nNewIndexType = self.__newindexType
	if not nNewIndexType then
		self:native_rawset(vContext, vKeyType, vValueType, vOverride)
		return
	else
		if vOverride then
			vContext:error("can't set override when trigger meta __newindex")
		end
		nNewIndexType:meta_set(vContext, vKeyType, vValueType)
		return
	end
end

function DefaultTableCom:_meta_get(vContext:class.Context, vKeyType:class.IAtomType)::Ret(Boolean, class.UAtomUnion)
	local nKeyContainType = self._keyType:containAtom(vKeyType)
	if nKeyContainType then
		return true, self._valueDict[nKeyContainType]!
	end
	local nIndexType = self.__indexType
	if not nIndexType then
		return false, self._manager.type.Nil
	else
		if not LuaFunction.is(nIndexType) and not TypeFunction.is(nIndexType) then
			-- TODO if nIndexType is Function, call it...
			return nIndexType:getDefaultCom():_meta_get(vContext, vKeyType)
		else
			return false, self._manager.type.Nil
		end
	end
end

function DefaultTableCom:meta_get(vContext, vKeyType:class.IAtomType)
	local nOkay, nReType = self:_meta_get(vContext, vKeyType)
	if not nOkay then
		vContext:error("index error, key=", tostring(vKeyType))
	end
	return nReType
end

function DefaultTableCom:getMetaEventDict()::Ret(Dict(String, class.IAtomType))
	return self._metaEventDict
end

function DefaultTableCom:meta_bop_func(vContext, vOper)
	local nMethodEvent = OPER_ENUM.all[vOper]!
	local nMethodType = self._metaEventDict[nMethodEvent]
	if not nMethodType then
		return false, nil
	else
		return true, nMethodType
	end
end

function DefaultTableCom:native_rawset(vContext, vKeyType, vValueType, vOverride)
	local nContainType = self._keyType:containAtom(vKeyType)
	if not nContainType then
		if vKeyType:isSingleton() and not vKeyType:isNilable() then
			-- TODO thinking when to lock this
			self._keyType = self._manager:checkedUnion(self._keyType, vKeyType)
			self._valueDict[vKeyType] = vValueType
			if vOverride then
				self._overrideLiteralSet[vKeyType] = true
			end
		else
			vContext:error("rawset("..tostring(vKeyType)..","..tostring(vValueType)..") error")
		end
	else
		local nCurValueType = self._valueDict[nContainType]!
		if not nCurValueType:containAll(vValueType) then
			if vKeyType:isSingleton() and not vKeyType:isNilable() and self._overrideLiteralSet[vKeyType] then
				self._valueDict[vKeyType] = vValueType
				if vOverride then
					self._overrideLiteralSet[vKeyType] = true
				end
			else
				vContext:error("wrong value type when set, value:"..tostring(vValueType).." !<= "..tostring(nCurValueType)..", key:"..tostring(nContainType))
			end
		end
	end
end

function DefaultTableCom:native_rawget(vContext, vKeyType)::Ret(class.UAtomUnion)
	local nKeyContainType = self._keyType:containAtom(vKeyType)
	if nKeyContainType then
		return self._valueDict[nKeyContainType]!
	else
		return self._manager.type.Nil
	end
end

function DefaultTableCom:native_getmetatable()
	return self._metaTable or self._manager.type.Nil
end

function DefaultTableCom:native_setmetatable(vContext, vMetaTableType)
	-- TODO thinking when to lock this ?
	assert(not self._metaTable, "meta table can be only set once")
	self._metaTable = vMetaTableType
	local nManager = self._manager
	const nIndexType = nManager:validIndexType(vMetaTableType:native_rawget(vContext, nManager:Literal("__index")))
	const nNewIndexType = nManager:validIndexType(vMetaTableType:native_rawget(vContext, nManager:Literal("__newindex")))
	local nMetaEventToType:Dict(String, class.IAtomType) = {}
	for nOper, nEvent in pairs(OPER_ENUM.all) do
		const nMethodType = vMetaTableType:native_rawget(vContext, nManager:Literal(nEvent))
		if TypeFunction.is(nMethodType) or LuaFunction.is(nMethodType) then
			nMetaEventToType[nEvent] = nMethodType
		end
	end
	const nSomeEvents:List(String) = {"__len", "__tostring"}
	for _, nEvent in pairs(nSomeEvents) do
		const nMethodType = vMetaTableType:native_rawget(vContext, nManager:Literal(nEvent))
		if TypeFunction.is(nMethodType) or LuaFunction.is(nMethodType) then
			nMetaEventToType[nEvent] = nMethodType
		end
	end
	self:_setMeta(nIndexType, nNewIndexType, nMetaEventToType)
end

function DefaultTableCom:native_next(vContext, vInitType)
	local nNextDict = self._nextDict
	local nValueType = self._nextValue
	if not nNextDict or not nValueType then
		nNextDict = {}
		for k,v in pairs(self._valueDict) do
			nNextDict[k] = v
		end
		local nNil = self._manager.type.Nil
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneValue in pairs(self._valueDict) do
			nOneValue = nOneValue:checkAtomUnion():notnilType()
			nNextDict[nOneKey] = nOneValue
			nCollection:put(nOneValue)
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		nNextDict[nNil] = nNil
		self._nextValue = nValueType
		self._nextDict = nNextDict
	end
	return nValueType, nNextDict
end

function DefaultTableCom:checkBaseObjectType()
	return self._baseStruct or self._manager.type.Object
end

function DefaultTableCom:getCompletion()
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function DefaultTableCom:tryCast(vContext:class.Context, vStruct:class.MetaObject)::Ret(Boolean)
	local nCastSuccess = true
	self:foreachGetPair(function(vKeyType, vValueType)
		local nKey, nValue = vStruct:indexKeyValue(vKeyType)
		if nKey then
			if vContext:castLuaType(vValueType, nValue) then
				return
			elseif nValue:containAll(vValueType) then
				return
			else
				vContext:error("table cast fail, field="..tostring(vKeyType).." not match")
			end
		else
			vContext:error("table cast fail, field="..tostring(vKeyType).." not existed")
		end
		nCastSuccess = false
	end)
	return nCastSuccess
end

return DefaultTableCom
