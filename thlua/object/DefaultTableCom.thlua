
const StringLiteral = require "thlua.type.StringLiteral"
const MetaObject = require "thlua.object.MetaObject"
const TypeFunction = require "thlua.func.TypeFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const LuaFunction = require "thlua.func.LuaFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.TableField = Struct {
		rawValueType = clazz.UAtomUnion,
		castValueType = OrFalse(clazz.UAtomUnion),
		kind = Union("property", "getter"),
	}
end)

const DefaultTableCom = {}
DefaultTableCom.__index = DefaultTableCom

function:class(clazz.DefaultTableCom) DefaultTableCom.new(vManager:clazz.TypeManager,
	vLuaTable:clazz.LuaTable):impl(clazz.IMetaNative)
	const self = setmetatable({.class
		_manager=vManager,
		_keyType=vManager.type.Never @clazz.UAtomUnion,
		_fieldDict={}@Dict(clazz.IAtomType, let.TableField),
		_nextValue=false@Union(False, clazz.UAtomUnion),
		_nextDict=false@Union(False, Dict(clazz.IAtomType, clazz.UAtomUnion)),
		_luaTable=vLuaTable,
		_isBasingDefault=false@Boolean,
		_interface=false@OrFalse(clazz.MetaObject),
	}, DefaultTableCom)
	return self
end

function DefaultTableCom:initByKeyValue(vKeyType:clazz.UAtomUnion, vValueDict:Dict(clazz.IAtomType, clazz.UAtomUnion)):Ret()
	self._keyType = vKeyType
	for k,v in pairs(vValueDict) do
		self._fieldDict[k] = {
			rawValueType = v,
			castValueType = false,
			kind = "property",
		}
	end
end

function DefaultTableCom:setInterface(vInterface:clazz.MetaObject)
	self._interface = vInterface
end

function DefaultTableCom:foreachGetPair(vFunc:Fn(clazz.IAtomType, clazz.UAtomUnion))
	self._keyType:foreach(function(vType)
		vFunc(vType, self._fieldDict[vType]!.rawValueType)
	end)
end

function DefaultTableCom:meta_set(vContext, vKeyType, vValueType)
	if self._isBasingDefault then
		self._manager:basingByDefault(vValueType)
	end
	local nKeyIncludeType = self._keyType:containAtom(vKeyType)
	if nKeyIncludeType then
		const nTableField = self._fieldDict[nKeyIncludeType]!
		const nFieldType = nTableField.castValueType or nTableField.rawValueType
		if not nFieldType:containAll(vValueType) then
			vContext:error("wrong value type when set key:"..tostring(nKeyIncludeType))
		end
		return
	end
	self:native_rawset(vContext, vKeyType, vValueType)
end

function DefaultTableCom:meta_get(vContext, vKeyType:clazz.IAtomType)
	local nKeyIncludeType = self._keyType:containAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		return nField.castValueType or nField.rawValueType
	else
		vContext:error("index error, key=", tostring(vKeyType))
		return self._manager.type.Nil
	end
end

function DefaultTableCom:native_rawset(vContext, vKeyType, vValueType)
	if self._isBasingDefault then
		self._manager:basingByDefault(vValueType)
	end
	local nIncludeType = self._keyType:containAtom(vKeyType)
	if not nIncludeType then
		if vKeyType:isSingleton() and not vKeyType:isNilable() then
			-- TODO thinking when to lock this
			self._keyType = self._manager:checkedUnion(self._keyType, vKeyType)
			self._fieldDict[vKeyType] = {
				rawValueType = vValueType,
				castValueType = false,
				kind = "property",
			}
		else
			vContext:error("set("..tostring(vKeyType)..","..tostring(vValueType)..") error")
		end
	else
		const nTableField = self._fieldDict[nIncludeType]!
		const nFieldType = nTableField.castValueType or nTableField.rawValueType
		if not nFieldType:containAll(vValueType) then
			vContext:error("wrong value type when set, key:"..tostring(nIncludeType))
		end
	end
end

function DefaultTableCom:native_rawget(vContext, vKeyType):Ret(clazz.UAtomUnion)
	local nKeyIncludeType = self._keyType:containAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		return nField.castValueType or nField.rawValueType
	else
		return self._manager.type.Nil
	end
end

function DefaultTableCom:setMetaIndex(vContext:clazz.Context, vIndexType:OrFalse(clazz.UAtomUnion), vNewIndexType:OrFalse(clazz.UAtomUnion))
	if not vIndexType then
		return
	end
	if vIndexType:isUnion() then
		vContext:info("union type as __index TODO")
		return
	end
	if vIndexType:isNilable() then
		vContext:info("TODO, impl interface if setmetatable without index")
		return
	end
	const nMetaIndexKeyType, nMetaIndexValueDict = vIndexType:lockAsMetaIndex()
	if not nMetaIndexKeyType then
		vContext:info("use type.."..tostring(vIndexType).." as __index TODO")
		return
	end
	const nNever = self._manager.type.Never
	const nSelfKey, nSelfFieldDict = self._keyType, self._fieldDict
	const nMergedKeyType = self._manager:checkedUnion(nMetaIndexKeyType, nSelfKey)
	const nFinalFieldDict:Dict(clazz.IAtomType, let.TableField) = {}
	nMergedKeyType:foreach(function(vKeyAtom)
		const nSelfInter = nSelfKey:intersectAtom(vKeyAtom) or nNever
		const nMetaInter = nMetaIndexKeyType:intersectAtom(vKeyAtom) or nNever
		assert(type(nSelfInter) == "table")
		assert(type(nMetaInter) == "table")
		local nSetter = false
		local nLuaFnCount = 0
		local nLuaMfnCount = 0
		local nNotLuaFnCount = 0
		local nSelfIsNilable = false
		const nCollection = self._manager:TypeCollection()
		nSelfInter:foreach(function(vAtom)
			const nValue = nSelfFieldDict[vAtom]!.rawValueType
			nCollection:put(nValue)
			nSelfIsNilable = nSelfIsNilable or nValue:isNilable()
			nSetter = true
			if LuaFunction.is(nValue) then
				nLuaFnCount = nLuaFnCount + 1
				if nValue:isMember() then
					nLuaMfnCount = nLuaMfnCount + 1
				end
			else
				nNotLuaFnCount = nNotLuaFnCount + 1
			end
		end)
		if not nSelfInter:containAll(nMetaInter) or nSelfIsNilable then
			local nMetaIsNilable = false
			nMetaInter:foreach(function(vAtom)
				const nValue = nMetaIndexValueDict[vAtom]!
				nMetaIsNilable = nMetaIsNilable or nValue:isNilable()
				nCollection:put(nValue)
				if LuaFunction.is(nValue) then
					nLuaFnCount = nLuaFnCount + 1
					if nValue:isMember() then
						nLuaMfnCount = nLuaMfnCount + 1
					end
				else
					nNotLuaFnCount = nNotLuaFnCount + 1
				end
			end)
			const nFinalNilable = nMetaIsNilable or not nMetaInter:containAll(nSelfInter)
			const nMergedValueType = nCollection:mergeToAtomUnion()
			nFinalFieldDict[vKeyAtom] = {
				rawValueType = nFinalNilable and nMergedValueType or nMergedValueType:notnilType(),
				castValueType = false,
				kind = nSetter and "property" or "getter",
			}
		else
			nFinalFieldDict[vKeyAtom] = {
				rawValueType = nCollection:mergeToAtomUnion(),
				castValueType = false,
				kind = nSetter and "property" or "getter",
			}
		end
		if nLuaFnCount > 0 then
			if nNotLuaFnCount > 0 then
				vContext:error("mix lua function and other type when setmetatable, key="..tostring(vKeyAtom))
			elseif nLuaMfnCount > 0 and nLuaFnCount ~= nLuaMfnCount then
				vContext:error("mix member lua function and normal lua function when setmetatable, key="..tostring(vKeyAtom))
			end
		end
	end)
	self._fieldDict = nFinalFieldDict
	self._keyType = nMergedKeyType
	const nInterface = self._interface
	if nInterface then
		self:implInterface(vContext, nInterface)
	end
end

function DefaultTableCom:native_next(vContext, vInitType)
	local nNextDict = self._nextDict
	local nValueType = self._nextValue
	if not nNextDict or not nValueType then
		nNextDict = {}
		for nKeyAtom, nField in pairs(self._fieldDict) do
			if nField.kind == "property" then
				nNextDict[nKeyAtom] = nField.castValueType or nField.rawValueType
			end
		end
		local nNil = self._manager.type.Nil
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneField in pairs(self._fieldDict) do
			if nOneField.kind == "property" then
				const nValueType = nOneField.castValueType or nOneField.rawValueType
				const nNotnilType = nValueType:notnilType()
				nNextDict[nOneKey] = nNotnilType
				nCollection:put(nNotnilType)
			end
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		nNextDict[nNil] = nNil
		self._nextValue = nValueType
		self._nextDict = nNextDict
	end
	return nValueType, nNextDict
end

function DefaultTableCom:lockAndGet():Ret(clazz.UAtomUnion, Dict(clazz.IAtomType, clazz.UAtomUnion))
	const nDict:Dict(clazz.IAtomType, clazz.UAtomUnion) = {}
	for k, nField in pairs(self._fieldDict) do
		nDict[k] = nField.castValueType or nField.rawValueType
	end
	return self._keyType, nDict
end

function DefaultTableCom:basingByDefault()
	if not self._isBasingDefault then
		self._isBasingDefault = true
		for k, v in pairs(self._fieldDict) do
			self._manager:basingByDefault(v.rawValueType)
		end
	end
end

function DefaultTableCom:getCompletion():Ret(clazz.LspCompletion)
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function DefaultTableCom:implInterface(vContext:clazz.Context, vInterface:clazz.MetaObject)
	const nInterfaceKeyValue = vInterface:copyValueDict(self._luaTable)
	const nSelfKey = self._keyType
	const nSelfFieldDict = self._fieldDict
	for nKeyAtom, nValue in pairs(nInterfaceKeyValue) do
		const nSelfKeyAtom = nSelfKey:containAtom(nKeyAtom)
		if nSelfKeyAtom then
			const nField = nSelfFieldDict[nSelfKeyAtom]!
			const nSelfValue = nField.rawValueType
			if LuaFunction.is(nSelfValue) then
				if nSelfValue:isMember() then
					if TypeFunction.is(nValue) then
						nField.castValueType = nSelfValue:cast(vContext, nValue)
					end
				end
			else
				if not nValue:containAll(nSelfValue) then
					vContext:error("interface's field must be supertype for table's field, key="..tostring(nKeyAtom))
				end
			end
		else
			vContext:error("interface has field not implement, key="..tostring(nKeyAtom))
		end
	end
	for _, nField in pairs(nSelfFieldDict) do
		if not nField.castValueType then
			const nSelfValue = nField.rawValueType
			if LuaFunction.is(nSelfValue) then
				if nSelfValue:isMember() then
					const nFn = nSelfValue:getInnerFn()
					if MemberFunction.is(nFn) and not nFn:needPolyArgs() then
						nFn:indexAutoFn(self._luaTable)
					end
				end
			end
		end
	end
end

function DefaultTableCom:castStruct(vContext:clazz.Context, vObjectAtomUnion:clazz.UObjectAtomUnion):Ret(OrFalse(clazz.MetaObject))
	if self._isBasingDefault then
		return false
	end
	local nFinalMatchStruct:OrFalse(clazz.MetaObject) = false
	local nFinalMatchCastList:List(Struct {clazz.LuaTable, clazz.UAllType}) = {}
	vObjectAtomUnion:foreach(function(vAtomType)
		if not MetaObject.is(vAtomType) then return end
		if vAtomType:isInterface() then return end
		const nCopyValueDict = vAtomType:copyValueDict()
		local nMatchSucc = true
		const nCastList:List(Struct {clazz.LuaTable, clazz.UAllType}) = {}
		self:foreachGetPair(function(vTableKey, vTableValue)
			if not nMatchSucc then
				return
			end
			local nMatchKey, nMatchValue = vAtomType:indexKeyValue(vTableKey)
			if not nMatchKey then
				nMatchSucc = false
				return
			end
			const nIsTable, nTableToCast = self._manager:tryLuaTable(vTableValue)
			if not nIsTable then
				const nOneMatchSucc = vContext:castLuaType(vTableValue, nMatchValue) or nMatchValue:containAll(vTableValue)
				if not nOneMatchSucc then
					nMatchSucc = false
					return
				end
			else
				nCastList[#nCastList + 1] = {nTableToCast, nMatchValue}
			end
			nCopyValueDict[nMatchKey] = nil
		end)
		if not nMatchSucc then
			return
		end
		for k,v in pairs(nCopyValueDict) do
			if not v:checkAtomUnion():isNilable() then
				nMatchSucc = false
				break
			end
		end
		if nMatchSucc and not nFinalMatchStruct then
			nFinalMatchStruct = vAtomType
			nFinalMatchCastList = nCastList
		else
			vContext:error("table cast error, table may match more than one struct")
		end
	end)
	for _, nPair in ipairs(nFinalMatchCastList) do
		vContext:castLuaType(nPair[1], nPair[2])
	end
	return nFinalMatchStruct
end

function.open DefaultTableCom.is(v):isguard(clazz.DefaultTableCom)
	return getmetatable(v) == DefaultTableCom
end

return DefaultTableCom
