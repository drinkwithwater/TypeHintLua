
const Exception = require "thlua.Exception"
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const StringLiteral = require "thlua.type.StringLiteral"
const LuaFunction = require "thlua.func.LuaFunction"
const Nil = require "thlua.type.Nil"
const TypeFunction = require "thlua.func.TypeFunction"
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const ClassTableCom = require "thlua.object.ClassTableCom"
const DefaultTableCom = require "thlua.object.DefaultTableCom"
const MetaObject = require "thlua.object.MetaObject"

const LuaTable = AtomTypeClass()


(@let.class = import("thlua.type.TypeClass").class)

function LuaTable.new(vManager:class.TypeManager)::RetClass(class.LuaTable, class.IAtomType)
	const self = setmetatable({::Self()
		_manager=vManager,
		_name="Table"@String,
		_unionSign=false,
		bits=TYPE_BITS.OBJECT,
		id=vManager:genTypeId(),
		_defaultCom=nil@class.DefaultTableCom,
		_classCom=false@OrFalse(class.ClassTableCom),
		_castStruct=false@OrFalse(class.MetaObject),
	}, LuaTable)
	self._defaultCom=DefaultTableCom.new(self._manager, self)
	return self
end

function LuaTable:createClassTableCom(vFnCom:class.ClassFnCom, vRefer:class.Reference, vBaseClass:Union(False, class.LuaTable), vInterface:class.MetaObject)::Ret(class.ClassTableCom)
	const nCom = ClassTableCom.new(self._manager, vRefer, self, vFnCom, vBaseClass, vInterface)
	self._classCom = nCom
	return nCom
end

function LuaTable:getDefaultCom()::Ret(class.DefaultTableCom)
	return self._defaultCom
end

function LuaTable:_checkComOrStruct(vContext)::Ret(Union(class.ITableCom, class.MetaObject))
	const nCastStruct = self._castStruct
	if nCastStruct then
		vContext:warn("table has been cast to other type")
		return nCastStruct
	else
		return self._classCom or self._defaultCom
	end
end

function LuaTable:detailString(v, vVerbose)
	return "LuaTable-"..self._name
end

function LuaTable:setName(vName:String)
	self._name = vName
end

function LuaTable:meta_pairs(vContext)
	vContext:warn("lua table meta_pairs TODO")
	local nManager = self._manager
	return nManager.builtin.next, self, nManager.type.Nil
end

function LuaTable:meta_ipairs(vContext)
	vContext:warn("lua table meta_ipairs TODO")
	local nManager = self._manager
	return nManager.builtin.inext, self, nManager.type.Nil
end

function LuaTable:native_next(vContext, vInitType)
	const nClassCom = self._classCom
	if nClassCom then
		return nClassCom:native_next(vContext, vInitType)
	else
		vContext:error("only class table can take next")
		return self._manager.type.Never, {}
	end
end

function LuaTable:native_setmetatable(vContext, vMetaTableType)
	self:_checkComOrStruct(vContext):native_setmetatable(vContext, vMetaTableType)
end

function LuaTable:native_getmetatable(vContext)
	return self:_checkComOrStruct(vContext):native_getmetatable(vContext)
end

function LuaTable:native_type()
	return self._manager:Literal("table")
end

function LuaTable:native_rawget(vContext, vKeyType)::Ret(class.UAtomUnion)
	return self:_checkComOrStruct(vContext):native_rawget(vContext, vKeyType)
end

function LuaTable:native_rawset(vContext, vKeyType:class.IAtomType, vValueType:class.UAtomUnion, vOverride:Union(Nil, Boolean))
	self:_checkComOrStruct(vContext):native_rawset(vContext, vKeyType, vValueType, vOverride)
end

function LuaTable:meta_get(vContext, vKeyType)
	return self:_checkComOrStruct(vContext):meta_get(vContext, vKeyType)
end

function LuaTable:meta_set(vContext, vKeyType, vValueType)
	self:_checkComOrStruct(vContext):meta_set(vContext, vKeyType, vValueType)
end

function LuaTable:meta_set_override(vContext, vKeyType, vValueType)
	if self._classCom then
		vContext:error("override set can't work on class table")
	else
		self._defaultCom:meta_set_ifoverride(vContext, vKeyType, vValueType, true)
	end
end

function LuaTable:meta_len(vContext)
	-- TODO
	return self._manager.type.Number
end

function LuaTable:meta_uop_some(vContext, vOper)
	vContext:error("meta uop TODO:"..tostring(vOper))
	return self._manager.type.Never
end

function LuaTable:meta_bop_func(vContext, vOper)
	return self:_checkComOrStruct(vContext):meta_bop_func(vContext, vOper)
end

function LuaTable:isSingleton()
	return false
end

function LuaTable:assumeContainAtom(vAssumeSet, vType)
	-- TODO check struct
	if self == vType then
		return self
	else
		return false
	end
end

function LuaTable:assumeIntersectAtom(vAssumeSet, vType)
	if vType:assumeContainAtom(nil, self) then
		return self
	else
		return false
	end
end

function LuaTable:cast(vContext:class.Context, vObjectAtomUnion:class.UObjectAtomUnion)::Ret(OrFalse(class.MetaObject))
	if self._classCom then
		return false
	end
	const nOldStruct = self._castStruct
	if nOldStruct then
		local nMatchStruct:OrNil(class.MetaObject) = nil
		vObjectAtomUnion:foreach(function(vAtomType)
			if not nMatchStruct and MetaObject.is(vAtomType)
				and vAtomType:containAll(nOldStruct) and nOldStruct:containAll(vAtomType) then
				nMatchStruct = vAtomType
			end
		end)
		if not nMatchStruct then
			vContext:error("table can't cast to multi struct type")
			return false
		end
		return nMatchStruct
	end
	const nMatchStruct = self._defaultCom:castStruct(vContext, vObjectAtomUnion)
	if not nMatchStruct then
		vContext:error("default table can't cast to struct type", self)
		return false
	end
	self._castStruct = nMatchStruct
	return nMatchStruct
end

function LuaTable:objectPartType()
	return self
end

function LuaTable:mayRecursive()
	return true
end

-- called when struct contain
function LuaTable:checkBaseObjectType()
	const nClassCom = self._classCom
	if nClassCom then
		return nClassCom:getBase()
	end
	const nStruct = self._castStruct
	if nStruct then
		print("unexcepted case, table has been cast to struct, but still call checkBaseObjectType...")
		return nStruct
	end
	self._defaultCom:basingByDefault()
	return self._manager.type.Object
end

function LuaTable:getCompletion()::Ret(class.LspCompletion)
	const com = self._classCom or self._defaultCom
	return com:getCompletion()
end

function LuaTable.is(v)::isguard(class.LuaTable)
	return getmetatable(v) == LuaTable
end

return LuaTable
