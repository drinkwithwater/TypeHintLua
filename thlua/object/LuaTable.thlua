
local Exception = require "thlua.Exception"
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local OPER_ENUM = require "thlua.type.OPER_ENUM"
local StringLiteral = require "thlua.type.StringLiteral"
local LuaFunction = require "thlua.func.LuaFunction"
local Nil = require "thlua.type.Nil"
local TypeFunction = require "thlua.func.TypeFunction"
local AtomTypeClass = require "thlua.type.AtomTypeClass"

local LuaTable = AtomTypeClass()

(@var.class = import("thlua.type.TypeClass").class)

function LuaTable.new(vManager:class.TypeManager, vImplType:Union(class.LuaTable, class.Struct, Nil))::RetNew(class.LuaTable, class.IAtomType)
	local self = setmetatable({::New()
		_manager=vManager,
		_valueDict={} @Dict(class.IAtomType, class.IKeyType),
		_keyType=vManager.type.Never @class.IKeyType,
		_overrideLiteralSet={} @Dict(class.IAtomType, True),
		_name="Table",
		_meta=nil @Union(Nil, class.LuaTable),
		_sealed=false @Boolean,
		singleton=false,
		_unionSign=false,
		bits=TYPE_BITS.OBJECT,
		id=vManager:genTypeId(),
		_implType=vImplType or false,
	}, LuaTable)
	return self
end

function LuaTable:initByKeyValue(vKeyType:class.IKeyType, vValueDict:Dict(class.IAtomType, class.IValueType))::Ret()
	self._keyType = vKeyType
	self._valueDict = vValueDict
end

function LuaTable:detailString(v)
	return "LuaTable-"..self._name
end

function LuaTable:setName(vName)
	self._name = vName
end

function LuaTable:meta_pairs(vContext)
	local nStruct = self._implType
	if nStruct then
		return nStruct:meta_pairs(vContext)
	end
	error(tostring(self).." other case TODO")
end

function LuaTable:meta_ipairs(vContext)
	local nStruct = self._implType
	if nStruct then
		return nStruct:meta_ipairs(vContext)
	end
	error("other case TODO")
end

function LuaTable:native_next(vContext, vInitType)
	local nStruct = self._implType
	if nStruct then
		return nStruct:native_next(vContext, vInitType)
	end
	error("other case TODO")
end

function LuaTable:native_setmetatable(vContext, vMetaTableType)
	-- TODO thinking when to lock this ???
	self._meta = vMetaTableType
	return self
end

function LuaTable:native_getmetatable()
	if self._meta then
		return self._meta
	else
		return self._manager.type.Nil
	end
end

function LuaTable:native_type()
	return self._manager:Literal("table")
end

function LuaTable:native_rawget(vContext, vKeyType)::Ret(class.IKeyType)
	local nKeyContainType = self._keyType:_containOneNotRefer(vKeyType)
	if nKeyContainType then
		return self._valueDict[nKeyContainType]!
	else
		return self._manager.type.Nil
	end
end

function LuaTable:native_rawset(vContext, vKeyType:class.IAtomType, vValueType:class.IKeyType, vOverride:Union(Nil, Boolean))
	local nContainType = self._keyType:_containOneNotRefer(vKeyType)
	if not nContainType then
		if vKeyType:isSingleton() and not vKeyType:isNilable() then
			-- TODO thinking when to lock this
			self._keyType = self._manager:Union(self._keyType, vKeyType):checkType()
			self._valueDict[vKeyType] = vValueType
			if vOverride then
				self._overrideLiteralSet[vKeyType] = true
			end
		else
			vContext:error("rawset("..tostring(vKeyType)..","..tostring(vValueType)..") error")
		end
	else
		local nCurValueType = self._valueDict[nContainType]!
		if not nCurValueType:contain(vValueType) then
			if vKeyType:isSingleton() and not vKeyType:isNilable() and self._overrideLiteralSet[vKeyType] then
				self._valueDict[vKeyType] = vValueType
				if vOverride then
					self._overrideLiteralSet[vKeyType] = true
				end
			else
				vContext:error("wrong value type when set, value:"..tostring(vValueType).." !<= "..tostring(nCurValueType)..", key:"..tostring(nContainType))
			end
		end
	end
end

-- get without implement type
function LuaTable:_meta_get(vContext, vKeyType)::Ret(Boolean, class.IKeyType)
	local nKeyContainType = self._keyType:_containOneNotRefer(vKeyType)
	if nKeyContainType then
		return true, self._valueDict[nKeyContainType]!
	end
	local nMetaTable = self._meta
	local nNil = self._manager.type.Nil
	if not nMetaTable then
		return false, nNil
	else
		local nIndexType = nMetaTable:native_rawget(vContext, self._manager:Literal("__index"))
		if Nil.is(nIndexType) then
			return false, nNil
		end
		if LuaTable.is(nIndexType) then
			return nIndexType:_meta_get(vContext, vKeyType)
		else
			-- TODO if nIndexType is Function, call it...
			return false, nNil
		end
	end
end

function LuaTable:meta_get(vContext, vKeyType:class.IAtomType)
	local nImplType = self._implType
	if nImplType then
		local nContain = nImplType:getKeyType():_containOneNotRefer(vKeyType)
		if nContain then
			return nImplType:meta_get(vContext, nContain)
		end
	end
	local nOkay, nReType = self:_meta_get(vContext, vKeyType)
	if not nOkay then
		vContext:error("index error, key=", tostring(vKeyType))
	end
	return nReType
end

-- set without implement type
function LuaTable:_meta_set(vContext, vKeyType:class.IAtomType, vValueType:class.IKeyType, vOverride:Union(Nil,Boolean))::Ret()
	local nKeyContainType = self._keyType:_containOneNotRefer(vKeyType)
	if nKeyContainType then
		local nCurValueType = self._valueDict[nKeyContainType]!
		if not nCurValueType:contain(vValueType) then
			if vKeyType:isSingleton() and not vKeyType:isNilable() and self._overrideLiteralSet[vKeyType] then
				self._valueDict[vKeyType] = vValueType
				if vOverride then
					self._overrideLiteralSet[vKeyType] = true
				end
			else
				vContext:error("wrong value type when set, value:"..tostring(vValueType).." !<= "..tostring(nCurValueType)..", key:"..tostring(nKeyContainType))
			end
		end
		return
	end
	local nMetaTable = self._meta
	if not nMetaTable then
		self:native_rawset(vContext, vKeyType, vValueType, vOverride)
		return
	else
		local nNewIndexType = nMetaTable:native_rawget(vContext, self._manager:Literal("__newindex"))
		local nNil = self._manager.type.Nil
		if nNewIndexType == nNil then
			self:native_rawset(vContext, vKeyType, vValueType, vOverride)
			return
		end
		if nNewIndexType:isUnion() then
			vContext:error("__newindex can't be union type")
			return
		else
			-- TODO if nNewIndexType is Function, call it...
			if vOverride then
				vContext:error("can't set override when trigger meta __newindex")
			end
			nNewIndexType:meta_set(vContext, vKeyType, vValueType)
			return
		end
	end
end

function LuaTable:meta_set(vContext, vKeyType, vValueType)
	local nImplType = self._implType
	if nImplType then
		local nContain = nImplType:getKeyType():_containOneNotRefer(vKeyType)
		if nContain then
			nImplType:meta_set(vContext, nContain, vValueType)
			return
		end
	end
	self:_meta_set(vContext, vKeyType, vValueType, false)
end

function LuaTable:meta_set_override(vContext, vKeyType, vValueType)
	local nImplType = self._implType
	if nImplType then
		local nContain = nImplType:getKeyType():contain(vKeyType)
		if nContain then
			vContext:error("override field can't be in _implType")
			return
		end
	end
	self:_meta_set(vContext, vKeyType, vValueType, true)
end

function LuaTable:meta_len(vContext)
	return self._manager.type.Number
end

function LuaTable:meta_uop_some(vContext, vOper)
	vContext:error("meta uop TODO:"..tostring(vOper))
	return self._manager.type.Never
end

function LuaTable:meta_bop_func(vContext, vOper)
	local nMetaTable = self._meta
	if not nMetaTable then
		return false, nil
	else
		local nMethodName = OPER_ENUM.all[vOper]!
		local nMetaMethod = nMetaTable:native_rawget(vContext, self._manager:Literal(nMethodName))
		if Nil.is(nMetaMethod) then
			return false, nil
		end
		if not (LuaFunction.is(nMetaMethod) or TypeFunction.is(nMetaMethod)) then
			vContext:error("meta method :"..nMethodName.." must be callable")
			return false, nil
		end
		return true, nMetaMethod
	end
end

function LuaTable:isSingleton()
	return self.singleton
end

function LuaTable:_containOneNotRefer(vType)
	-- TODO check struct
	if self == vType then
		return self
	else
		return false
	end
end

function LuaTable:_intersectOneNotRefer(vType)
	if self == vType then
		return self
	elseif vType:_containOneNotRefer(self) then
		return self
	else
		return false
	end
end

-- called when New function checkDefine
function LuaTable:sealNew(vContext)
	local nImplType = self._implType
	if nImplType then
		self:_tryImpl(vContext, nImplType) 
	end
	self._sealed = true
end

function LuaTable:_tryImpl(vContext, vStruct)::Ret(Boolean)
	local nCastSuccess = true
	local nFuncPairList = {}
	vStruct:foreachGetPair(function(vKeyType, vValueType)
		local nDstType = vValueType:checkType()
		local nSrcType 
		local nRawValue = self:native_rawget(vContext, vKeyType)
		if not nRawValue:isNilable() then
			nSrcType = nRawValue
			self._valueDict[vKeyType] = nDstType
		else
			local _, nMetaGetValue = self:_meta_get(vContext, vKeyType)
			nSrcType = nMetaGetValue
		end
		if LuaFunction.is(nSrcType) then
			if not TypeFunction.is(nDstType) then
				nCastSuccess = false
			else
				if nDstType:isMember() then
					local nArgTuple = nDstType:getArgTuple()
					nDstType = self._manager:Function(nArgTuple:replaceFirst(self), nDstType:getRetTuples())
				end
				nFuncPairList[#nFuncPairList + 1] = {nSrcType, nDstType}
				if not vContext:cast(nSrcType, nDstType) then
					nCastSuccess = false
					vContext:error("field cast function failed, field="..tostring(vKeyType))
				end
			end
		elseif not nDstType:contain(nSrcType) then
			vContext:error("field cast fail, field="..tostring(vKeyType))
			nCastSuccess = false
		end
	end)
	vStruct:foreachSetPair(function(vKeyType, vValueType)
		if vKeyType:isSingleton() then
			local nRawValue = self:native_rawget(vContext, vKeyType)
			if not nRawValue:isNilable() then
				if not nRawValue:contain(vValueType) then
					vContext:error(" setter field error, field=", vKeyType)
				end
			else
				print("TODO check __newindex")
				-- self:_meta_set(vContext, vKeyType, vValueType, false)
			end
		else
			print("TODO check __newindex")
			-- self:_meta_set(vContext, vKeyType, vValueType, false)
		end
	end)
	return nCastSuccess
end

function LuaTable:cast(vContext, vStruct)::Ret(Boolean)
	if self._implType then
		return false
	end
	self._implType = vStruct
	local nCastSuccess = self:_tryImpl(vContext, vStruct)
	if not nCastSucess then
		self._implType = false
		self._sealed = true
		return false
	end
	return true
end

function LuaTable.is(v)::isguard(class.LuaTable)
	return getmetatable(v) == LuaTable
end

-- called when struct contain
function LuaTable:checkImplType()
	local nImplType = self._implType
	if not nImplType then
		nImplType = self._manager:Struct({})
		self._implType = nImplType
	end
	return nImplType
end

return LuaTable
