
local Exception = require "thlua.Exception"
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local OPER_ENUM = require "thlua.type.OPER_ENUM"
local StringLiteral = require "thlua.type.StringLiteral"
local LuaFunction = require "thlua.func.LuaFunction"
local Nil = require "thlua.type.Nil"
local TypeFunction = require "thlua.func.TypeFunction"
local AtomTypeClass = require "thlua.type.AtomTypeClass"
local ClassTableCom = require "thlua.object.ClassTableCom"
local StructTableCom = require "thlua.object.StructTableCom"
local DefaultTableCom = require "thlua.object.DefaultTableCom"

local LuaTable = AtomTypeClass()


(@let.class = import("thlua.type.TypeClass").class)

function LuaTable.new(vManager:class.TypeManager)::RetClass(class.LuaTable, class.IAtomType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_name="Table",
		_unionSign=false,
		singleton=false,
		bits=TYPE_BITS.OBJECT,
		id=vManager:genTypeId(),
		_sealed=false@Boolean,
		_metaTable=false,
		_sealCom=false@Union(class.StructTableCom, class.ClassTableCom),
	}, LuaTable)
	self._defaultCom=DefaultTableCom.new(self._manager, self)
	return self
end

function LuaTable:initByClass(vFnCom:class.ClassFnCom, vBaseClass:Union(False, class.LuaTable), vStruct:Union(False, class.MetaObject))
	self._sealCom = ClassTableCom.new(self._manager, self, vFnCom, vBaseClass, vStruct)
end

function LuaTable:getDefaultCom()::Ret(class.DefaultTableCom)
	return self._defaultCom
end

function LuaTable:getCurrentCom()
	if not self._sealed then
		return self._defaultCom
	else
		return self._sealCom or self._defaultCom
	end
	return self._sealCom or self._defaultCom
end

function LuaTable:detailString(v)
	return "LuaTable-"..self._name
end

function LuaTable:setName(vName)
	self._name = vName
end

function LuaTable:meta_pairs(vContext)
	local nSealCom = self._sealCom
	if StructTableCom.is(nSealCom) then
		return nSealCom:meta_pairs(vContext)
	else
		local nManager = self._manager
		return nManager.builtin.next, self, nManager.type.Nil
	end
end

function LuaTable:meta_ipairs(vContext)
	local nSealCom = self._sealCom
	if StructTableCom.is(nSealCom) then
		return nSealCom:meta_ipairs(vContext)
	else
		local nManager = self._manager
		return nManager.builtin.inext, self, nManager.type.Nil
	end
end

function LuaTable:native_next(vContext, vInitType)
	local nSealCom = self._sealCom
	if StructTableCom.is(nSealCom) then
		return nSealCom:native_next(vContext, vInitType)
	else
		print("lua table pairs, ipairs, next TODO")
		return self._manager.type.Never, {}
	end
end

function LuaTable:native_setmetatable(vContext, vMetaTableType:class.LuaTable)::Ret(class.LuaTable)
	-- TODO thinking when to lock this ?
	assert(not self._metaTable, "meta table can be only set once")
	self._metaTable = vMetaTableType
	local nManager = self._manager
	local nIndexType = vMetaTableType:native_rawget(vContext, nManager:Literal("__index"))
	local nNewIndexType = vMetaTableType:native_rawget(vContext, nManager:Literal("__newindex"))
	local nEventToType = {}
	local function isValidIndexType(vType)
		return LuaTable.is(vType) or TypeFunction.is(vType) or LuaFunction.is(vType)
	end
	if isValidIndexType(nIndexType) then
		nEventToType.__index=nIndexType
	end
	if isValidIndexType(nNewIndexType) then
		nEventToType.__newindex=nNewIndexType
	end
	local nOperEventToType = {}
	for nOper, nEvent in pairs(OPER_ENUM.all) do
		local nMethodType = vMetaTableType:native_rawget(vContext, nManager:Literal(nEvent))
		if TypeFunction.is(nMethodType) or LuaFunction.is(nMethodType) then
			nOperEventToType[nEvent] = nMethod
		end
	end
	self._defaultCom:setMetaEvent(nEventToType, nOperEventToType)
	return self
end

function LuaTable:foreachGetPair(vFunc)
	self._defaultCom:foreachGetPair(vFunc)
end

function LuaTable:native_getmetatable()::Ret(Union(class.LuaTable, class.Nil))
	if self._metaTable then
		return self._metaTable
	else
		return self._manager.type.Nil
	end
end

function LuaTable:native_type()
	return self._manager:Literal("table")
end

function LuaTable:native_rawget(vContext, vKeyType)::Ret(class.UAtomUnion)
	return self._defaultCom:native_rawget(vContext, vKeyType)
end

function LuaTable:native_rawset(vContext, vKeyType:class.IAtomType, vValueType:class.UAtomUnion, vOverride:Union(Nil, Boolean))
	if not self._sealed then
		self._defaultCom:native_rawset(vContext, vKeyType, vValueType, vOverride)
	else
		vContext:error("can rawset for a sealed table")
	end
end

function LuaTable:meta_get(vContext, vKeyType:class.IAtomType)
	return self:getCurrentCom():meta_get(vContext, vKeyType)
end

function LuaTable:meta_set(vContext, vKeyType, vValueType, vOverride)
	self:getCurrentCom():meta_set(vContext, vKeyType, vValueType, false)
end

function LuaTable:meta_set_override(vContext, vKeyType, vValueType)
	self:getCurrentCom():meta_set(vContext, vKeyType, vValueType, true)
end

function LuaTable:meta_len(vContext)
	-- TODO
	return self._manager.type.Number
end

function LuaTable:meta_uop_some(vContext, vOper)
	vContext:error("meta uop TODO:"..tostring(vOper))
	return self._manager.type.Never
end

function LuaTable:meta_bop_func(vContext, vOper)
	return self:getCurrentCom():meta_bop_func(vContext, vOper)
end

function LuaTable:isSingleton()
	return self.singleton
end

function LuaTable:atomContainAssume(vAssumeSet, vType)
	-- TODO check struct
	if self == vType then
		return self
	else
		return false
	end
end

function LuaTable:_intersectOneNotRefer(vType)
	if self == vType then
		return self
	elseif vType:containAtom(self) then
		return self
	else
		return false
	end
end

-- called when New function checkDefine
function LuaTable:sealNew(vContext)
	assert(not self._sealed, "is sealed")
	self._sealed = true
	self._sealCom:implement(vContext)
end

function LuaTable:cast(vContext, vStruct)::Ret(Boolean)
	if self._sealCom then
		return false
	end
	self._sealed = true
	local nStructCom = StructTableCom.new(self._manager, self, vStruct)
	-- TODO cast maybe fail, fail may be because union
	self._sealCom = nStructCom
	nStructCom:tryCast(vContext)
	return true
end

function LuaTable.is(v)::isguard(class.LuaTable)
	return getmetatable(v) == LuaTable
end

-- called when struct contain
function LuaTable:checkStruct()
	local nStructOrCom = self._sealCom
	if not nStructOrCom then
		nStructOrCom = self._manager.type.Object
		self._sealCom = nStructOrCom
	end
	return nStructOrCom:checkStruct()
end

function LuaTable:getCompletion()
	return self:getCurrentCom():getCompletion()
end

function LuaTable:checkDefine()
	if ClassTableCom.is(self._sealCom) then
		self._sealCom:checkDefine()
	end
end

return LuaTable
