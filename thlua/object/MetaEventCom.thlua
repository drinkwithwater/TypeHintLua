
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"
const TypeFunction = require "thlua.func.TypeFunction"
const LuaFunction = require "thlua.func.LuaFunction"

(@do
	let.class = import("thlua.type.TypeClass").class
	let.MetaFnField = Struct {
		sourceFn=OrFalse(class.LuaFunction, class.MemberFunction),
		typeFn=class.TypeFunction,
	}
end)

const MetaEventCom = {}
MetaEventCom.__index=MetaEventCom

function MetaEventCom.new(vManager:class.TypeManager)::RetClass(class.MetaEventCom)
	const self = setmetatable({::Self()
		_manager=vManager,
		_selfType=false@OrFalse(class.LuaTable, class.MetaObject),
		_bopEq=false@OrFalse(let.MetaFnField),
		_bopDict={}@Dict(String, let.MetaFnField),
		_uopLen=false@OrFalse(let.MetaFnField),
		_uopDict={}@Dict(String, let.MetaFnField),
		-- special
		_mode=false,
		_call=false@OrFalse(let.MetaFnField),
		_metatable=false,
		_tostring=false@OrFalse(let.MetaFnField),
		_pairs=false@OrFalse(let.MetaFnField),
		_ipairs=false,
		_gc=false,
		_name=false,
		_close=false,
	}, MetaEventCom)
	return self
end

const function buildFieldFromFn(vContext:class.Context, vEvent:String, vMethodFn:class.UAtomUnion,
	vSelfOrTypeFn:OrNil(class.TypeFunction, class.LuaTable))::Ret(OrNil(let.MetaFnField))
	if vMethodFn:isUnion() then
		vContext:error("meta method can't be union type, event:"..vEvent)
		return nil
	elseif TypeFunction.is(vMethodFn) then
		return {
			sourceFn=false,
			typeFn=vMethodFn
		}
	elseif LuaFunction.is(vMethodFn) then
		if TypeFunction.is(vSelfOrTypeFn) then
			return {
				sourceFn=vMethodFn,
				typeFn=vMethodFn:specialize(vContext, nil, vSelfOrTypeFn)
			}
		elseif vSelfOrTypeFn then
			return {
				sourceFn=vMethodFn,
				typeFn=vMethodFn:specialize(vContext, vSelfOrTypeFn, nil)
			}
		else
			return {
				sourceFn=vMethodFn,
				typeFn=vMethodFn:specialize(vContext, nil, nil)
			}
		end
	elseif not Nil.is(vMethodFn) then
		vContext:error("meta method type must be function or nil, event:"..vEvent)
	end
	return nil
end

function MetaEventCom:getBopFunc(vBopEvent:String)::Ret(OrNil(class.TypeFunction))
	const nField = self._bopDict[vBopEvent]
	return nField and nField.typeFn
end

function MetaEventCom:getPairsFunc()::Ret(OrFalse(class.TypeFunction))
	const nField = self._pairs
	return nField and nField.typeFn
end

function MetaEventCom:initByLuaTable(vContext:class.Context, vSelf:class.LuaTable, vMetaTable:class.DefaultTableCom)
	if not self._selfType then
		self._selfType = vSelf
	else
		vContext:error("meta event com init more than once")
		return
	end
	const nManager = self._manager
	-- 1. build bop
	for nOper, nEvent in pairs(OPER_ENUM.bopNoEq) do
		const nMethodType = vMetaTable:native_rawget(vContext, nManager:Literal(nEvent))
		const nField = buildFieldFromFn(vContext, nEvent, nMethodType)
		self._bopDict[nEvent] = nField
	end
	const nEqFn = vMetaTable:native_rawget(vContext, nManager:Literal("__eq"))
	if not Nil.is(nEqFn) then
		vContext:error("TODO meta logic for bop __eq", tostring(nEqFn))
	end
	-- 2. build uop
	const nLenFn = vMetaTable:native_rawget(vContext, nManager:Literal("__len"))
	const nLenTypeFn = nManager:checkedFn(vSelf):Ret(nManager.type.Integer)
	self._uopLen = buildFieldFromFn(vContext, "__len", nLenFn, nLenTypeFn) or false
	-- 3. build other
	-- 1) __tostring
	const nStringTypeFn = nManager:checkedFn(vSelf):Ret(nManager.type.String)
	const nStringFn = vMetaTable:native_rawget(vContext, nManager:Literal("__tostring"))
	self._tostring = buildFieldFromFn(vContext, "__tostring", nStringFn, nStringTypeFn) or false
	-- 2) __pairs
	const nPairsFn = vMetaTable:native_rawget(vContext, nManager:Literal("__pairs"))
	self._pairs = buildFieldFromFn(vContext, "__pairs", nPairsFn, vSelf) or false
end

function MetaEventCom:initByMetaObjectAction()
end

return MetaEventCom
