
const Reference = require "thlua.type.Reference"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"
const TypeFunction = require "thlua.func.TypeFunction"
const LuaFunction = require "thlua.func.LuaFunction"

(@do
	let.class = import("thlua.type.TypeClass").class
	let.MetaFnField = Struct {
		luaFn=OrFalse(class.LuaFunction),
		typeFn=class.TypeFunction,
	}
end)

const MetaEventCom = {}
MetaEventCom.__index=MetaEventCom

function MetaEventCom.new(vManager:class.TypeManager)::RetClass(class.MetaEventCom)
	const self = setmetatable({::Self()
		_manager=vManager,
		_selfType=false@OrFalse(class.LuaTable, class.MetaObject),
		_bopEq=false@OrFalse(let.MetaFnField),
		_bopDict={}@Dict(String, let.MetaFnField),
		_uopLen=false@OrFalse(let.MetaFnField),
		_uopDict={}@Dict(String, let.MetaFnField),
		-- special
		_mode=false,
		_call=false@OrFalse(let.MetaFnField),
		_metatable=false,
		_tostring=false@OrFalse(let.MetaFnField),
		_pairs=false@OrFalse(let.MetaFnField),
		_ipairs=false@OrFalse(let.MetaFnField),
		_gc=false,
		_name=false,
		_close=false,
	}, MetaEventCom)
	return self
end

function MetaEventCom:getBopFunc(vBopEvent:String)::Ret(OrNil(class.TypeFunction))
	const nField = self._bopDict[vBopEvent]
	return nField and nField.typeFn
end

function MetaEventCom:hasUopLen()::Ret(Boolean)
	return self._uopLen and true
end

function MetaEventCom:getPairsFunc()::Ret(OrFalse(class.TypeFunction))
	const nField = self._pairs
	return nField and nField.typeFn
end

const function buildFieldFromFn(vContext:class.Context, vEvent:String, vMethodFn:class.UAtomUnion,
	vSelfOrTypeFn:OrNil(class.TypeFunction, class.LuaTable))::Ret(OrNil(let.MetaFnField))
	if vMethodFn:isUnion() then
		vContext:error("meta method can't be union type, event:"..vEvent)
		return nil
	elseif TypeFunction.is(vMethodFn) then
		return {
			luaFn=false,
			typeFn=vMethodFn
		}
	elseif LuaFunction.is(vMethodFn) then
		if TypeFunction.is(vSelfOrTypeFn) then
			return {
				luaFn=vMethodFn,
				typeFn=vMethodFn:specialize(vContext, nil, vSelfOrTypeFn)
			}
		elseif vSelfOrTypeFn then
			return {
				luaFn=vMethodFn,
				typeFn=vMethodFn:specialize(vContext, vSelfOrTypeFn, nil)
			}
		else
			return {
				luaFn=vMethodFn,
				typeFn=vMethodFn:specialize(vContext, nil, nil)
			}
		end
	elseif not Nil.is(vMethodFn) then
		vContext:error("meta method type must be function or nil, event:"..vEvent)
	end
	return nil
end

function MetaEventCom:initByLuaTable(vContext:class.Context, vSelf:class.LuaTable, vMetaTable:class.DefaultTableCom)
	if not self._selfType then
		self._selfType = vSelf
	else
		vContext:error("meta event com init more than once")
		return
	end
	const nManager = self._manager
	-- 1. build bop
	for nOper, nEvent in pairs(OPER_ENUM.bopNoEq) do
		const nMethodType = vMetaTable:native_rawget(vContext, nManager:Literal(nEvent))
		self._bopDict[nEvent] = buildFieldFromFn(vContext, nEvent, nMethodType)
	end
	const nEqFn = vMetaTable:native_rawget(vContext, nManager:Literal("__eq"))
	if not Nil.is(nEqFn) then
		vContext:error("TODO meta logic for bop __eq", tostring(nEqFn))
	end
	-- 2. build uop
	const nLenFn = vMetaTable:native_rawget(vContext, nManager:Literal("__len"))
	const nLenTypeFn = nManager:checkedFn(vSelf):Ret(nManager.type.Integer)
	self._uopLen = buildFieldFromFn(vContext, "__len", nLenFn, nLenTypeFn) or false
	-- 3. build other
	-- 1) __tostring
	const nStringTypeFn = nManager:checkedFn(vSelf):Ret(nManager.type.String)
	const nStringFn = vMetaTable:native_rawget(vContext, nManager:Literal("__tostring"))
	self._tostring = buildFieldFromFn(vContext, "__tostring", nStringFn, nStringTypeFn) or false
	-- 2) __pairs
	const nPairsFn = vMetaTable:native_rawget(vContext, nManager:Literal("__pairs"))
	self._pairs = buildFieldFromFn(vContext, "__pairs", nPairsFn, vSelf) or false
end

const function buildFieldFromAllType(vEvent:String, vTypeFn:OrNil(class.IAtomType))::Ret(OrNil(let.MetaFnField))
	if not vTypeFn then
		return nil
	end
	if Reference.is(vTypeFn) then
		vTypeFn = vTypeFn:getTypeAwait()
	end
	if not TypeFunction.is(vTypeFn) then
		error("meta field "..vEvent.." must be single type-function")
	else
		return {
			luaFn=false,
			typeFn=vTypeFn
		}
	end
end

function MetaEventCom:initByEventDict(vObject:class.MetaObject, vActionDict:Dict(String, class.IAtomType))
	if not self._selfType then
		self._selfType = vObject
	else
		error("meta event com init more than once")
		return
	end
	const nManager = self._manager
	-- 1. build bop
	for nOper, nEvent in pairs(OPER_ENUM.bopNoEq) do
		self._bopDict[nEvent] = buildFieldFromAllType(nEvent, vActionDict[nEvent])
	end
	if vActionDict["__eq"] then
		print("__eq in action table TODO")
	end
	-- 2. build uop
	const nLenType = vActionDict["_len"]
	if nLenType then
		if not nManager.type.Integer:containAll(nLenType) then
			error("len type must be subtype of Integer")
		end
		self._uopLen = buildFieldFromAllType("__len", nManager:checkedFn(vObject):Ret(nLenType)) or false
	end
	-- 3.
	self._pairs = buildFieldFromAllType("__pairs", vActionDict["__pairs"]) or false
	self._ipairs = buildFieldFromAllType("__ipairs", vActionDict["__ipairs"]) or false
end

function MetaEventCom:initByMerge(vLeft:class.MetaEventCom, vRight:class.MetaEventCom)
end

return MetaEventCom
