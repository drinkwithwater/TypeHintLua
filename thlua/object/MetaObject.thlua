
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const MemberFunction = require "thlua.func.MemberFunction"
const StringLiteral = require "thlua.type.StringLiteral"
const Exception = require "thlua.Exception"
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const OPER_ENUM = require "thlua.type.OPER_ENUM"

const MetaObject = AtomTypeClass()

(@do
	let.class = import("thlua.type.TypeClass").class
	let.UMemberField = Union(class.UAllType, class.MemberFunction)
end)

function MetaObject.new(vManager:class.TypeManager, vBasicKey:class.UAtomUnion, vMoreKey:OrFalse(class.Reference))
	::RetClass(class.MetaObject, class.IAtomType)
	const self = setmetatable({::Self()
		_manager=vManager,
		_basicKey=vBasicKey,
		_moreKey=vMoreKey,
		_memberDict=false@class.MemberDict,
		_nextValue=false@Union(False, class.UAtomUnion),
		_nextDict=false@Union(False, Dict(class.IAtomType, class.UAtomUnion)),
		_intersectSet={}@Dict(class.MetaObject, True),
		_metaEventDict={}@Dict(String, class.IAtomType),
		bits=TYPE_BITS.OBJECT,
		id=vManager:genTypeId(),
		_unionSign=false,
		_containCache={} @ Dict(class.MetaObject, Boolean),
		_referName=false@Union(String, False),
	}, MetaObject)
	return self
end

function MetaObject:initIntersectSet(vIntersectSet:Dict(class.MetaObject, True))
	self._intersectSet = vIntersectSet
end

function MetaObject:init(vMemberDict:class.MemberDict, vMetaEventDict:OrNil(Dict(String, class.IAtomType)))
	self._memberDict = vMemberDict
	self._nextDict = {} @ Dict(class.IAtomType, class.UAtomUnion)
	if vMetaEventDict then
		for k,v in pairs(vMetaEventDict) do
			self._metaEventDict[k] = v
		end
	end
end

function MetaObject:intersectAtom(vRightType)
	if self == vRightType then
		return self
	elseif self:containAtom(vRightType) then
		return vRightType
	else
		return false
	end
end

function MetaObject:_everyWith(vRightObject:class.MetaObject, vFunc:Fn(class.IAtomType, class.UAllType, Boolean):Ret(Boolean))::Ret(Boolean)
	for nLeftKey, nLeftValue in pairs(self._memberDict) do
		if not nLeftValue:mayRecursive() and not vFunc(nLeftKey, nLeftValue, false) then
			return false
		end
	end
	for nLeftKey, nLeftValue in pairs(self._memberDict) do
		if nLeftValue:mayRecursive() then
			local nLeftIsMfn = false
			if MemberFunction.is(nLeftValue) then
				nLeftValue = nLeftValue:indexTypeFn(vRightObject)
				nLeftIsMfn = true
			end
			if not vFunc(nLeftKey, nLeftValue, nLeftIsMfn) then
				return false
			end
		end
	end
	return true
end

function MetaObject:_structSameWithAssume(vAssumeSet:Dict(Integer, Boolean), vRightObject:class.MetaObject)::Ret(Boolean)
	const nRightValueDict = vRightObject:copyValueDict()
	const nRightBasic, nRightMoreRefer = vRightObject:getKeyTypes()
	assert(nRightMoreRefer, "only struct & struct can call this function")
	if not self._basicKey:containAll(nRightBasic) or not nRightBasic:containAll(self._basicKey) then
		return false
	end
	const function isMatchedKeyValue(
		vLeftKey:class.IAtomType, vLeftValue:class.UAllType,
		vRightKey:class.IAtomType, vRightValue:class.UAllType)::Ret(Boolean)
		if not vRightValue:assumeContainAll(vAssumeSet, vLeftValue) then
			return false
		end
		if not vLeftValue:assumeContainAll(vAssumeSet, vRightValue) then
			return false
		end
		if not vLeftKey:assumeContainAtom(vAssumeSet, vRightKey) then
			return false
		end
		return true
	end
	if not self:_everyWith(vRightObject, function(nLeftKey, nLeftValue, _)
		const nRightBasicKey = nRightBasic:containAtom(nLeftKey)
		if nRightBasicKey then --  key is basic type
			const nRightValue = nRightValueDict[nRightBasicKey]
			if not nRightValue then
				return false
			end
			if not isMatchedKeyValue(nLeftKey, nLeftValue, nRightBasicKey, nRightValue) then
				return false
			end
			nRightValueDict[nRightBasicKey] = nil
		else -- key is non-basic type
			const nMoreType = nRightMoreRefer:getResultType()
			if nMoreType then -- key is merged, just get one matched
				const nRightMoreKey = nMoreType:assumeContainAtom(vAssumeSet, nLeftKey)
				if not nRightMoreKey then
					return false
				end
				const nRightValue = nRightValueDict[nRightMoreKey]
				if not nRightValue then
					return false
				end
				if not isMatchedKeyValue(nLeftKey, nLeftValue, nRightMoreKey, nRightValue) then
					return false
				end
				nRightValueDict[nRightMoreKey] = nil
			else -- key is not merged, iter for one matched
				local nMatchedKey:OrNil(class.IAtomType) = nil
				for _, nRightMoreKey in ipairs(nRightMoreRefer:getListAwait()) do
					if nRightMoreKey:assumeContainAtom(vAssumeSet, nLeftKey) then
						const nRightValue = nRightValueDict[nRightMoreKey]
						if nRightValue and isMatchedKeyValue(nLeftKey, nLeftValue, nRightMoreKey, nRightValue) then
							nMatchedKey = nRightMoreKey
							break
						end
					end
				end
				if not nMatchedKey then
					return false
				end
				nRightValueDict[nMatchedKey] = nil
			end
		end
		return true
	end) then
		return false
	end
	if next(nRightValueDict) then
		return false
	end
	return true
end

function MetaObject:_interfaceContainWithAssume(vAssumeSet:Dict(Integer, Boolean), vRightObject:class.MetaObject)::Ret(Boolean)
	if vRightObject._intersectSet[self] then
		return true
	end
	const nRightBasicKey, _ = vRightObject:getKeyTypes()
	if not nRightBasicKey:containAll(self._basicKey) then
		return false
	end
	const nRightValueDict = vRightObject:getMemberDict()
	return self:_everyWith(vRightObject, function(vLeftKey, vLeftValue, vLeftIsMfn)
		const nRightKey = nRightBasicKey:containAtom(vLeftKey)
		if not nRightKey then
			return false
		end
		local nRightValue = nRightValueDict[nRightKey]!
		if MemberFunction.is(nRightValue) then
			if not vLeftIsMfn then
				return false
			end
			const nRightTypeFn = nRightValue:indexTypeFn(vRightObject)
			if not vLeftValue:assumeContainAtom(vAssumeSet, nRightTypeFn) then
				return false
			end
		else
			if not vLeftValue:assumeContainAll(vAssumeSet, nRightValue) then
				return false
			end
		end
		return true
	end)
end

function MetaObject:assumeContainObject(vAssumeSet:Dict(Integer, Boolean), vRightObject:class.MetaObject)::Ret(Boolean)
	local nAssumeContain:Boolean = false
	if self:isInterface() then
		return self:_interfaceContainWithAssume(vAssumeSet, vRightObject)
	elseif vRightObject:isInterface() then
		return false
	else
		return self:_structSameWithAssume(vAssumeSet, vRightObject)
	end
end

function MetaObject:assumeContainAtom(vAssumeSet, vRightType)
	local nRightStruct = vRightType:checkBaseObjectType()
	if not nRightStruct then
		return false
	end
	if self == vRightType then
		return self
	end
	const nMgr = self._manager
	if not vAssumeSet then
		const nPair, nContainRefer = nMgr:attachObjPairContain(self, nRightStruct)
		local nResultType = nContainRefer:getTypeAwait()
		return nResultType == nMgr.type.True and self
	end
	const nPair, nContainRefer = nMgr:getTypePairContain(self, nRightStruct)
	const nResultType = nContainRefer and nContainRefer:getResultType()
	if nResultType then
		return nResultType == nMgr.type.True and self
	end
	const nAssumeResult = vAssumeSet[nPair]
	if nAssumeResult ~= nil then
		return nAssumeResult and self
	end
	vAssumeSet[nPair] = true
	local nAssumeContain = self:assumeContainObject(vAssumeSet, nRightStruct)
	if not nAssumeContain then
		vAssumeSet[nPair] = false
		return false
	else
		return self
	end
end

function MetaObject:meta_len(vContext)
	return self._manager.type.Number
end

function MetaObject:meta_uop_some(vContext, vOper)
	vContext:error("other oper invalid:"..tostring(vOper))
	return self._manager.type.Never
end

function MetaObject:meta_pairs(vContext)
	local nManager = self._manager
	return nManager.builtin.next, self, nManager.type.Nil
end

function MetaObject:meta_ipairs(vContext)
	local nManager = self._manager
	return nManager.builtin.inext, self, nManager:Literal(0)
end

function MetaObject:native_next(vContext, vInitType)
	local nNextDict = self._nextDict
	if not nNextDict then
		vContext:error("struct can't put by next")
		return self._manager.type.Never, {}
	end
	local nValueType = self._nextValue
	local nNil = self._manager.type.Nil
	if not nValueType then
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneValue in pairs(self._memberDict) do
			if MemberFunction.is(nOneValue) then
				vContext:error("struct.native_next with member function TODO")
			else
				nOneValue = nOneValue:checkAtomUnion():notnilType()
				nNextDict[nOneKey] = nOneValue
				nCollection:put(nOneValue)
			end
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		self._nextValue = nValueType
		nNextDict[nNil] = nNil
	end
	return nValueType, nNextDict
end

function MetaObject:isSingleton()
	return false
end

function MetaObject:_keyContainAtom(vType:class.IAtomType)::Ret(OrFalse(class.IAtomType))
	const nMoreKey = self._moreKey
	return self._basicKey:containAtom(vType) or (nMoreKey and nMoreKey:containAtom(vType))
end

function MetaObject:meta_get(vContext, vType)
	return self:_meta_get(vContext, vType, false)
end

function MetaObject:meta_get_invoke(vContext, vType)
	return self:_meta_get(vContext, vType, true)
end

function MetaObject:_meta_get(vContext:class.Context, vType:class.IAtomType, vIsInvoke:Boolean)::Ret(class.UAtomUnion)
	const nKey = self:_keyContainAtom(vType)
	if not nKey then
		vContext:error("error get("..tostring(vType)..") in struct")
		return self._manager.type.Nil
	else
		local nGetValue = self._memberDict[nKey]
		if nGetValue then
			if MemberFunction.is(nGetValue) then
				if not vIsInvoke then
					vContext:warn("index a member function but using as invoke")
				end
				return nGetValue:indexTypeFn(self)
			else
				return nGetValue:checkAtomUnion()
			end
		end
	end
end

function MetaObject:meta_set(vContext, vKeyType, vValueType)
	if self:isInterface() then
		vContext:error("interface's field is readonly")
		return
	end
	const nKey = self:_keyContainAtom(vKeyType)
	if nKey then
		local nSetValue = self._memberDict[nKey]
		if nSetValue then
			if MemberFunction.is(nSetValue) then
				vContext:error("error:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field is member function")
				return
			end
			local nSetType = nSetValue:checkAtomUnion()
			if vContext:castLuaType(vValueType, nSetType) then
				return
			elseif nSetType:containAll(vValueType) then
				return
			else
				vContext:error("error1:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not match")
			end
		end
	end
	vContext:error("error2:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not exist")
end

function MetaObject:meta_bop_func(vContext, vOper)
	local nMethodEvent = OPER_ENUM.all[vOper]!
	local nType = self._metaEventDict[nMethodEvent]
	if nType then
		return true, nType
	else
		return false, nil
	end
end

function MetaObject:indexKeyValue(vKeyType:class.IAtomType)::Ret(False):Ret(class.IAtomType, class.UAllType)
	const nKey = self:_keyContainAtom(vKeyType)
	if nKey then
		local nValue = self._memberDict[nKey]!
		if not MemberFunction.is(nValue) then
			return nKey, nValue
		else
			return false
		end
	else
		return false
	end
end

function MetaObject:addNamedReference(vRefer, vName)
	if not self._referName then
		self._referName = vName
	end
end

function MetaObject:detailString(vToStringCache, vVerbose)
	local nReferName = self._referName
	if nReferName then
		return nReferName
	end
	local nCache = vToStringCache[self]
	if nCache then
		return nCache
	end
	vToStringCache[self] = "Struct {...}"
	local l:List(String) = {}
	for k,v in pairs(self._memberDict) do
		local nKeyString:String = ""
		if StringLiteral.is(k) and not vVerbose then
			nKeyString = k:getLiteral()
		else
			nKeyString = "["..k:detailString(vToStringCache, vVerbose).."]"
		end
		l[#l+1] = nKeyString.."="..v:detailString(vToStringCache, vVerbose)
	end
	local nResult = "Interface {"..table.concat(l, ",").."}"
	vToStringCache[self] = nResult
	return nResult
end

function MetaObject:getMemberDict()::Ret(class.MemberDict)
	return self._memberDict
end

function MetaObject:canIntersect(vRightObject:class.MetaObject)::Ret(Boolean)
	if self:isInterface() and vRightObject:isInterface() then
		const nRightValueDict = vRightObject:getMemberDict()
		const nRightBasic, nRightMoreRefer = vRightObject:getKeyTypes()
		self:_everyWith(vRightObject, function(vLeftKey, vLeftValue, vLeftIsMfn)
			const nRightKey = nRightBasic:containAtom(vLeftKey)
			if not nRightKey then
				return true
			end
			local nRightValue = nRightValueDict[nRightKey]!
			if MemberFunction.is(nRightValue) then
				nRightValue = nRightValue:indexTypeFn(vRightObject)
			end
			const nInter = vLeftValue:intersect(nRightValue)
			if nInter:isNever() then
				return false
			else
				return true
			end
		end)
		return true
	else
		return false
	end
end

function MetaObject:copyValueDict(vSelfObject:OrNil(class.LuaTable, class.MetaObject))::Ret(Dict(class.IAtomType, class.UAllType))
	const nValueDict:Dict(class.IAtomType, class.UAllType) = {}
	for k,v in pairs(self._memberDict) do
		if not MemberFunction.is(v) then
			nValueDict[k] = v
		else
			assert(vSelfObject, "member function copy require SelfObject")
			nValueDict[k] = v:indexTypeFn(vSelfObject)
		end
	end
	return nValueDict
end

function MetaObject:getMetaEventDict()::Ret(Dict(String, class.IAtomType))
	return self._metaEventDict
end

function MetaObject:getKeyTypes()::Ret(class.UAtomUnion, OrFalse(class.Reference))
	return self._basicKey, self._moreKey
end

function MetaObject:checkBaseObjectType()
	return self
end

function MetaObject:isInterface()::Ret(Boolean)
	return not self._moreKey
end

function MetaObject:native_type()
	return self._manager:Literal("table")
end

function MetaObject:objectPartType()
	return self
end

function MetaObject:mayRecursive()
	return true
end

function MetaObject:getCompletion()::Ret(class.LspCompletion)
	local nDict:Dict(String, True) = {}
	self._basicKey:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function MetaObject.is(v)::isguard(class.MetaObject)
	return getmetatable(v) == MetaObject
end

return MetaObject
