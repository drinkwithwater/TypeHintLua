
local AtomTypeClass = require "thlua.type.AtomTypeClass"
local StringLiteral = require "thlua.type.StringLiteral"
local Exception = require "thlua.Exception"
local TYPE_BITS = require "thlua.type.TYPE_BITS"

local MetaObject = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function MetaObject.new(vManager:class.TypeManager, vKeyRefer:class.Reference)
	::RetClass(class.MetaObject, class.IAtomType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_keyRefer=vKeyRefer,
		_valueDict=false@class.ValueDict,
		_nextValue=false,
		_nextDict=false@Union(False, class.ValueDict),
		_intersectSet=false,
		bits=TYPE_BITS.OBJECT,
		id=vManager:genTypeId(),
		_unionSign=false,
		_containCache={} @ Dict(class.MetaObject, Boolean),
	}, MetaObject)
	return self
end

function MetaObject:init(vValueDict:class.ValueDict, vNext:Boolean, vIntersectSet)
	self._valueDict = vValueDict
	self._nextDict = {}
	self._intersectSet = vIntersectSet or {}
end

function MetaObject:_intersectOneNotRefer(vRightType)
	if self == vRightType then
		return self
	elseif self:_containOneNotRefer(vRightType) then
		return vRightType
	else
		return false
	end
end

-- experiment code
function MetaObject:containWithAssumption(vAssumptionPairSet:Dict(Integer, True), vRightObject:class.MetaObject)
	if self == vRightObject then
		return true
	else
		local nPair, nResult = self._manager:getObjPairContain(self, vRightObject)
		if nResult ~= nil then
			return nResult
		end
		if vAssumptionPairSet[nPair] then
			return true
		end
		vAssumptionPairSet[nPair] = true
		local nNotContain = false
		self:foreachGetPair(function(vLeftKey, vLeftValue)
			if nNotContain then
				return
			end
			local nRightKey = vRightObject:getKeyRefer():containAllType(vLeftKey)
			if not nRightKey then
				nNotContain = true
				return
			end
			local nRightValue = vRightObject:getValueDict()[nRightKey]!
			vLeftValue=vLeftValue:checkAtomUnion()
			local nSubResult = vLeftValue:containWithAssumption(vAssumptionPairSet, nRightValue:checkAtomUnion())
			if not nSubResult then
				nNotContain = true
				return
			end
		end)
		if nNotContain then
			self._manager:setObjPairContain(nPair, false)
			vAssumptionPairSet[nPair] = nil
			return false
		end
		return true
	end
end

function MetaObject:_containOneNotRefer(vRightType)
	local nRightStruct = vRightType:checkStruct()
	if not nRightStruct then
		return false
	end
	if nRightStruct._intersectSet[self] then
		return self
	end
	local nContainCache = self._containCache
	local nCacheResult = nContainCache[nRightStruct]
	if nCacheResult == true then
		return self
	elseif nCacheResult == false then
		return false
	end
	nContainCache[nRightStruct] = true
	if MetaObject.is(nRightStruct) then
		if self == nRightStruct then
			nContainCache[nRightStruct] = true
			return self
		else
			nContainCache[nRightStruct] = true
			if not nRightStruct:getKeyType():containAllType(self:getKeyType()) then
				nContainCache[nRightStruct] = false
				return false
			end
			if not self:getKeyType():containAllType(nRightStruct:getKeyType()) then
				nContainCache[nRightStruct] = false
				return false
			end
			-- check for not late type
			local nLatePairList:List(Struct {class.UAllType, class.UAllType}) = {}
			for nKey, nValue in pairs(self._valueDict) do
				local nValueType = nValue:getType()
				local nRightValue = nRightStruct._valueDict[nKey]!
				if nValueType and nRightValue and nRightValue:getType() then
					local nRightValueType = nRightValue:getType()
					if not nValueType:containAllType(nRightValueType) then
						nContainCache[nRightStruct] = false
						return false
					end
				end
			end
			nContainCache[nRightStruct] = true
			return self
		end
	else
		nContainCache[nRightStruct] = false
		return false
	end
end

function MetaObject:meta_len(vContext)
	return self._manager.type.Number
end

function MetaObject:meta_uop_some(vContext, vOper)
	vContext:error("other oper invalid:"..tostring(vOper))
	return self._manager.type.Never
end

function MetaObject:meta_pairs(vContext)
	local nManager = self._manager
	return nManager.builtin.next, self, nManager.type.Nil
end

function MetaObject:meta_ipairs(vContext)
	local nManager = self._manager
	return nManager.builtin.inext, self, nManager:Literal(0)
end

function MetaObject:native_next(vContext, vInitType)
	local nNextDict = self._nextDict
	if not nNextDict then
		vContext:error("struct can't put by next")
		return self._manager.type.Never, {}
	end
	local nValueType = self._nextValue
	local nNil = self._manager.type.Nil
	if not nValueType then
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneValue in pairs(self._valueDict) do
			nOneValue = nOneValue:checkAtomUnion():notnilType()
			nNextDict[nOneKey] = nOneValue
			nCollection:put(nOneValue)
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		self._nextValue = nValueType
		nNextDict[nNil] = nNil
	end
	return nValueType, nNextDict
end

function MetaObject:isSingleton(v)
	return false
end

function MetaObject:meta_get(vContext, vType)
	local nKey = self._keyRefer:_containOneNotRefer(vType)
	if nKey then
		local nGetValue = self._valueDict[nKey]
		if nGetValue then
			return nGetValue:checkAtomUnion()
		end
	else
		vContext:error("error get("..tostring(vType)..") in struct")
		return self._manager.type.Nil
	end
end

function MetaObject:meta_set(vContext, vKeyType, vValueType)
	local nKey = self._keyRefer:_containOneNotRefer(vKeyType)
	if nKey then
		local nSetValue = self._valueDict[nKey]
		if nSetValue then
			local nSetType = nSetValue:checkAtomUnion()
			if vContext:cast(vValueType, nSetType) then
				return
			elseif nSetType:containAllType(vValueType) then
				return
			else
				vContext:error("error1:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not match")
			end
		end
	end
	vContext:error("error2:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not exist")
end

function MetaObject:foreachGetPair(vFunc:Fn(class.IAtomType, class.UAllType))
	self._keyRefer:foreach(function(vKeyType)
		local nGetValue = self._valueDict[vKeyType]
		if nGetValue then
			vFunc(vKeyType, nGetValue:checkAtomUnion())
		end
	end)
end

function MetaObject:foreachSetPair(vFunc:Fn(class.IAtomType, class.UAllType))
	self._keyRefer:foreach(function(vKeyType)
		local nSetValue = self._valueDict[vKeyType]
		if nSetValue then
			vFunc(vKeyType, nSetValue:checkAtomUnion())
		end
	end)
end

function MetaObject:detailString(vToStringCache, vVerbose)
	if self._referName then
		return self._referName
	end
	self._keyRefer:checkAtomUnion()
	local nCache = vToStringCache[self]
	if nCache == true then
		return "Struct {~}"
	elseif nCache then
		return nCache
	end
	vToStringCache[self] = true
	local l:List(String) = {}
	for k,v in pairs(self._valueDict) do
		local nKeyString
		if StringLiteral.is(k) and not vVerbose then
			nKeyString = k:getLiteral()
		else
			nKeyString = "["..k:detailString(vToStringCache, vVerbose).."]"
		end
		l[#l+1] = nKeyString.."="..v:detailString(vToStringCache, vVerbose)
	end
	local nResult = "Interface {"..table.concat(l, ",").."}"
	vToStringCache[self] = nResult
	return nResult
end

function MetaObject:getKeyType()::Ret(class.UAtomUnion)
	return self._keyRefer:checkAtomUnion()
end

function MetaObject:getValueDict()::Ret(class.ValueDict)
	return self._valueDict
end

function MetaObject:getKeyRefer()::Ret(class.Reference)
	return self._keyRefer
end

function MetaObject:checkStruct()
	return self
end

function MetaObject:getCompletion()::Ret(class.LspCompletion)
	local nDict:Dict(String, True) = {}
	self._keyRefer:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function MetaObject.is(v)::isguard(class.MetaObject)
	return getmetatable(v) == MetaObject
end

return MetaObject
