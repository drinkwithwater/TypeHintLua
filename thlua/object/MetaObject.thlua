
const AtomTypeClass = require "thlua.type.AtomTypeClass"
const MemberFunction = require "thlua.func.MemberFunction"
const StringLiteral = require "thlua.type.StringLiteral"
const Exception = require "thlua.Exception"
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const MetaEventCom = require "thlua.object.MetaEventCom"

const MetaObject = AtomTypeClass()

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

function:class(clazz.MetaObject) MetaObject.new(vManager:clazz.TypeManager, vIsInterface:Boolean, vKeyRefer:clazz.UnionReferCom, vNextKey:OrFalse(clazz.UAllType)):impl(clazz.IAtomType)
	const self = setmetatable({.class
		_manager=vManager,
		_keyRefer=vKeyRefer,
		_memberDict=false@OrFalse(clazz.MemberDict),
		_nextKey=vNextKey,
		_nextValue=false@OrFalse(clazz.UAtomUnion),
		_nextDict={}@Dict(clazz.IAtomType, clazz.UAtomUnion),
		_metaEventCom=false@OrFalse(clazz.MetaEventCom),
		_intersectSet={}@Dict(clazz.MetaObject, True),
		_unionSign=false,
		_referCom=false@OrFalse(clazz.UnionReferCom),
		_isInterface=vIsInterface,
		bits=TYPE_BITS.OBJECT,
		id=vManager:genTypeId(),
	}, MetaObject)
	return self
end

function MetaObject:linkNamedReference(vRefer:clazz.UnionReferCom)
	if not self._referCom then
		self._referCom = vRefer
	end
end

function MetaObject:lateInit(vIntersectSet:Dict(clazz.MetaObject,True), vMemberDict:clazz.MemberDict, vMetaEventCom:OrFalse(clazz.MetaEventCom))
	self._intersectSet = vIntersectSet
	self._metaEventCom = vMetaEventCom
	self._memberDict = vMemberDict
end

function MetaObject:lateCheck()
	const nNextKey = self._nextKey
	const nMemberDict = assert(self._memberDict, "member dict must existed here")
	if nNextKey then
		nNextKey:foreachAwait(function(vKeyAtom)
			const nMember = nMemberDict[vKeyAtom]
			if not nMember then
				error("nextKey is not subtype of object's key, missing field:"..tostring(vKeyAtom))
			elseif MemberFunction.is(nMember) then
				error("nextKey's value can't be member function"..tostring(vKeyAtom))
			end
		end)
	end
end

function MetaObject:_everyWith(vRightObject:clazz.MetaObject, vFunc:Fn(clazz.IAtomType, clazz.UAllType, Boolean):Ret(Boolean)):Ret(Boolean)
	const nMemberDict = self:getMemberDict()
	for nLeftKey, nLeftValue in pairs(nMemberDict) do
		if not nLeftValue:mayRecursive() and not vFunc(nLeftKey, nLeftValue, false) then
			return false
		end
	end
	for nLeftKey, nLeftValue in pairs(nMemberDict) do
		if nLeftValue:mayRecursive() then
			local nLeftIsMfn = false
			if MemberFunction.is(nLeftValue) then
				nLeftValue = nLeftValue:indexTypeFn(vRightObject)
				nLeftIsMfn = true
			end
			if not vFunc(nLeftKey, nLeftValue, nLeftIsMfn) then
				return false
			end
		end
	end
	return true
end

function MetaObject:_structSameWithAssume(vAssumeSet:Dict(Integer, Boolean), vRightObject:clazz.MetaObject):Ret(Boolean)
	const nRightValueDict = vRightObject:copyValueDict()
	const nRightKeyRefer, nRightNextKey = vRightObject:getKeyTypes()
	const nLeftNextKey = self._nextKey
	if nLeftNextKey and nRightNextKey then
		const nLR = nLeftNextKey:assumeIncludeAll(vAssumeSet, nRightNextKey)
		const nRL = nRightNextKey:assumeIncludeAll(vAssumeSet, nLeftNextKey)
		if not (nLR and nRL) then
			return false
		end
	elseif nLeftNextKey or nRightNextKey then
		return false
	end
	const function isMatchedKeyValue(
		vLeftKey:clazz.IAtomType, vLeftValue:clazz.UAllType,
		vRightKey:clazz.IAtomType, vRightValue:clazz.UAllType):Ret(Boolean)
		if not vRightValue:assumeIncludeAll(vAssumeSet, vLeftValue) then
			return false
		end
		if not vLeftValue:assumeIncludeAll(vAssumeSet, vRightValue) then
			return false
		end
		if not vLeftKey:assumeIncludeAtom(vAssumeSet, vRightKey) then
			return false
		end
		return true
	end
	const nRightResultType = nRightKeyRefer:getResultType()
	if not self:_everyWith(vRightObject, function(nLeftKey, nLeftValue, _)
		if nRightResultType then -- key is merged, just get one matched
			const nRightKey = nRightResultType:assumeIncludeAtom(vAssumeSet, nLeftKey)
			if not nRightKey then
				return false
			end
			const nRightValue = nRightValueDict[nRightKey]
			if not nRightValue then
				return false
			end
			if not isMatchedKeyValue(nLeftKey, nLeftValue, nRightKey, nRightValue) then
				return false
			end
			nRightValueDict[nRightKey] = nil
		else -- key is not merged, iter for one matched
			local nMatchedKey:OrNil(clazz.IAtomType) = nil
			for _, nRightKey in ipairs(nRightKeyRefer:getListAwait()) do
				if nRightKey:assumeIncludeAtom(vAssumeSet, nLeftKey) then
					const nRightValue = nRightValueDict[nRightKey]
					if nRightValue and isMatchedKeyValue(nLeftKey, nLeftValue, nRightKey, nRightValue) then
						nMatchedKey = nRightKey
						break
					end
				end
			end
			if not nMatchedKey then
				return false
			end
			nRightValueDict[nMatchedKey] = nil
		end
		return true
	end) then
		return false
	end
	if next(nRightValueDict) then
		return false
	end
	return true
end

function MetaObject:assumeIntersectInterface(vAssumeSet:Dict(Integer, Boolean), vRightObject:clazz.MetaObject):Ret(Boolean)
	assert(self:isInterface(), vRightObject:isInterface(), "here must be interface")
	const nRightValueDict = vRightObject:getMemberDict()
	const nRightKeyRefer, nRightNextKey = vRightObject:getKeyTypes()
	const nRightResultType = nRightKeyRefer:getResultType()
	return self:_everyWith(vRightObject, function(vLeftKey, vLeftValue, vLeftIsMfn)
		if nRightResultType then -- key is merged, just get one matched
			const nRightKey = nRightResultType:assumeIncludeAtom(vAssumeSet, vLeftKey)
			if not nRightKey then
				return true
			end
			local nRightValue = nRightValueDict[nRightKey]!
			if MemberFunction.is(nRightValue) then
				nRightValue = nRightValue:indexTypeFn(vRightObject)
			end
			if vLeftValue:assumeIntersectSome(vAssumeSet, nRightValue) then
				return true
			else
				return false
			end
		else
			for _, nRightKey in ipairs(nRightKeyRefer:getListAwait()) do
				if nRightKey:assumeIncludeAtom(vAssumeSet, vLeftKey) then
					local nRightValue = nRightValueDict[nRightKey]!
					if MemberFunction.is(nRightValue) then
						nRightValue = nRightValue:indexTypeFn(vRightObject)
					end
					if vLeftValue:assumeIntersectSome(vAssumeSet, nRightValue) then
						return true
					end
				end
			end
			return false
		end
	end)
end

function MetaObject:_interfaceIncludeWithAssume(vAssumeSet:Dict(Integer, Boolean), vRightObject:clazz.MetaObject):Ret(Boolean)
	if vRightObject._intersectSet[self] then
		return true
	end
	const nRightKeyRefer, nRightNextKey = vRightObject:getKeyTypes()
	const nLeftNextKey = self._nextKey
	if nLeftNextKey then
		if not nRightNextKey then
			return false
		end
		if not nLeftNextKey:assumeIncludeAll(vAssumeSet, nRightNextKey) then
			return false
		end
	end
	const function isMatchedValue(vLeftValue:clazz.UAllType, vRightValue:clazz.UMemberAllType, vLeftIsMfn:Boolean):Ret(Boolean)
		if MemberFunction.is(vRightValue) then
			if not vLeftIsMfn then
				return false
			end
			const nRightTypeFn = vRightValue:indexTypeFn(vRightObject)
			if not vLeftValue:assumeIncludeAll(vAssumeSet, nRightTypeFn) then
				return false
			end
		else
			if not vLeftValue:assumeIncludeAll(vAssumeSet, vRightValue) then
				return false
			end
		end
		return true
	end
	const nRightValueDict = vRightObject:getMemberDict()
	const nRightResultType = nRightKeyRefer:getResultType()
	return self:_everyWith(vRightObject, function(vLeftKey, vLeftValue, vLeftIsMfn)
		if nRightResultType then -- key is merged, just get one matched
			const nRightKey = nRightResultType:assumeIncludeAtom(vAssumeSet, vLeftKey)
			if not nRightKey then
				return false
			end
			const nRightValue = nRightValueDict[nRightKey]
			if not nRightValue then
				return false
			end
			return isMatchedValue(vLeftValue, nRightValue, vLeftIsMfn)
		else -- key is not merged, iter for one matched
			for _, nRightMoreKey in ipairs(nRightKeyRefer:getListAwait()) do
				if nRightMoreKey:assumeIncludeAtom(vAssumeSet, vLeftKey) then
					const nRightValue = nRightValueDict[nRightMoreKey]
					if nRightValue and isMatchedValue(vLeftValue, nRightValue, vLeftIsMfn) then
						return true
					end
				end
			end
			return false
		end
	end)
end

function MetaObject:assumeIncludeObject(vAssumeSet:Dict(Integer, Boolean), vRightObject:clazz.MetaObject):Ret(Boolean)
	local nAssumeInclude:Boolean = false
	if self:isInterface() then
		return self:_interfaceIncludeWithAssume(vAssumeSet, vRightObject)
	elseif vRightObject:isInterface() then
		return false
	else
		return self:_structSameWithAssume(vAssumeSet, vRightObject)
	end
end

function MetaObject:assumeIncludeAtom(vAssumeSet, vRightType)
	local nRightStruct = vRightType:checkBaseObjectType()
	if not nRightStruct then
		return false
	end
	if self == nRightStruct then
		return self
	end
	const nMgr = self._manager
	const nRelation = nMgr:attachPairInclude(self, nRightStruct, not vAssumeSet)
	if nRelation then
		if nRelation == ">" or nRelation == "=" then
			return self
		else
			return false
		end
	else
		assert(vAssumeSet, "assume set must be existed here")
	end
	const nPair = self._manager:makePair(self, nRightStruct)
	const nAssumeResult = vAssumeSet[nPair]
	if nAssumeResult ~= nil then
		return nAssumeResult and self
	end
	vAssumeSet[nPair] = true
	local nAssumeInclude = self:assumeIncludeObject(vAssumeSet, nRightStruct)
	if not nAssumeInclude then
		vAssumeSet[nPair] = false
		return false
	else
		return self
	end
end

function MetaObject:assumeIntersectAtom(vAssumeSet, vRightType)
	if (not (MetaObject.is(vRightType) and vRightType:isInterface())) or (not self:isInterface()) then
		if self == vRightType then
			return self
		elseif vRightType:assumeIncludeAtom(nil, self) then
			return self
		elseif self:assumeIncludeAtom(nil, vRightType) then
			return vRightType
		else
			return false
		end
	end
	if self == vRightType then
		return self
	end
	const nRightStruct = vRightType
	const nMgr = self._manager
	const nRelation = nMgr:attachPairInclude(self, nRightStruct, not vAssumeSet)
	if nRelation then
		if nRelation == ">" then
			return vRightType
		elseif nRelation == "<" then
			return self
		elseif nRelation == "=" then
			return self
		elseif nRelation == "&" then
			return true
		else
			return false
		end
	end
	assert(vAssumeSet, "assume set must be existed here")
	const _, nLRPair, nRLPair = self._manager:makeDuPair(self, nRightStruct)
	const nAssumeResult = vAssumeSet[nLRPair]
	if nAssumeResult ~= nil then
		return nAssumeResult and self
	end
	vAssumeSet[nLRPair] = true
	vAssumeSet[nRLPair] = true
	local nAssumeIntersect = self:assumeIntersectInterface(vAssumeSet, nRightStruct)
	if not nAssumeIntersect then
		vAssumeSet[nLRPair] = false
		vAssumeSet[nRLPair] = false
		return false
	else
		return true
	end
end

function MetaObject:meta_len(vContext)
	const nCom = self:getMetaEventCom()
	if nCom then
		const nType = nCom:getLenType()
		if nType then
			return nType
		end
	end
	vContext:error(self, "object take # oper, but _len action not setted")
	return self._manager.type.Integer
end

function MetaObject:meta_uop_some(vContext, vOper)
	vContext:error("other oper invalid:"..tostring(vOper))
	return self._manager.type.Never
end

function MetaObject:meta_pairs(vContext)
	return false
end

function MetaObject:meta_ipairs(vContext)
	return false
end

function MetaObject:native_next(vContext, vInitType)
	const nMemberDict = self:getMemberDict()
	const nNextKey = self._nextKey
	const nNil = self._manager.type.Nil
	if not nNextKey then
		vContext:error("this object can not take next")
		return nNil, {[nNil]=nNil}
	end
	local nNextValue = self._nextValue
	local nNextDict = self._nextDict
	if not nNextValue then
		nNextDict = {}
		local nCollection = self._manager:TypeCollection()
		nNextKey:foreachAwait(function(vKeyAtom)
			const nValue = nMemberDict[vKeyAtom]!
			if MemberFunction.is(nValue) then
				vContext:error("next can't take member function as value")
			else
				const nNotnilValue = nValue:checkAtomUnion():notnilType()
				nNextDict[vKeyAtom] = nNotnilValue
				nCollection:put(nNotnilValue)
			end
		end)
		nCollection:put(nNil)
		nNextValue = nCollection:mergeToAtomUnion()
		nNextDict[nNil] = nNil
		self._nextValue = nNextValue
		self._nextDict = nNextDict
	end
	return nNextValue, nNextDict
end

function MetaObject:isSingleton()
	return false
end

function MetaObject:_keyIncludeAtom(vType:clazz.IAtomType):Ret(clazz.IAtomType, clazz.UMemberAllType):Ret(False)
	const nKey = self._keyRefer:getTypeAwait():includeAtom(vType)
	if nKey then
		return nKey, assert(self._memberDict)[nKey]!
	else
		return false
	end
end

function MetaObject:meta_get(vContext, vType)
	return self:_meta_get(vContext, vType, false)
end

function MetaObject:meta_get_invoke(vContext, vType)
	return self:_meta_get(vContext, vType, true)
end

function MetaObject:_meta_get(vContext:clazz.OperContext, vType:clazz.IAtomType, vIsInvoke:Boolean):Ret(clazz.UAtomUnion)
	const nKey, nGetValue = self:_keyIncludeAtom(vType)
	if not nKey then
		vContext:error("error get("..tostring(vType)..") in struct")
		return self._manager.type.Nil
	else
		if MemberFunction.is(nGetValue) then
			if not vIsInvoke then
				vContext:warn("index a member function but using as invoke")
			end
			return nGetValue:indexTypeFn(self)
		else
			return nGetValue:checkAtomUnion()
		end
	end
end

function MetaObject:native_rawset(vContext, vKeyType, vValueType)
	vContext:warn("abstract object take rawset")
	return self:meta_set(vContext, vKeyType, vValueType)
end

function MetaObject:native_rawget(vContext, vKeyType)
	vContext:warn("abstract object take rawget")
	return self:meta_get(vContext, vKeyType)
end

function MetaObject:meta_set(vContext, vKeyType, vValueType)
	if self:isInterface() then
		vContext:error("interface's field is readonly")
		return
	end
	const nKey, nSetValue = self:_keyIncludeAtom(vKeyType)
	if nKey then
		if MemberFunction.is(nSetValue) then
			vContext:error("error:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field is member function")
			return
		end
		local nSetType = nSetValue:checkAtomUnion()
		if vContext:castLuaType(vValueType, nSetType) then
			return
		elseif nSetType:includeAll(vValueType) then
			return
		else
			vContext:error("error1:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not match")
		end
	end
	vContext:error("error2:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not exist")
end

function MetaObject:meta_bop_func(vContext, vOper)
	local nMethodEvent = OPER_ENUM.bopNoEq[vOper]!
	const nCom = self:getMetaEventCom()
	if nCom then
		const nFn = nCom:getBopFunc(nMethodEvent)
		if nFn then
			return true, nFn
		end
	end
	return false, nil
end

function MetaObject:indexKeyValue(vKeyType:clazz.IAtomType):Ret(False):Ret(clazz.IAtomType, clazz.UAllType)
	const nKey, nValue = self:_keyIncludeAtom(vKeyType)
	if nKey then
		if MemberFunction.is(nValue) then
			return false
		else
			return nKey, nValue
		end
	else
		return false
	end
end

function MetaObject:detailString(vToStringCache, vVerbose)
	local nRefer = self._referCom
	if nRefer then
		return "Object ("..nRefer:getToString()..")"
	end
	local nCache = vToStringCache[self]
	if nCache then
		return nCache
	end
	const nMemberDict = self._memberDict
	if not nMemberDict then
		return "Object (constructing...)"
	end
	vToStringCache[self] = "Object {...}"
	local l:List(String) = {}
	for k,v in pairs(nMemberDict) do
		local nKeyString:String = ""
		if StringLiteral.is(k) and not vVerbose then
			nKeyString = k:getLiteral()
		else
			nKeyString = "["..k:detailString(vToStringCache, vVerbose).."]"
		end
		l[#l+1] = nKeyString.."="..v:detailString(vToStringCache, vVerbose)
	end
	local nResult = "Object {"..table.concat(l, ",").."}"
	vToStringCache[self] = nResult
	return nResult
end

function MetaObject:getMemberDict():Ret(clazz.MemberDict)
	self._keyRefer:getListAwait()
	return (assert(self._memberDict, "member list is not setted after waiting"))
end

function MetaObject:copyValueDict(vSelfObject:OrNil(clazz.LuaTable, clazz.MetaObject)):Ret(Dict(clazz.IAtomType, clazz.UAllType))
	const nValueDict:Dict(clazz.IAtomType, clazz.UAllType) = {}
	for k,v in pairs(self:getMemberDict()) do
		if not MemberFunction.is(v) then
			nValueDict[k] = v
		else
			assert(vSelfObject, "member function copy require SelfObject")
			nValueDict[k] = v:indexTypeFn(vSelfObject)
		end
	end
	return nValueDict
end

function MetaObject:getMetaEventCom():Ret(OrFalse(clazz.MetaEventCom))
	self._keyRefer:getListAwait()
	return self._metaEventCom
end

function MetaObject:getKeyTypes():Ret(clazz.UnionReferCom, OrFalse(clazz.UAllType))
	return self._keyRefer, self._nextKey
end

function MetaObject:checkBaseObjectType()
	return self
end

function MetaObject:isInterface():Ret(Boolean)
	return self._isInterface
end

function MetaObject:native_type()
	return self._manager:Literal("table")
end

function MetaObject:objectPartType()
	return self
end

function MetaObject:mayRecursive()
	return true
end

function MetaObject:getCompletion():Ret(clazz.LspCompletion)
	local nDict:Dict(String, True) = {}
	self._keyRefer:foreachAwait(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function.open MetaObject.is(v):isguard(clazz.MetaObject)
	return getmetatable(v) == MetaObject
end

return MetaObject
