
local AtomTypeClass = require "thlua.type.AtomTypeClass"
local StringLiteral = require "thlua.type.StringLiteral"
local Exception = require "thlua.Exception"
local TYPE_BITS = require "thlua.type.TYPE_BITS"

local MetaObject = AtomTypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function MetaObject.new(
		vManager:class.TypeManager,
		vKeyType:class.UAtomUnion,
		vGetDict:Dict(class.IAtomType, class.UValueType),
		vNextDict:Dict(class.IAtomType, class.UValueType)
	)::RetClass(class.MetaObject, class.IAtomType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_keyRefer=false,
		_valueDict=false,
		_nextValue=false,
		_nextDict=vNextDict,
		bits=TYPE_BITS.OBJECT,
		id=vManager:genTypeId(),
		_unionSign=false,
		_containCache={} @Dict(Truth, Boolean),
	}, MetaObject)
	return self
end

function MetaObject:init(vKeyRefer, vValueDict, vNextDict)
	self._keyRefer = vKeyRefer
	self._valueDict = vValueDict
	self._nextDict = vNextDict
end

function MetaObject:_intersectOneNotRefer(vRightType)
	if self == vRightType then
		return self
	elseif self:_containOneNotRefer(vRightType) then
		return vRightType
	else
		return false
	end
end

function MetaObject:_containOneNotRefer(vRightType)
	local nRightStruct = vRightType:checkStruct()
	if not nRightStruct then
		return false
	end
	local nContainCache = self._containCache
	local nCacheResult = nContainCache[nRightStruct]
	if nCacheResult == true then
		return self
	elseif nCacheResult == false then
		return false
	end
	nContainCache[nRightStruct] = true
	if MetaObject.is(nRightStruct) then
		-- struct contain TODO
		--[[
		-- 1. check all left strict keys contain by right keys
		if not self:checkMustKeyType():every(function(vLeftKey)
			local nLeftValue = self._valueDict[vLeftKey]
			local nRightKey = nRightStruct:checkMustKeyType():contain(vLeftKey)
			if not nRightKey then
				return false
			end
			local nRightValue = nRightStruct._valueDict[nRightKey]
			if not nLeftValue:contain(nRightValue) then
				return false
			end
			return true
		end) then
			nContainCache[nRightStruct] = false
			return false
		end
		-- 2. check all right key-value contain by right key-value
		if not nRightStruct._keyRefer:every(function(vRightKey)
			local nLeftKey = self._keyRefer:contain(vRightKey)
			if not nLeftKey then
				return false
			end
			local nLeftValue = self._valueDict[nLeftKey]
			local nRightValue = nRightStruct._valueDict[vRightKey]
			if not nLeftValue:contain(nRightValue) then
				return false
			end
			return true
		end) then
			nContainCache[nRightStruct] = false
			return false
		end
		]]
		--[[
		-- check as interface
		local nResult = self._keyRefer:every(function(vLeftKey)
			local nLeftValue = self._valueDict[vLeftKey]
			local nRightValue = nRightStruct._valueDict[vLeftKey]
			if not nRightValue then
				return false
			end
			if not nLeftValue:contain(nRightValue) then
				return false
			end
			return true
		end)
		if nResult then
			nContainCache[nRightStruct] = true
			return self
		else
			nContainCache[nRightStruct] = false
			return false
		end]]
		if self == nRightStruct then
			nContainCache[nRightStruct] = true
			return self
		else
			nContainCache[nRightStruct] = true
			if not nRightStruct:getKeyType():contain(self:getKeyType()) then
				nContainCache[nRightStruct] = false
				return false
			end
			if not self:getKeyType():contain(nRightStruct:getKeyType()) then
				nContainCache[nRightStruct] = false
				return false
			end
			-- check for not late type
			local nLatePairList:List(Struct {class.UValueType, class.UValueType}) = {}
			for nKey, nValue in pairs(self._valueDict) do
				local nValueType = nValue:getType()
				local nRightValue = nRightStruct._valueDict[nKey]!
				local nRightValueType = nRightValue:getType()
				if nValueType and nRightValueType then
					if not nValueType:contain(nRightValueType) then
						nContainCache[nRightStruct] = false
						return false
					end
				else
					nLatePairList[#nLatePairList + 1] = {
						nValue, nRightValue
					}
				end
			end
			for _, nPair in pairs(nLatePairList) do
				local nBig, nSmall = nPair[1], nPair[2]
				-- TODO raise error if checkAtomUnion failed
				if not nBig:contain(nSmall) then
					nContainCache[nRightStruct] = false
					return false
				end
			end
			nContainCache[nRightStruct] = true
			return self
		end
	else
		nContainCache[nRightStruct] = false
		return false
	end
end

function MetaObject:meta_len(vContext)
	return self._manager.type.Number
end

function MetaObject:meta_uop_some(vContext, vOper)
	vContext:error("other oper invalid:"..tostring(vOper))
	return self._manager.type.Never
end

function MetaObject:meta_pairs(vContext)
	local nManager = self._manager
	return nManager.builtin.next, self, nManager.type.Nil
end

function MetaObject:meta_ipairs(vContext)
	local nManager = self._manager
	return nManager.builtin.inext, self, nManager:Literal(0)
end

function MetaObject:native_next(vContext, vInitType)
	local nValueDict = self._nextDict
	if not nValueDict then
		vContext:error("struct can't put by next")
		return self._manager.type.Never, {}
	end
	local nValueType = self._nextValue
	local nNil = self._manager.type.Nil
	if not nValueType then
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneValue in pairs(nValueDict) do
			nOneValue = nOneValue:checkAtomUnion():notnilType()
			nValueDict[nOneKey] = nOneValue
			nCollection:put(nOneValue)
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		self._nextValue = nValueType
		self._nextDict[nNil] = nNil
	end
	return nValueType, nValueDict
end

function MetaObject:isSingleton(v)
	return false
end

function MetaObject:meta_get(vContext, vType)
	local nKey = self._keyRefer:_containOneNotRefer(vType)
	if nKey then
		local nGetValue = self._valueDict[nKey]
		if nGetValue then
			return nGetValue:checkAtomUnion()
		end
	else
		vContext:error("error get("..tostring(vType)..") in struct")
		return self._manager.type.Nil
	end
end

function MetaObject:meta_set(vContext, vKeyType, vValueType)
	local nKey = self._keyRefer:_containOneNotRefer(vKeyType)
	if nKey then
		local nSetValue = self._valueDict[nKey]
		if nSetValue then
			local nSetType = nSetValue:checkAtomUnion()
			if vContext:cast(vValueType, nSetType) then
				return
			elseif nSetType:contain(vValueType) then
				return
			else
				vContext:error("error:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not match")
			end
		end
	end
	vContext:error("error:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not exist")
end

function MetaObject:foreachGetPair(vFunc)
	self._keyRefer:foreach(function(vKeyType)
		local nGetValue = self._valueDict[vKeyType]
		if nGetValue then
			vFunc(vKeyType, nGetValue)
		end
	end)
end

function MetaObject:foreachSetPair(vFunc)
	self._keyRefer:foreach(function(vKeyType)
		local nSetValue = self._valueDict[vKeyType]
		if nSetValue then
			vFunc(vKeyType, nSetValue)
		end
	end)
end

function MetaObject:detailString(vToStringCache, vVerbose)
	if self._referName then
		return self._referName
	end
	local nCache = vToStringCache[self]
	if nCache == true then
		return "Struct {~}"
	elseif nCache then
		return nCache
	end
	vToStringCache[self] = true
	local lsetter = {}
	for k,v in pairs(self._valueDict) do
		local nKeyString
		if StringLiteral.is(k) and not vVerbose then
			nKeyString = k:getLiteral()
		else
			nKeyString = "["..k:detailString(vToStringCache, vVerbose).."]"
		end
		lsetter[#lsetter+1] = nKeyString.."="..v:detailString(vToStringCache, vVerbose)
	end
	local lgetter = {}
	for k,v in pairs(self._valueDict) do
		local nKeyString
		if StringLiteral.is(k) and not vVerbose then
			nKeyString = k:getLiteral()
		else
			nKeyString = "["..k:detailString(vToStringCache, vVerbose).."]"
		end
		lgetter[#lgetter+1] = nKeyString.."="..v:detailString(vToStringCache, vVerbose)
	end
	local nResult = "Struct({},{get={"..table.concat(lsetter, ",").."},{set={"..table.concat(lgetter,",").."}}"
	vToStringCache[self] = nResult
	return nResult
end

function MetaObject:getKeyType()
	return self._keyRefer:checkAtomUnion()
end

function MetaObject:checkStruct()
	return self
end

function MetaObject:getCompletion()
	local nDict = {}
	self._keyRefer:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function MetaObject.is(v)::isguard(class.MetaObject)
	return getmetatable(v) == MetaObject
end

return MetaObject
