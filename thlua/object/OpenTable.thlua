
const StringLiteral = require "thlua.type.StringLiteral"
const TypedObject = require "thlua.object.TypedObject"
const BaseFunction = require "thlua.func.BaseFunction"
const MemberFunction = require "thlua.func.MemberFunction"

const BaseObject = require "thlua.object.BaseObject"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.OpenTableField = Struct {
		valueType = clazz.UAtomUnion,
		lockCtx = OrFalse(clazz.OperContext),
	}
end)

const OpenTable = class@<clazz.OpenTable, false>(BaseObject)

function.open OpenTable:ctor(vManager:clazz.TypeManager)
	self._keyType=vManager.type.Never @clazz.UAtomUnion
	self._fieldDict={}@Dict(clazz.IAtomType, OpenTableField)
	self._indexType=false@OrFalse(clazz.IAtomType)
	self._newIndexType=false@OrFalse(clazz.IAtomType)
	self._nextValue=false@Union(False, clazz.UAtomUnion)
	self._nextDict=false@Union(False, Dict(clazz.IAtomType, clazz.UAtomUnion))
	self._metaTable=false@OrFalse(clazz.OpenTable, clazz.SealTable)
	self._name="Table"@String
end

function OpenTable:detailString(v, vVerbose)
	return "OpenTable@"..self._name
end

function OpenTable:meta_len(vContext)
	-- TODO
	return self._manager.type.Number
end

function OpenTable:setName(vName:String)
	self._name = vName
end

function OpenTable:initByKeyValue(vKeyType:clazz.UAtomUnion, vValueDict:Dict(clazz.IAtomType, clazz.UAtomUnion))
	self._keyType = vKeyType
	for k,v in pairs(vValueDict) do
		self._fieldDict[k] = {
			valueType = v,
			lockCtx = false,
		}
	end
end

function OpenTable:lockAsMetaIndex()
	return self:lockAndGet()
end

function OpenTable:lockAsMetaNewIndex()
	return self:lockAndGet()
end

function OpenTable:native_getmetatable(vContext)
	return self._metaTable or self._manager.type.Nil
end

function OpenTable:native_setmetatable(vContext, vMetaTableType)
	if self._metaTable then
		vContext:error("can only setmetatable once for one table")
		return
	end
	self._metaTable = vMetaTableType
	-- TODO, opentable don't allow meta event except index & newindex, check other fields
	--assert(not self._metaEventCom, "meta event has been setted")
	--const nMetaEventCom = self._manager:makeMetaEventCom(self)
	--nMetaEventCom:initByBaseTable(vContext, vMetaTableType)
	--self._metaEventCom = nMetaEventCom
	-- 2. copyout index/newindex event items
	local nManager = self._manager
	const nIndexType = vMetaTableType:native_rawget(vContext, nManager:Literal("__index"))
	const nNewIndexType = vMetaTableType:native_rawget(vContext, nManager:Literal("__newindex"))
	-- 3. set default com
	self:setMetaIndex(
		vContext,
		not nIndexType:isNever() and nIndexType or false,
		not nNewIndexType:isNever() and nNewIndexType or false)
end

function OpenTable:meta_set(vContext, vKeyType, vValueType)
	if not vKeyType:isSingleton() then
		vContext:error("open table's key must be singleton type")
		return
	end
	if vKeyType:isNilable() then
		vContext:error("open table's key can't be nil")
		return
	end
	const nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		if nField.lockCtx then
			vContext:error("field is locked"..tostring(vKeyType))
		else
			nField.valueType = vValueType
		end
	else
		const nNewIndexType = self._newIndexType
		if BaseFunction.is(nNewIndexType) then
			const nTermTuple = vContext:FixedTermTuple({
				vContext:RefineTerm(self), vContext:RefineTerm(vKeyType), vContext:RefineTerm(vValueType)
			})
			nNewIndexType:meta_call(vContext, nTermTuple)
			return
		elseif BaseObject.is(nNewIndexType) then
			nNewIndexType:meta_set(vContext, vKeyType, vValueType)
			return
		end
	end
	self:native_rawset(vContext, vKeyType, vValueType)
end

function OpenTable:meta_get(vContext, vKeyType)
	-- TODO trigger meta index
	const nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		nField.lockCtx = vContext
		vContext:pushFirstAndTuple(nField.valueType)
	else
		const nIndexType = self._indexType
		if BaseFunction.is(nIndexType) then
			const nTermTuple = vContext:FixedTermTuple({vContext:RefineTerm(self), vContext:RefineTerm(vKeyType)})
			nIndexType:meta_call(vContext, nTermTuple)
		elseif BaseObject.is(nIndexType) then
			nIndexType:meta_get(vContext, vKeyType)
		end
		vContext:pushFirstAndTuple(self:native_rawget(vContext, vKeyType))
	end
end

function OpenTable:native_rawset(vContext, vKeyType, vValueType)
	const nIncludeType = self._keyType:includeAtom(vKeyType)
	if not nIncludeType then
		if vKeyType:isSingleton() and not vKeyType:isNilable() then
			-- TODO thinking when to lock this
			self._keyType = self._manager:checkedUnion(self._keyType, vKeyType)
			self._fieldDict[vKeyType] = {
				valueType = vValueType,
				lockCtx = false,
			}
		else
			vContext:error("set("..tostring(vKeyType)..","..tostring(vValueType)..") error")
		end
	else
		self._fieldDict[nIncludeType] = {
			valueType = vValueType,
			lockCtx = false,
		}
	end
end

function OpenTable:native_rawget(vContext, vKeyType):Ret(clazz.UAtomUnion)
	const nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		nField.lockCtx = vContext
		return nField.valueType
	else
		const nNil = self._manager.type.Nil
		self._fieldDict[vKeyType] = {
			valueType=nNil,
			lockCtx=vContext
		}
		return nNil
	end
end

function OpenTable:setMetaIndex(vContext:clazz.OperContext, vIndexType:OrFalse(clazz.UAtomUnion), vNewIndexType:OrFalse(clazz.UAtomUnion))
	if vIndexType then
		if not vIndexType:isUnion() then
			self._indexType = vIndexType
		else
			vContext:error("open table's __index can't be union type")
		end
	end
	if vNewIndexType then
		if not vNewIndexType:isUnion() then
			self._newIndexType = vNewIndexType
		else
			vContext:error("open table's __newindex can't be union type")
		end
	end
end

function OpenTable:native_next(vContext, vInitType)
	local nNextDict = self._nextDict
	local nValueType = self._nextValue
	if not nNextDict or not nValueType then
		nNextDict = {}
		for nKeyAtom, nField in pairs(self._fieldDict) do
			nNextDict[nKeyAtom] = nField.valueType
		end
		local nNil = self._manager.type.Nil
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneField in pairs(self._fieldDict) do
			const nValueType = nOneField.valueType
			const nNotnilType = nValueType:notnilType()
			nNextDict[nOneKey] = nNotnilType
			nCollection:put(nNotnilType)
			nOneField.lockCtx = vContext
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		nNextDict[nNil] = nNil
		self._nextValue = nValueType
		self._nextDict = nNextDict
	end
	return nValueType, nNextDict
end

function OpenTable:meta_pairs(vContext)
	--[[
	const nCom = self._metaEventCom
	if nCom then
		const nPairsFn = nCom:getPairsFunc()
		if nPairsFn then
			vContext:error("TODO:open table use __pairs as meta field")
		end
	end]]
	return false
end

function OpenTable:meta_ipairs(vContext)
	vContext:error("TODO:open table use __ipairs as meta field")
	return false
end

function OpenTable:lockAndGet():Ret(clazz.UAtomUnion, Dict(clazz.IAtomType, clazz.UAtomUnion))
	const nDict:Dict(clazz.IAtomType, clazz.UAtomUnion) = {}
	for k, nField in pairs(self._fieldDict) do
		nDict[k] = nField.valueType
	end
	return self._keyType, nDict
end

function OpenTable:checkBaseObjectType()
	return self._manager.type.AnyObject
end

function OpenTable:getCompletion():Ret(clazz.LspCompletion)
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function OpenTable:isSingleton()
	return true
end

return OpenTable
