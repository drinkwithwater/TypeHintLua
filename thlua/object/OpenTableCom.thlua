
const StringLiteral = require "thlua.type.StringLiteral"
const MetaObject = require "thlua.object.MetaObject"
const TypeFunction = require "thlua.func.TypeFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const LuaFunction = require "thlua.func.LuaFunction"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.OpenTableField = Struct {
		valueType = clazz.UAtomUnion,
		lockCtx = OrFalse(clazz.Context),
	}
end)

const OpenTableCom = {}
OpenTableCom.__index = OpenTableCom

function:class(clazz.OpenTableCom) OpenTableCom.new(vManager:clazz.TypeManager,
	vLuaTable:clazz.LuaTable):impl(clazz.IMetaNative)
	const self = setmetatable({.class
		_manager=vManager,
		_keyType=vManager.type.Never @clazz.UAtomUnion,
		_fieldDict={}@Dict(clazz.IAtomType, let.OpenTableField),
		_luaTable=vLuaTable,
	}, OpenTableCom)
	return self
end

function OpenTableCom:initByKeyValue(vKeyType:clazz.UAtomUnion, vValueDict:Dict(clazz.IAtomType, clazz.UAtomUnion)):Ret()
	self._keyType = vKeyType
	for k,v in pairs(vValueDict) do
		self._fieldDict[k] = {
			valueType = v,
			lockCtx = false,
		}
	end
end

function OpenTableCom:foreachGetPair(vFunc:Fn(clazz.IAtomType, clazz.UAtomUnion))
	self._keyType:foreach(function(vType)
		vFunc(vType, self._fieldDict[vType]!.valueType)
	end)
end

function OpenTableCom:meta_set(vContext:clazz.Context, vKeyType:clazz.IAtomType, vValueType:clazz.UAtomUnion)
	if not vKeyType:isSingleton() then
		vContext:error("open table's key must be singleton type")
		return
	end
	if vKeyType:isNilable() then
		vContext:error("open table's key can't be nil")
		return
	end
	const nKeyIncludeType = self._keyType:containAtom(vKeyType)
	if nKeyIncludeType then
		self._fieldDict[nKeyIncludeType] = {
			valueType = vValueType,
			lockCtx = false
		}
	end
	self:native_rawset(vContext, vKeyType, vValueType)
end

function OpenTableCom:meta_get(vContext, vKeyType)
	-- TODO trigger meta index
	const nKeyIncludeType = self._keyType:containAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		nField.lockCtx = vContext
		return nField.valueType
	else
		vContext:error("index error, key=", tostring(vKeyType))
		return self._manager.type.Nil
	end
end

function OpenTableCom:native_rawset(vContext, vKeyType, vValueType)
	const nIncludeType = self._keyType:containAtom(vKeyType)
	if not nIncludeType then
		if vKeyType:isSingleton() and not vKeyType:isNilable() then
			-- TODO thinking when to lock this
			self._keyType = self._manager:checkedUnion(self._keyType, vKeyType)
			self._fieldDict[vKeyType] = {
				valueType = vValueType,
				lockCtx = false,
			}
		else
			vContext:error("set("..tostring(vKeyType)..","..tostring(vValueType)..") error")
		end
	else
		self._fieldDict[nIncludeType] = {
			valueType = vValueType,
			lockCtx = false,
		}
	end
end

function OpenTableCom:native_rawget(vContext, vKeyType):Ret(clazz.UAtomUnion)
	const nKeyIncludeType = self._keyType:containAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		nField.lockCtx = vContext
		return nField.valueType
	else
		return self._manager.type.Nil
	end
end

function OpenTableCom:setMetaIndex(vContext:clazz.Context, vAsIndex:OrFalse(clazz.MetaIndexField), vAsNewIndex:OrFalse(clazz.MetaIndexField))
	-- TODO
end

function OpenTableCom:native_next(vContext, vInitType)
	-- TODO
end

function OpenTableCom:lockAsMetaIndex():Ret(clazz.MetaIndexField)
	const nDict:Dict(clazz.IAtomType, clazz.UAtomUnion) = {}
	for k, nField in pairs(self._fieldDict) do
		nDict[k] = nField.valueType
	end
	return {
		keyType=self._keyType,
		valueDict=nDict,
		fnType=false,
	}
end

function OpenTableCom:lockAsMetaNewIndex():Ret(clazz.MetaIndexField)
	const nDict:Dict(clazz.IAtomType, clazz.UAtomUnion) = {}
	for k, nField in pairs(self._fieldDict) do
		nDict[k] = nField.valueType
	end
	return {
		keyType=self._keyType,
		valueDict=nDict,
		fnType=false,
	}
end

function OpenTableCom:basingByDefault()
end

function OpenTableCom:castStruct(vContext:clazz.Context, vObjectAtomUnion:clazz.UObjectAtomUnion):Ret(OrFalse(clazz.MetaObject))
	return false
end

function OpenTableCom:getCompletion():Ret(clazz.LspCompletion)
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

return OpenTableCom
