
const StringLiteral = require "thlua.type.StringLiteral"
const MetaObject = require "thlua.object.MetaObject"
const TypeFunction = require "thlua.func.TypeFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const LuaFunction = require "thlua.func.LuaFunction"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.OpenTableField = Struct {
		valueType = clazz.UAtomUnion,
		lockCtx = OrFalse(clazz.BaseContext),
	}
end)

const OpenTableCom = {}
OpenTableCom.__index = OpenTableCom

function:class(clazz.OpenTableCom) OpenTableCom.new(vManager:clazz.TypeManager,
	vLuaTable:clazz.LuaTable):impl(clazz.IMetaNative)
	const self = setmetatable({.class
		_manager=vManager,
		_keyType=vManager.type.Never @clazz.UAtomUnion,
		_fieldDict={}@Dict(clazz.IAtomType, OpenTableField),
		_indexType=false@OrFalse(clazz.IAtomType),
		_newIndexType=false@OrFalse(clazz.IAtomType),
		_nextValue=false@Union(False, clazz.UAtomUnion),
		_nextDict=false@Union(False, Dict(clazz.IAtomType, clazz.UAtomUnion)),
		_luaTable=vLuaTable,
	}, OpenTableCom)
	return self
end

function OpenTableCom:initByKeyValue(vKeyType:clazz.UAtomUnion, vValueDict:Dict(clazz.IAtomType, clazz.UAtomUnion)):Ret()
	self._keyType = vKeyType
	for k,v in pairs(vValueDict) do
		self._fieldDict[k] = {
			valueType = v,
			lockCtx = false,
		}
	end
end

function OpenTableCom:foreachGetPair(vFunc:Fn(clazz.IAtomType, clazz.UAtomUnion))
	self._keyType:foreach(function(vType)
		vFunc(vType, self._fieldDict[vType]!.valueType)
	end)
end

function OpenTableCom:meta_set(vContext, vKeyType, vValueType)
	if not vKeyType:isSingleton() then
		vContext:error("open table's key must be singleton type")
		return
	end
	if vKeyType:isNilable() then
		vContext:error("open table's key can't be nil")
		return
	end
	const nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		if nField.lockCtx then
			vContext:error("field is locked"..tostring(vKeyType))
		else
			nField.valueType = vValueType
		end
	else
		const nNewIndexType = self._newIndexType
		if nNewIndexType then
			nNewIndexType:triggerAsMetaNewIndex(vContext, vContext:RefineTerm(self._luaTable),
				vContext:RefineTerm(vKeyType), vContext:RefineTerm(vValueType))
			return
		end
	end
	self:native_rawset(vContext, vKeyType, vValueType)
end

function OpenTableCom:meta_get(vContext, vKeyType)
	-- TODO trigger meta index
	const nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		nField.lockCtx = vContext
		return nField.valueType
	else
		const nIndexType = self._indexType
		if nIndexType then
			const nType = nIndexType:triggerAsMetaIndex(vContext, vContext:RefineTerm(self._luaTable), vContext:RefineTerm(vKeyType)):getType()
			return assert(nType):checkAtomUnion()
		end
		return self:native_rawget(vContext, vKeyType)
	end
end

function OpenTableCom:native_rawset(vContext, vKeyType, vValueType)
	const nIncludeType = self._keyType:includeAtom(vKeyType)
	if not nIncludeType then
		if vKeyType:isSingleton() and not vKeyType:isNilable() then
			-- TODO thinking when to lock this
			self._keyType = self._manager:checkedUnion(self._keyType, vKeyType)
			self._fieldDict[vKeyType] = {
				valueType = vValueType,
				lockCtx = false,
			}
		else
			vContext:error("set("..tostring(vKeyType)..","..tostring(vValueType)..") error")
		end
	else
		self._fieldDict[nIncludeType] = {
			valueType = vValueType,
			lockCtx = false,
		}
	end
end

function OpenTableCom:native_rawget(vContext, vKeyType):Ret(clazz.UAtomUnion)
	const nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		nField.lockCtx = vContext
		return nField.valueType
	else
		const nNil = self._manager.type.Nil
		self._fieldDict[vKeyType] = {
			valueType=nNil,
			lockCtx=vContext
		}
		return nNil
	end
end

function OpenTableCom:setMetaIndex(vContext:clazz.OperContext, vIndexType:OrFalse(clazz.UAtomUnion), vNewIndexType:OrFalse(clazz.UAtomUnion))
	if vIndexType then
		if not vIndexType:isUnion() then
			self._indexType = vIndexType
		else
			vContext:error("open table's __index can't be union type")
		end
	end
	if vNewIndexType then
		if not vNewIndexType:isUnion() then
			self._newIndexType = vNewIndexType
		else
			vContext:error("open table's __newindex can't be union type")
		end
	end
end

function OpenTableCom:native_next(vContext, vInitType)
	local nNextDict = self._nextDict
	local nValueType = self._nextValue
	if not nNextDict or not nValueType then
		nNextDict = {}
		for nKeyAtom, nField in pairs(self._fieldDict) do
			nNextDict[nKeyAtom] = nField.valueType
		end
		local nNil = self._manager.type.Nil
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneField in pairs(self._fieldDict) do
			const nValueType = nOneField.valueType
			const nNotnilType = nValueType:notnilType()
			nNextDict[nOneKey] = nNotnilType
			nCollection:put(nNotnilType)
			nOneField.lockCtx = vContext
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		nNextDict[nNil] = nNil
		self._nextValue = nValueType
		self._nextDict = nNextDict
	end
	return nValueType, nNextDict
end

function OpenTableCom:lockAndGet():Ret(clazz.UAtomUnion, Dict(clazz.IAtomType, clazz.UAtomUnion))
	const nDict:Dict(clazz.IAtomType, clazz.UAtomUnion) = {}
	for k, nField in pairs(self._fieldDict) do
		nDict[k] = nField.valueType
	end
	return self._keyType, nDict
end

function OpenTableCom:basingByDefault()
end

function OpenTableCom:castStruct(vContext:clazz.OperContext, vObjectAtomUnion:clazz.UObjectAtomUnion):Ret(OrFalse(clazz.MetaObject))
	return false
end

function OpenTableCom:getCompletion():Ret(clazz.LspCompletion)
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function.open OpenTableCom.is(v):isguard(clazz.OpenTableCom)
	return getmetatable(v) == OpenTableCom
end

return OpenTableCom
