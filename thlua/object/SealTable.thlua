
const StringLiteral = require "thlua.type.StringLiteral"
const TypedObject = require "thlua.object.TypedObject"
const TypedFunction = require "thlua.func.TypedFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const AutoFunction = require "thlua.func.AutoFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"

const BaseObject = require "thlua.object.BaseObject"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.TableField = Struct {
		rawValueType = clazz.UAtomUnion,
		castValueType = OrFalse(clazz.UAtomUnion),
		kind = Union("property", "getter"),
	}
end)

const SealTable = class@<clazz.SealTable, false>(BaseObject)

function.open SealTable:ctor(vManager:clazz.TypeManager, ...)
	self._keyType=vManager.type.Never @clazz.UAtomUnion
	self._fieldDict={}@Dict(clazz.IAtomType, TableField)
	self._nextValue=false@Union(False, clazz.UAtomUnion)
	self._nextDict=false@Union(False, Dict(clazz.IAtomType, clazz.UAtomUnion))
	self._isBasingDefault=false@Boolean
	self._interface=false@OrFalse(clazz.TypedObject)
	self._metaTable=false@OrFalse(clazz.OpenTable, clazz.SealTable)
	self._name="Table"@String
end

function SealTable:setName(vName:String)
	self._name = vName
end

function SealTable:meta_len(vContext)
	-- TODO
	return self._manager.type.Number
end

function SealTable:ctxWait(vContext:clazz.OperContext)
end

function SealTable:initByKeyValue(vKeyType:clazz.UAtomUnion, vValueDict:Dict(clazz.IAtomType, clazz.UAtomUnion)):Ret()
	self._keyType = vKeyType
	for k,v in pairs(vValueDict) do
		self._fieldDict[k] = {
			rawValueType = v,
			castValueType = false,
			kind = "property",
		}
	end
end

function SealTable:onSetMetaTable(vContext:clazz.OperContext)
end

function SealTable:native_setmetatable(vContext, vMetaTableType)
	if self._metaTable then
		vContext:error("can only setmetatable once for one table")
		return
	end
	self._metaTable = vMetaTableType
	-- 1. copyout meta event items
	assert(not self._metaEventCom, "meta event has been setted")
	const nMetaEventCom = self._manager:makeMetaEventCom(self)
	nMetaEventCom:initByTable(vContext, vMetaTableType)
	self._metaEventCom = nMetaEventCom
	-- 2. copyout index/newindex event items
	local nManager = self._manager
	const nIndexType = vMetaTableType:native_rawget(vContext, nManager:Literal("__index"))
	const nNewIndexType = vMetaTableType:native_rawget(vContext, nManager:Literal("__newindex"))
	-- 3. set default com
	self:setMetaIndex(
		vContext,
		not nIndexType:isNever() and nIndexType or false,
		not nNewIndexType:isNever() and nNewIndexType or false)
	-- 4. trigger on set
	self:onSetMetaTable(vContext)
end

function SealTable:meta_set(vContext, vKeyType, vValueType)
	self:ctxWait(vContext)
	vContext:pushNothing()
	if self._isBasingDefault then
		self._manager:basingByDefault(vValueType)
	end
	local nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nTableField = self._fieldDict[nKeyIncludeType]!
		const nFieldType = nTableField.castValueType or nTableField.rawValueType
		if not nFieldType:includeAll(vValueType) then
			vContext:error("wrong value type when set key:"..tostring(nKeyIncludeType))
		end
		return
	end
	self:native_rawset(vContext, vKeyType, vValueType)
end

function SealTable:meta_get(vContext, vKeyType:clazz.IAtomType)
	self:ctxWait(vContext)
	local nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		vContext:pushFirstAndTuple(nField.castValueType or nField.rawValueType)
	else
		vContext:error("index error, key=", tostring(vKeyType))
		vContext:pushFirstAndTuple(self._manager.type.Nil)
	end
end

function SealTable:native_rawset(vContext, vKeyType, vValueType)
	self:ctxWait(vContext)
	if self._isBasingDefault then
		self._manager:basingByDefault(vValueType)
	end
	local nIncludeType = self._keyType:includeAtom(vKeyType)
	if not nIncludeType then
		if vKeyType:isSingleton() and not vKeyType:isNilable() then
			-- TODO thinking when to lock this
			self._keyType = self._manager:checkedUnion(self._keyType, vKeyType)
			self._fieldDict[vKeyType] = {
				rawValueType = vValueType,
				castValueType = false,
				kind = "property",
			}
		else
			vContext:error("set("..tostring(vKeyType)..","..tostring(vValueType)..") error")
		end
	else
		const nTableField = self._fieldDict[nIncludeType]!
		const nFieldType = nTableField.castValueType or nTableField.rawValueType
		if not nFieldType:includeAll(vValueType) then
			vContext:error("wrong value type when set, key:"..tostring(nIncludeType))
		end
	end
end

function SealTable:native_rawget(vContext, vKeyType):Ret(clazz.UAtomUnion)
	self:ctxWait(vContext)
	local nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		return nField.castValueType or nField.rawValueType
	else
		return self._manager.type.Nil
	end
end

function SealTable:meta_ipairs(vContext)
	self:ctxWait(vContext)
	return false
end

function SealTable:meta_pairs(vContext)
	self:ctxWait(vContext)
	const nCom = self._metaEventCom
	if nCom then
		const nPairsFn = nCom:getPairsFunc()
		if nPairsFn then
			print("meta_pairs TODO")
			--[[const nManager = self._manager
			const nRetTuples = nPairsFn:meta_call(vContext, vContext:FixedTermTuple({self}))
			local nRetOneTuple:OrFalse(clazz.UTypeTuple) = false
			nRetTuples:foreachWithFirst(function(vTuple, _)
				nRetOneTuple = vTuple
			end)
			if nRetTuples:getTupleCount() ~= 1 then
				vContext:error("__pairs must return only one tuple")
			end
			return nRetOneTuple]]
		end
	else
		return false
	end
end

function SealTable:setMetaIndex(vContext:clazz.OperContext, vIndexType:OrFalse(clazz.UAtomUnion), vNewIndexType:OrFalse(clazz.UAtomUnion))
	if not vIndexType then
		return
	end
	if vIndexType:isUnion() then
		vContext:info("union type as __index TODO")
		return
	end
	if vIndexType:isNilable() then
		vContext:info("TODO, impl interface if setmetatable without index")
		return
	end
	const nMetaIndexKeyType, nMetaIndexValueDict = vIndexType:lockAsMetaIndex()
	if not nMetaIndexKeyType then
		vContext:info("use type.."..tostring(vIndexType).." as __index TODO")
		return
	end
	const nNever = self._manager.type.Never
	const nSelfKey, nSelfFieldDict = self._keyType, self._fieldDict
	const nMergedKeyType = self._manager:checkedUnion(nMetaIndexKeyType, nSelfKey)
	const nFinalFieldDict:Dict(clazz.IAtomType, TableField) = {}
	nMergedKeyType:foreach(function(vKeyAtom)
		const nSelfInter = nSelfKey:intersectAtom(vKeyAtom) or nNever
		const nMetaInter = nMetaIndexKeyType:intersectAtom(vKeyAtom) or nNever
		assert(type(nSelfInter) == "table")
		assert(type(nMetaInter) == "table")
		local nSetter = false
		local nFnCount = 0
		local nMfnCount = 0
		local nNotFnCount = 0
		local nSelfIsNilable = false
		const nCollection = self._manager:TypeCollection()
		nSelfInter:foreach(function(vAtom)
			const nValue = nSelfFieldDict[vAtom]!.rawValueType
			nCollection:put(nValue)
			nSelfIsNilable = nSelfIsNilable or nValue:isNilable()
			nSetter = true
			if BaseFunction.is(nValue) then
				nFnCount = nFnCount + 1
				if nValue:isMember() then
					nMfnCount = nMfnCount + 1
				end
			else
				nNotFnCount = nNotFnCount + 1
			end
		end)
		if not nSelfInter:includeAll(nMetaInter) or nSelfIsNilable then
			local nMetaIsNilable = false
			nMetaInter:foreach(function(vAtom)
				const nValue = nMetaIndexValueDict[vAtom]!
				nMetaIsNilable = nMetaIsNilable or nValue:isNilable()
				nCollection:put(nValue)
				if BaseFunction.is(nValue) then
					nFnCount = nFnCount + 1
					if nValue:isMember() then
						nMfnCount = nMfnCount + 1
					end
				else
					nNotFnCount = nNotFnCount + 1
				end
			end)
			const nFinalNilable = nMetaIsNilable or not nMetaInter:includeAll(nSelfInter)
			const nMergedValueType = nCollection:mergeToAtomUnion()
			nFinalFieldDict[vKeyAtom] = {
				rawValueType = nFinalNilable and nMergedValueType or nMergedValueType:notnilType(),
				castValueType = false,
				kind = nSetter and "property" or "getter",
			}
		else
			nFinalFieldDict[vKeyAtom] = {
				rawValueType = nCollection:mergeToAtomUnion(),
				castValueType = false,
				kind = nSetter and "property" or "getter",
			}
		end
		if nFnCount > 0 then
			if nNotFnCount > 0 then
				vContext:error("mix function and other type when setmetatable, key="..tostring(vKeyAtom))
			elseif nMfnCount > 0 and nFnCount ~= nMfnCount then
				vContext:error("mix member function and normal function when setmetatable, key="..tostring(vKeyAtom))
			end
		end
	end)
	self._fieldDict = nFinalFieldDict
	self._keyType = nMergedKeyType
end

function SealTable:native_next(vContext, vInitType)
	self:ctxWait(vContext)
	local nNextDict = self._nextDict
	local nValueType = self._nextValue
	if not nNextDict or not nValueType then
		nNextDict = {}
		for nKeyAtom, nField in pairs(self._fieldDict) do
			if nField.kind == "property" then
				nNextDict[nKeyAtom] = nField.castValueType or nField.rawValueType
			end
		end
		local nNil = self._manager.type.Nil
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneField in pairs(self._fieldDict) do
			if nOneField.kind == "property" then
				const nValueType = nOneField.castValueType or nOneField.rawValueType
				const nNotnilType = nValueType:notnilType()
				nNextDict[nOneKey] = nNotnilType
				nCollection:put(nNotnilType)
			end
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		nNextDict[nNil] = nNil
		self._nextValue = nValueType
		self._nextDict = nNextDict
	end
	return nValueType, nNextDict
end

function SealTable:native_getmetatable(vContext)
	self:ctxWait(vContext)
	return self._metaTable or self._manager.type.Nil
end

function SealTable:meta_uop_some(vContext, vOper)
	self:ctxWait(vContext)
	vContext:error("meta uop TODO:"..tostring(vOper))
	return self._manager.type.Never
end

function SealTable:meta_bop_func(vContext, vOper)
	self:ctxWait(vContext)
	const nMethodEvent = OPER_ENUM.bopNoEq[vOper]!
	const nCom = self._metaEventCom
	if nCom then
		const nMethodFn = nCom:getBopFunc(nMethodEvent)
		if nMethodFn then
			return true, nMethodFn
		end
	end
	return false, nil
end

function SealTable:basingByDefault()
	if not self._isBasingDefault then
		self._isBasingDefault = true
		for k, v in pairs(self._fieldDict) do
			self._manager:basingByDefault(v.rawValueType)
		end
	end
end

function SealTable:getCompletion():Ret(clazz.LspCompletion)
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

function SealTable:checkBaseObjectType()
	const nInterface = self._interface
	if nInterface then
		return nInterface
	else
		self:basingByDefault()
		return self._manager.type.AnyObject
	end
end

return SealTable
