
const StringLiteral = require "thlua.type.StringLiteral"
const TypedObject = require "thlua.object.TypedObject"
const TypedFunction = require "thlua.func.TypedFunction"
const MemberFunction = require "thlua.func.MemberFunction"
const AutoFunction = require "thlua.func.AutoFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const OPER_ENUM = require "thlua.type.OPER_ENUM"
const Nil = require "thlua.type.Nil"

const BaseObject = require "thlua.object.BaseObject"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.TableField = Struct {
		rawValueType = clazz.UAtomUnion,
	}
end)

const SealTable = class@<clazz.SealTable, false>(BaseObject)

function.open SealTable:ctor(vManager:clazz.TypeManager, ...)
	self._keyType=vManager.type.Never @clazz.UAtomUnion
	self._fieldDict={}@Dict(clazz.IAtomType, TableField)
	self._nextValue=false@Union(False, clazz.UAtomUnion)
	self._nextDict=false@Union(False, Dict(clazz.IAtomType, clazz.UAtomUnion))
	self._metaTable=false@OrFalse(clazz.OpenTable, clazz.SealTable)
	self._metaIndex=false@OrFalse(clazz.IAtomType)
	self._newIndexType=false@OrFalse(clazz.IAtomType)
end

function SealTable:meta_len(vContext)
	-- TODO
	return self._manager.type.Number
end

function SealTable:ctxWait(vContext:clazz.OperContext)
end

function SealTable:initByKeyValue(vKeyType:clazz.UAtomUnion, vValueDict:Dict(clazz.IAtomType, clazz.UAtomUnion)):Ret()
	self._keyType = vKeyType
	for k,v in pairs(vValueDict) do
		self._fieldDict[k] = {
			rawValueType = v,
		}
	end
end

function SealTable:onSetMetaTable(vContext:clazz.ApplyContext)
end

function SealTable:native_setmetatable(vContext, vMetaTableType)
	if self._metaTable then
		vContext:error("can only setmetatable once for one table")
		return
	end
	self._metaTable = vMetaTableType
	-- 1. copyout meta event items
	assert(not self._metaEventCom, "meta event has been setted")
	const nMetaEventCom = self._manager:makeMetaEventCom(self)
	nMetaEventCom:initByTable(vContext, vMetaTableType)
	self._metaEventCom = nMetaEventCom
	-- 2. copyout index/newindex event items
	local nManager = self._manager
	const nIndexType = vMetaTableType:native_rawget(vContext, nManager:Literal("__index"))
	const nNewIndexType = vMetaTableType:native_rawget(vContext, nManager:Literal("__newindex"))
	-- 3. set default com
	self:setMetaIndex(
		vContext,
		not nIndexType:isNever() and nIndexType or false,
		not nNewIndexType:isNever() and nNewIndexType or false)
	-- 4. trigger on set
	vContext:getStack():withNoPushContext(vContext:getNode(), function(vApplyContext)
		self:onSetMetaTable(vApplyContext)
	end)
end

function SealTable:meta_set(vContext, vKeyType, vValueType)
	self:ctxWait(vContext)
	vContext:pushNothing()
	vValueType:setAssigned(vContext)
	local nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nTableField = self._fieldDict[nKeyIncludeType]!
		const nFieldType = nTableField.rawValueType
		if not nFieldType:includeAll(vValueType) then
			vContext:error("wrong value type when set key:"..tostring(nKeyIncludeType))
		end
		return
	end
	self:native_rawset(vContext, vKeyType, vValueType)
end

const NIL_TRIGGER = 1
const NONE_TRIGGER = 2
function SealTable:meta_get(vContext, vKeyType)
	self:ctxWait(vContext)
	const nNotRecursive, nOkay = vContext:recursiveChainTestAndRun(self, function()
		const nKeyIncludeType = self._keyType:includeAtom(vKeyType)
		const nIndexType = self._metaIndex
		local nTrigger:OrFalse($NIL_TRIGGER,$NONE_TRIGGER) = false
		if nKeyIncludeType then
			const nField = self._fieldDict[nKeyIncludeType]!
			const nValueType = nField.rawValueType
			if nValueType:isNilable() then
				nTrigger = NIL_TRIGGER
				if nIndexType then
					vContext:pushFirstAndTuple(nValueType:notnilType())
				else
					vContext:pushFirstAndTuple(nValueType)
				end
			else
				vContext:pushFirstAndTuple(nValueType)
			end
		else
			nTrigger = NONE_TRIGGER
			const nInterType = self._keyType:safeIntersect(vKeyType)
			if not nInterType then
				vContext:error("unexpected intersect when table get")
			else
				nInterType:foreach(function(vKeyAtom)
					const nField = self._fieldDict[vKeyAtom]!
					const nValueType = nField.rawValueType
					if nIndexType then
						vContext:pushFirstAndTuple(nValueType:notnilType())
					else
						vContext:pushFirstAndTuple(nValueType)
					end
				end)
			end
			if not nIndexType then
				vContext:pushFirstAndTuple(self._manager.type.Nil)
			end
		end
		local nOkay = nTrigger ~= NONE_TRIGGER
		if nTrigger and nIndexType then
			const nNextOkay = nIndexType:meta_get(vContext, vKeyType)
			nOkay = nOkay or nNextOkay
		end
		return nOkay
	end)
	if nNotRecursive then
		return nOkay
	else
		vContext:pushFirstAndTuple(self._manager.type.Nil)
		return false
	end
end

function SealTable:native_rawset(vContext, vKeyType, vValueType)
	self:ctxWait(vContext)
	vValueType:setAssigned(vContext)
	local nIncludeType = self._keyType:includeAtom(vKeyType)
	if not nIncludeType then
		if vKeyType:isSingleton() and not vKeyType:isNilable() then
			-- TODO thinking when to lock this
			self._keyType = self._manager:checkedUnion(self._keyType, vKeyType)
			self._fieldDict[vKeyType] = {
				rawValueType = vValueType,
			}
		else
			vContext:error("set("..tostring(vKeyType)..","..tostring(vValueType)..") error")
		end
	else
		const nTableField = self._fieldDict[nIncludeType]!
		const nFieldType = nTableField.rawValueType
		if not nFieldType:includeAll(vValueType) then
			vContext:error("wrong value type when set, key:"..tostring(nIncludeType))
		end
	end
end

function SealTable:native_rawget(vContext, vKeyType):Ret(clazz.UAtomUnion)
	self:ctxWait(vContext)
	local nKeyIncludeType = self._keyType:includeAtom(vKeyType)
	if nKeyIncludeType then
		const nField = self._fieldDict[nKeyIncludeType]!
		return nField.rawValueType
	else
		return self._manager.type.Nil
	end
end

function SealTable:meta_ipairs(vContext)
	self:ctxWait(vContext)
	return false
end

function SealTable:meta_pairs(vContext)
	self:ctxWait(vContext)
	const nCom = self._metaEventCom
	if nCom then
		const nPairsFn = nCom:getPairsFunc()
		if nPairsFn then
			print("meta_pairs TODO")
			--[[const nManager = self._manager
			const nRetTuples = nPairsFn:meta_call(vContext, vContext:FixedTermTuple({self}))
			local nRetOneTuple:OrFalse(clazz.UTypeTuple) = false
			nRetTuples:foreachWithFirst(function(vTuple, _)
				nRetOneTuple = vTuple
			end)
			if nRetTuples:getTupleCount() ~= 1 then
				vContext:error("__pairs must return only one tuple")
			end
			return nRetOneTuple]]
		end
	else
		return false
	end
end

function SealTable:setMetaIndex(vContext:clazz.OperContext, vIndexType:OrFalse(clazz.UAtomUnion), vNewIndexType:OrFalse(clazz.UAtomUnion))
	if not vIndexType then
		return
	end
	if vIndexType:isUnion() then
		vContext:info("union type as __index TODO")
		return
	end
	if vIndexType:isNilable() then
		vContext:info("TODO, impl interface if setmetatable without index")
		return
	end
	self._metaIndex = vIndexType
end

function SealTable:native_next(vContext, vInitType)
	self:ctxWait(vContext)
	local nNextDict = self._nextDict
	local nValueType = self._nextValue
	if not nNextDict or not nValueType then
		nNextDict = {}
		for nKeyAtom, nField in pairs(self._fieldDict) do
			nNextDict[nKeyAtom] = nField.rawValueType
		end
		local nNil = self._manager.type.Nil
		local nCollection = self._manager:TypeCollection()
		for nOneKey, nOneField in pairs(self._fieldDict) do
			const nValueType = nOneField.rawValueType
			const nNotnilType = nValueType:notnilType()
			nNextDict[nOneKey] = nNotnilType
			nCollection:put(nNotnilType)
		end
		nCollection:put(nNil)
		nValueType = nCollection:mergeToAtomUnion()
		nNextDict[nNil] = nNil
		self._nextValue = nValueType
		self._nextDict = nNextDict
	end
	return nValueType, nNextDict
end

function SealTable:native_getmetatable(vContext)
	self:ctxWait(vContext)
	return self._metaTable or self._manager.type.Nil
end

function SealTable:meta_uop_some(vContext, vOper)
	self:ctxWait(vContext)
	vContext:error("meta uop TODO:"..tostring(vOper))
	return self._manager.type.Never
end

function SealTable:meta_bop_func(vContext, vOper)
	self:ctxWait(vContext)
	const nMethodEvent = OPER_ENUM.bopNoEq[vOper]!
	const nCom = self._metaEventCom
	if nCom then
		const nMethodFn = nCom:getBopFunc(nMethodEvent)
		if nMethodFn then
			return true, nMethodFn
		end
	end
	return false, nil
end

function SealTable:memberFunctionFillSelf(vContext:clazz.ApplyContext, vSelfTable:clazz.SealTable)
	const nNotRecursive = vContext:recursiveChainTestAndRun(self, function()
		for _, nField in pairs(self._fieldDict) do
			const nSelfValue = nField.rawValueType
			if MemberFunction.is(nSelfValue) then
				if not nSelfValue:needPolyArgs() then
					nSelfValue:indexAutoFn(vSelfTable)
				end
			end
		end
		return true
	end)
	if nNotRecursive then
		const nMetaIndex = self._metaIndex
		if nMetaIndex then
			if BaseObject.is(nMetaIndex) then
				nMetaIndex:memberFunctionFillSelf(vContext, vSelfTable)
			end
		end
	end
end

function SealTable:getValueDict():Ret(Dict(clazz.IAtomType, clazz.UAtomUnion))
	local nDict:Dict(clazz.IAtomType, clazz.UAtomUnion) = {}
	self._keyType:foreach(function(vType)
		nDict[vType] = self._fieldDict[vType]!.rawValueType
	end)
	return nDict
end

function SealTable:getCompletion():Ret(clazz.LspCompletion)
	local nDict:Dict(String, True) = {}
	self._keyType:foreach(function(vType)
		if StringLiteral.is(vType) then
			nDict[vType:getLiteral()] = true
		end
	end)
	return nDict
end

return SealTable
