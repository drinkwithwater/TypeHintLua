
const MemberFunction = require "thlua.func.MemberFunction"
const MetaObject = require "thlua.object.MetaObject"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const Struct = class@<clazz.Struct, false>(MetaObject)

function.open Struct:ctor(...)
end

function Struct:detailString(vToStringCache, vVerbose)
	return "struct@"..tostring(self._node)
end

function Struct:assumeIncludeObject(vAssumeSet:Dict(Integer, Boolean), vRightObject:clazz.MetaObject):Ret(Boolean)
	local nAssumeInclude:Boolean = false
	if not Struct.is(vRightObject) then
		return false
	end
	const nRightValueDict = vRightObject:copyValueDict()
	const nRightKeyRefer, nRightNextKey = vRightObject:getKeyTypes()
	const nLeftNextKey = self._nextKey
	if nLeftNextKey and nRightNextKey then
		const nLR = nLeftNextKey:assumeIncludeAll(vAssumeSet, nRightNextKey)
		const nRL = nRightNextKey:assumeIncludeAll(vAssumeSet, nLeftNextKey)
		if not (nLR and nRL) then
			return false
		end
	elseif nLeftNextKey or nRightNextKey then
		return false
	end
	const function isMatchedKeyValue(
		vLeftKey:clazz.IAtomType, vLeftValue:clazz.UAllType,
		vRightKey:clazz.IAtomType, vRightValue:clazz.UAllType):Ret(Boolean)
		if not vRightValue:assumeIncludeAll(vAssumeSet, vLeftValue) then
			return false
		end
		if not vLeftValue:assumeIncludeAll(vAssumeSet, vRightValue) then
			return false
		end
		if not vLeftKey:assumeIncludeAtom(vAssumeSet, vRightKey) then
			return false
		end
		return true
	end
	const nRightResultType = nRightKeyRefer:getResultType()
	if not self:_everyWith(vRightObject, function(nLeftKey, nLeftValue, _)
		if nRightResultType then -- key is merged, just get one matched
			const nRightKey = nRightResultType:assumeIncludeAtom(vAssumeSet, nLeftKey)
			if not nRightKey then
				return false
			end
			const nRightValue = nRightValueDict[nRightKey]
			if not nRightValue then
				return false
			end
			if not isMatchedKeyValue(nLeftKey, nLeftValue, nRightKey, nRightValue) then
				return false
			end
			nRightValueDict[nRightKey] = nil
		else -- key is not merged, iter for one matched
			local nMatchedKey:OrNil(clazz.IAtomType) = nil
			for _, nRightKey in ipairs(nRightKeyRefer:getListAwait()) do
				if nRightKey:assumeIncludeAtom(vAssumeSet, nLeftKey) then
					const nRightValue = nRightValueDict[nRightKey]
					if nRightValue and isMatchedKeyValue(nLeftKey, nLeftValue, nRightKey, nRightValue) then
						nMatchedKey = nRightKey
						break
					end
				end
			end
			if not nMatchedKey then
				return false
			end
			nRightValueDict[nMatchedKey] = nil
		end
		return true
	end) then
		return false
	end
	if next(nRightValueDict) then
		return false
	end
	return true
end

function Struct:meta_set(vContext, vKeyType, vValueType)
	vContext:pushNothing()
	const nKey, nSetValue = self:_keyIncludeAtom(vKeyType)
	if nKey then
		if MemberFunction.is(nSetValue) then
			vContext:error("error:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field is member function")
			return
		end
		local nSetType = nSetValue:checkAtomUnion()
		if vContext:castLuaType(vValueType, nSetType) then
			return
		elseif nSetType:includeAll(vValueType) then
			return
		else
			vContext:error("error1:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not match")
		end
	end
	vContext:error("error2:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not exist")
end

function Struct:native_rawset(vContext, vKeyType, vValueType)
	vContext:warn("abstract object take rawset")
	const nKey, nSetValue = self:_keyIncludeAtom(vKeyType)
	if nKey then
		if not nSetValue:includeAll(vValueType) then
			vContext:error("error1:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not match")
		end
	else
		vContext:error("error2:set("..tostring(vKeyType)..","..tostring(vValueType)..") in struct, field not exist")
	end
end

return Struct
