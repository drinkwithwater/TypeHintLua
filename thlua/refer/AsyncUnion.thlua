
const ScheduleTask = require "thlua.manager.ScheduleTask"
const class = require "thlua.class"
const Exception = require "thlua.Exception"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const AsyncUnion = class@<clazz.AsyncUnion, clazz.IType>()

function AsyncUnion.__tostring(self:clazz.AsyncUnion)
	const l:List(String) = {}
	const nTypeList = self._typeList
	if nTypeList then
		for i, v in ipairs(nTypeList) do
			l[i] = tostring(v)
		end
		return "AsyncUnion("..table.concat(l, ",")..")"
	else
		return "AsyncUnion(?)"
	end
end

function.open AsyncUnion:ctor(vManager:clazz.TypeManager)
	const nTask = vManager:getScheduleManager():newTask()
	self._manager=vManager
	self._task = nTask
	self._assignNode = false@OrFalse(clazz.IBaseNode)
	self._mayRecursive=false@Boolean
	self._typeList=false@OrFalse(List(clazz.IAtomType))
	self._resultType=false@OrFalse(clazz.UAtomUnion)
	self._listBuildEvent=nTask:makeEvent()
	self._resultBuildEvent=nTask:makeEvent()
	self.id=vManager:genTypeId()
end

function AsyncUnion:detailString(v, vVerbose)
	return "AsyncUnion detail string TODO"
	--[[
	const nCom = self._com
	if not nCom then
		return "Reference("..(tostring(self._key) or tostring(self._assignNode))..")"
	else
		if AsyncUnion.is(nCom) then
			return "TypeReference("..tostring(nCom:getTypeNowait())..")"
		else
			return "TemplateReference("..(tostring(self._key) or tostring(self._assignNode))..")"
		end
	end
	]]
end

function AsyncUnion:getResultType():Ret(OrFalse(clazz.UAtomUnion))
	return self._resultType
end

function AsyncUnion:getTypeNowait():Ret(Union(clazz.AsyncUnion, clazz.UAtomUnion))
	return self._resultType or self
end

function AsyncUnion:checkAtomUnion():Ret(clazz.UAtomUnion)
	if not self._resultType then
		self._resultBuildEvent:wait()
	end
	return (assert(self._resultType, "result type not setted"))
end

function AsyncUnion:mayRecursive():Ret(Boolean)
	return self._mayRecursive
end

function AsyncUnion:getListAwait():Ret(List(clazz.IAtomType))
	if not self._typeList then
		self._listBuildEvent:wait()
	end
	return (assert(self._typeList, "type list not setted"))
end

function AsyncUnion:setTypeAsync(vNode:clazz.IBaseNode, vFn:Fn():Ret(clazz.UMustType))
	assert(not self._assignNode, "async type has setted")
	self._assignNode = vNode
	self._task:runAsync(function()
		const nResultType = vFn()
		if AsyncUnion.is(nResultType) then
			self._typeList = nResultType:getListAwait()
			self._listBuildEvent:wakeup()
			self._resultType = nResultType:checkAtomUnion()
			self._resultBuildEvent:wakeup()
		else
			const nList = {} @ List(clazz.IAtomType)
			nResultType:foreach(function(vType)
				nList[#nList + 1] = vType
			end)
			self._typeList = nList
			self._resultType = nResultType
			self._listBuildEvent:wakeup()
			self._resultBuildEvent:wakeup()
		end
	end)
end

function AsyncUnion:setListAsync(vNode:clazz.IBaseNode, vGetListLateRunner:Fn():Ret(List(clazz.IAtomType), OrNil(Fn(clazz.UAtomUnion))))
	assert(not self._assignNode, "async type has setted")
	self._assignNode = vNode
	self._task:runAsync(function()
		const nAtomList, nLateRunner = vGetListLateRunner()
		-- step 1. set list
		self._typeList = nAtomList
		for k, v in ipairs(nAtomList) do
			if v:mayRecursive() then
				self._mayRecursive = true
			end
		end
		self._listBuildEvent:wakeup()
		-- step 2. merge to result type
		local nResultType:OrNil(clazz.UAtomUnion) = nil
		if #nAtomList == 0 then
			nResultType = self._manager.type.Never
		elseif #nAtomList == 1 then
			nResultType = nAtomList[1]!
		else
			local nCollection = self._manager:TypeCollection()
			for _, v in ipairs(nAtomList) do
				nCollection:put(v)
			end
			nResultType = nCollection:mergeToAtomUnion()
		end
		self._resultType = nResultType
		self._resultBuildEvent:wakeup()
		if nLateRunner then
			nLateRunner(nResultType)
		end
	end)
end

function AsyncUnion:foreachAwait(vFunc:Fn(clazz.IAtomType))
	const nResultType = self._resultType
	if nResultType then
		nResultType:foreach(vFunc)
	else
		local nListType = self:getListAwait()
		for _, v in ipairs(nListType) do
			vFunc(v)
		end
	end
end

function AsyncUnion:assumeIncludeAll(vAssumeSet, vRight, vSelfType)
	const nResultType = self:getTypeNowait()
	if not nResultType:isAsync() then
		return nResultType:assumeIncludeAll(vAssumeSet, vRight, vSelfType)
	else
		local nAllInclude:Boolean = true
		const nTypeList = nResultType:getListAwait()
		vRight:foreachAwait(function(vAtomType)
			if not nAllInclude then
				return
			end
			local nCurInclude:Boolean = false
			for _, nType in ipairs(nTypeList) do
				if nType:assumeIncludeAtom(vAssumeSet, vAtomType, vSelfType) then
					nCurInclude = true
					break
				end
			end
			if not nCurInclude then
				nAllInclude = false
			end
		end)
		return nAllInclude
	end
end

function AsyncUnion:assumeIntersectSome(vAssumeSet, vRight)
	const nResultType = self:getTypeNowait()
	if not nResultType:isAsync() then
		return nResultType:assumeIntersectSome(vAssumeSet, vRight)
	else
		local nSomeIntersect:Boolean = false
		const nTypeList = nResultType:getListAwait()
		vRight:foreachAwait(function(vAtomType)
			if nSomeIntersect then
				return
			end
			local nCurIntersect:Boolean = false
			for _, nType in ipairs(nTypeList) do
				if nType:assumeIntersectAtom(vAssumeSet, vAtomType) then
					nCurIntersect = true
					break
				end
			end
			if nCurIntersect then
				nSomeIntersect = true
			end
		end)
		return nSomeIntersect
	end
end

function AsyncUnion:foreachAwait(vFunc)
	const nResultType = self:getTypeNowait()
	if not nResultType:isAsync() then
		nResultType:foreach(vFunc)
	else
		local nListType = nResultType:getListAwait()
		for _, v in ipairs(nListType) do
			vFunc(v)
		end
	end
end

function AsyncUnion:intersectAtom(vRightType)
	return self:checkAtomUnion():intersectAtom(vRightType)
end

function AsyncUnion:includeAtom(vRightType)
	return self:checkAtomUnion():includeAtom(vRightType)
end

function AsyncUnion:includeAll(vRight)
	return self:assumeIncludeAll(nil, vRight)
end

function AsyncUnion:safeIntersect(vRight)
	return self:checkAtomUnion():safeIntersect(vRight)
end

function AsyncUnion:intersectSome(vRight)
	return self:assumeIntersectSome(nil, vRight)
end

function AsyncUnion:isAsync():Ret(True)
	return true
end

function AsyncUnion:unionSign()
	return tostring(self.id)
end

function AsyncUnion:isNever():Ret(Boolean)
	const nList = self:getListAwait()
	return #nList <= 0
end

function AsyncUnion:isReference():Ret(True)
	return true
end

function AsyncUnion:getManager()
	return self._manager
end

function AsyncUnion:mustType()
	return self
end

return AsyncUnion
