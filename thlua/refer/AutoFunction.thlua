
const TypeFunction = require "thlua.func.TypeFunction"
const BaseReference = require "thlua.refer.BaseReference"
const Exception = require "thlua.Exception"

const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.BuildRunner = Fn(clazz.AutoFunction, OrFalse(clazz.TypeFunction)):Ret(
		OrFalse(clazz.TypeFunction), Fn():Ret(clazz.TypeFunction)
	)
end)

const AutoFunction = class@<clazz.AutoFunction, false>(BaseReference)
AutoFunction.__tostring=function(self:clazz.AutoFunction)
	return "auto-fn"
end

function.open AutoFunction:ctor(vManager:clazz.TypeManager, vContext:clazz.SealContext)
	const nScheduleManager = self._scheduleManager
	self._headStartEvent=nScheduleManager:makeEvent()
	self._headFinishEvent=nScheduleManager:makeEvent(self._selfCo)
	self._bodyStartEvent=nScheduleManager:makeEvent()
	self._bodyFinishEvent=nScheduleManager:makeEvent(self._selfCo)
	self._castList={}@List(clazz.TypeFunction)
	self._typeFn=false@OrFalse(clazz.TypeFunction)
	self._retTuples=false@OrFalse(clazz.RetTuples)
	self._context = vContext
	self._stopWaitType=true@Boolean
end

function AutoFunction:checkWhenCast(vContext:clazz.OperContext, vTypeFn:clazz.TypeFunction):Ret(Boolean)
	if not self._headStartEvent:isWaken() then
		const nList = self._castList
		nList[#nList + 1] = vTypeFn
		return true
	else
		return false
	end
end

function AutoFunction:setRetTuples(vRetTuples:clazz.RetTuples)
	self._retTuples = vRetTuples
end

function AutoFunction:getRetTuples():Ret(OrFalse(clazz.RetTuples))
	return self._retTuples
end

function AutoFunction:build(vRunner:BuildRunner)
	self._scheduleManager:coStart(self._selfCo, function()
		self:_build(vRunner)
	end)
end

function AutoFunction:_build(vRunner:BuildRunner)
	self._headStartEvent:wait()
	self._stopWaitType = true
	local nCastFn:OrFalse(clazz.TypeFunction) = false
	for k,v in pairs(self._castList) do
		nCastFn = v
	end
	const nTypeFn, nLateRunner = vRunner(self, nCastFn)
	if nTypeFn then
		self._typeFn = nTypeFn
		self._retTuples = nTypeFn:getRetTuples()
	end
	self._headFinishEvent:wakeup()
	self._bodyStartEvent:wait()
	const nTypeFn = nLateRunner()
	if not self._typeFn then
		self._typeFn = nTypeFn
		self._retTuples = nTypeFn:getRetTuples()
	end
	self._bodyFinishEvent:wakeup()
end

function AutoFunction:meta_call(vContext:clazz.OperContext, vTermTuple:clazz.UTermTuple):Ret(clazz.RetTuples)
	const nTypeFn = self:getFnAwait()
	return nTypeFn:meta_call(vContext, vTermTuple)
end

function AutoFunction:getFnAwait():Ret(clazz.TypeFunction)
	if not self._typeFn then
		self._headStartEvent:wakeup()
		self._headFinishEvent:wait()
		if not self._typeFn then
			self._bodyStartEvent:wakeup()
			self._bodyFinishEvent:wait()
		end
	end
	return (assert(self._typeFn, "_typeFn must existed here"))
end

function AutoFunction:startBuild()
	self._headStartEvent:wakeup()
	self._bodyStartEvent:wakeup()
end

function AutoFunction:canWaitType()
	return not self._stopWaitType
end

function AutoFunction:getContext()
	return self._context
end

function AutoFunction:getAssignNode()
	return self._context:getNode()
end

return AutoFunction
