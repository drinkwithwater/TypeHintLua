
const Exception = require "thlua.Exception"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const ClassFactory = {}
ClassFactory.__index=ClassFactory

function:class(clazz.ClassFactory) ClassFactory.new(vManager:clazz.TypeManager, vRefer:clazz.Reference)
	const self = setmetatable({.class
		_manager=vManager,
		_refer=vRefer,
		-- startSid : true means wait to gen sid and start, int means waiting, false means started
		_waitStartSid=true@Union(Boolean, Integer),
		_namedRefer=vRefer,
		_typeFn=false@OrFalse(clazz.TypeFunction),
		_classType=false@OrFalse(clazz.LuaTable),
		_waitClassCoToSid={} @ OrFalse(Dict(Thread, Integer)),
		_waitBuildCoToSid={} @ OrFalse(Dict(Thread, Integer)),
		_waitFuncCoToSid={} @ Dict(Thread, Integer),
	}, ClassFactory)
	return self
end

function ClassFactory:addReference(vRefer:clazz.Reference)
	if vRefer:getKey() and not self._namedRefer:getKey() then
		self._namedRefer = vRefer
	end
end

function ClassFactory:getToString():Ret(String)
	return tostring(self._refer)
end

function ClassFactory:getResultType():Ret(OrFalse(clazz.LuaTable))
	return self._classType
end

function ClassFactory:meta_call(vContext:clazz.Context, vTermTuple:clazz.UTermTuple):Ret(clazz.RetTuples)
	const nTypeFn = self:getFnAwait()
	return nTypeFn:meta_call(vContext, vTermTuple)
end

function ClassFactory:getFnAwait():Ret(clazz.TypeFunction)
	if not self._typeFn then
		self:getTypeAwait()
		if not self._typeFn then
			self:startBuild()
			if not self._typeFn then
				const nSessionId = self._manager:genSessionId()
				const nCurCo = coroutine.running()
				self._waitFuncCoToSid[nCurCo] = nSessionId
				self._manager:coWait(nCurCo, nSessionId, self._refer:getSelfCo())
			end
		end
	end
	return (assert(self._typeFn, "type function not setted after wait"))
end

function ClassFactory:getTypeAwait():Ret(clazz.UAtomUnion)
	if not self._classType then
		const nWaitClassCoToSid = assert(self._waitClassCoToSid, "can't be false here")
		const nSessionId = self._manager:genSessionId()
		const nCurCo = coroutine.running()
		nWaitClassCoToSid[nCurCo] = nSessionId
		self._manager:coWait(nCurCo, nSessionId, self._refer:getSelfCo())
	end
	return (assert(self._classType, "result type not setted"))
end

function ClassFactory:getMayRecursive():Ret(Boolean)
	return true
end

function ClassFactory:getListAwait():Ret(List(clazz.IAtomType))
	if not self._classType then
		const nWaitClassCoToSid = assert(self._waitClassCoToSid, "can't be false here")
		const nSessionId = self._manager:genSessionId()
		const nCurCo = coroutine.running()
		nWaitClassCoToSid[nCurCo] = nSessionId
		self._manager:coWait(nCurCo, nSessionId, self._refer:getSelfCo())
	end
	const nClassType = assert(self._classType, "clazz type is not setted")
	return {nClassType}
end

function ClassFactory:build(
	vRunner:Fn():Ret(
		clazz.MetaObject,
		OrFalse(clazz.TypeFunction),
		Fn(clazz.ClassFactory, clazz.LuaTable):Ret(OrFalse(clazz.TypeFunction))
	)
)
	--vGetInterface:Fn():Ret(clazz.MetaObject), vClassBuilder:Fn(clazz.ClassFactory, clazz.LuaTable):Ret(clazz.TypeFunction))
	-- step 1. wait inteface
	const nInterface, nTypeFn, nLateRunner = vRunner()
	-- step 2. create table
	const nNewTable = self._manager:LuaTable()
	nNewTable:initByClassCom(self, nInterface)
	self._classType = nNewTable
	if nTypeFn then
		self._typeFn = nTypeFn
	end
	self:_wakeupClass()
	-- nClassType:linkNamedReference(self)
	const nWaitStartSid = self._waitStartSid
	if nWaitStartSid then
		assert(nWaitStartSid == true, "wait start sid must be true here")
		const nSessionId = self._manager:genSessionId()
		self._waitStartSid = nSessionId
		const co = coroutine.running()
		self._manager:coWait(co, nSessionId)
	end
	-- step 3. run build
	const nTypeFn = nLateRunner(self, nNewTable)
	if nTypeFn then
		self._typeFn = nTypeFn
	end
	self:_wakeupBuild()
	-- step 4. wake up fn
	for co, sid in pairs(self._waitFuncCoToSid) do
		self._manager:coWakeup(co, sid)
	end
end

function ClassFactory:startBuild()
	const nWaitStartSid = self._waitStartSid
	if nWaitStartSid then
		self._waitStartSid = false
		if type(nWaitStartSid) == "number" then
			const co = self._refer:getSelfCo()
			self._manager:coWakeup(co, nWaitStartSid)
		end
	end
end

function ClassFactory:onSetMetaTable()
	self:_wakeupBuild()
end

function ClassFactory:waitBuild()
	self:startBuild()
	const nCurCo = coroutine.running()
	const nSelfCo = self._refer:getSelfCo()
	if nCurCo ~= nSelfCo then
		const nWaitCoToSid = self._waitBuildCoToSid
		if nWaitCoToSid then
			const nSessionId = self._manager:genSessionId()
			nWaitCoToSid[nCurCo] = nSessionId
			self._manager:coWait(nCurCo, nSessionId, nSelfCo)
		end
	end
end

function ClassFactory:_wakeupClass()
	assert(coroutine.running() == self._refer:getSelfCo(), "can only setmetatable in constructor thread")
	const nWaitCoToSid = self._waitClassCoToSid
	if nWaitCoToSid then
		self._waitClassCoToSid = false
		for co, sid in pairs(nWaitCoToSid) do
			self._manager:coWakeup(co, sid)
		end
	end
end

function ClassFactory:_wakeupBuild()
	assert(coroutine.running() == self._refer:getSelfCo(), "can only setmetatable in constructor thread")
	const nWaitCoToSid = self._waitBuildCoToSid
	if nWaitCoToSid then
		self._waitBuildCoToSid = false
		for co, sid in pairs(nWaitCoToSid) do
			self._manager:coWakeup(co, sid)
		end
	end
end

function.open ClassFactory.is(self):isguard(clazz.ClassFactory)
	return getmetatable(self) == ClassFactory
end

return ClassFactory
