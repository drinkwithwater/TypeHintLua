
const BaseReference = require "thlua.refer.BaseReference"
const Exception = require "thlua.Exception"

const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.BuildRunner = Fn(clazz.ClassFactory):Ret(
		OrFalse(clazz.LuaTable), clazz.MetaObject,
		Fn(clazz.LuaTable):Ret(OrFalse(clazz.TypeFunction), Fn():Ret(clazz.TypeFunction))
	)
end)

const ClassFactory = class@<clazz.ClassFactory, false>(BaseReference)
function ClassFactory.__tostring(self:clazz.ClassFactory)
	return "class@"..tostring(self._context:getNode())
end

function.open ClassFactory:ctor(vManager:clazz.TypeManager, vContext:clazz.SealContext)
	const nScheduleManager = self._scheduleManager
	self._classEvent=nScheduleManager:makeEvent(self._selfCo)
	self._headStartEvent=nScheduleManager:makeEvent()
	self._headFinishEvent=nScheduleManager:makeEvent(self._selfCo)
	self._buildStartEvent=nScheduleManager:makeEvent()
	self._buildFinishEvent=nScheduleManager:makeEvent(self._selfCo)
	self._funcEvent=nScheduleManager:makeEvent(self._selfCo)
	self._typeFn=false@OrFalse(clazz.TypeFunction)
	self._classType=false@OrFalse(clazz.LuaTable)
	self._context = vContext
	self._stopWaitType=false@Boolean
end

function ClassFactory:getToString():Ret(String)
	return tostring(self._context:getNode())
end

function ClassFactory:meta_call(vContext:clazz.OperContext, vTermTuple:clazz.UTermTuple):Ret(clazz.RetTuples)
	self:waitBuild()
	const nTypeFn = self:getFnAwait()
	return nTypeFn:meta_call(vContext, vTermTuple)
end

function ClassFactory:getFnAwait():Ret(clazz.TypeFunction)
	if not self._typeFn then
		self._classEvent:wait()
		self._headStartEvent:wakeup()
		self._headFinishEvent:wait()
		if not self._typeFn then
			self._buildStartEvent:wakeup()
			self._buildFinishEvent:wait()
			if not self._typeFn then
				self._funcEvent:wait()
			end
		end
	end
	return (assert(self._typeFn, "type function not setted after wait"))
end

function ClassFactory:getClassAwait():Ret(clazz.UAtomUnion)
	if not self._classType then
		self._classEvent:wait()
	end
	return (assert(self._classType, "result type not setted"))
end

function ClassFactory:build(vRunner:BuildRunner)
	self._scheduleManager:coStart(self._selfCo, function()
		self:_build(vRunner)
	end)
end

function ClassFactory:_build(vRunner:BuildRunner)
	-- step 1. wait inteface
	const nBaseClass, nInterface, nPreRunner = vRunner(self)
	-- step 2. create table
	const nNewTable = self._manager:LuaTable()
	nNewTable:initByClassCom(self, nBaseClass, nInterface)
	self._classType = nNewTable
	self._classEvent:wakeup()
	self._headStartEvent:wait()
	self._stopWaitType = true
	-- nClassType:linkNamedReference(self)
	const nTypeFn, nLateRunner = nPreRunner(nNewTable)
	if nTypeFn then
		self._typeFn = nTypeFn
	end
	self._headFinishEvent:wakeup()
	self._buildStartEvent:wait()
	-- step 3. run build
	const nTypeFn = nLateRunner()
	if not self._typeFn then
		self._typeFn = nTypeFn
	end
	self._buildFinishEvent:wakeup()
	-- step 4. wake up fn
	self._funcEvent:wakeup()
end

function ClassFactory:startBuild()
	self._headStartEvent:wakeup()
	self._buildStartEvent:wakeup()
end

function ClassFactory:onSetMetaTable()
	self._buildFinishEvent:wakeup()
end

function ClassFactory:waitBuild()
	self:startBuild()
	if coroutine.running() ~= self._selfCo then
		self._buildFinishEvent:wait()
	end
end

function ClassFactory:canWaitType()
	return not self._stopWaitType
end

function ClassFactory:getContext()
	return self._context
end

function ClassFactory:getAssignNode()
	return self._context:getNode()
end

return ClassFactory
