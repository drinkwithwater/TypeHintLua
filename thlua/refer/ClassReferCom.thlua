
const Exception = require "thlua.Exception"

(@let.class = import("thlua.type.TypeClass").class)

const ClassReferCom = {}
ClassReferCom.__index=ClassReferCom

function:class(class.ClassReferCom) ClassReferCom.new(vManager:class.TypeManager, vRefer:class.Reference)
	const self = setmetatable({.class
		_manager=vManager,
		_refer=vRefer,
		_startSid=vManager:genSessionId(),
		_namedRefer=vRefer,
		_mayRecursive=false@Boolean,
		_classType=false@OrFalse(class.LuaTable),
		_interface=false@OrFalse(class.MetaObject),
		_typeFunction=false@OrFalse(class.TypeFunction),
		_waitClassCoToSid={} @ Dict(Thread, Integer),
		_waitBuildCoToSid={}@OrFalse(Dict(Thread, Integer)),
	}, ClassReferCom)
	return self
end

function ClassReferCom:addReference(vRefer:class.Reference)
	if vRefer:getKey() and not self._namedRefer:getKey() then
		self._namedRefer = vRefer
	end
end

function ClassReferCom:getToString():Ret(String)
	return tostring(self._refer)
end

function ClassReferCom:getTypeFn():Ret(OrFalse(class.TypeFunction))
	return self._typeFunction
end

function ClassReferCom:getInterface():Ret(OrFalse(class.MetaObject))
	return self._interface
end

function ClassReferCom:getResultType():Ret(OrFalse(class.LuaTable))
	return self._classType
end

function ClassReferCom:getTypeAwait():Ret(class.UAtomUnion)
	if not self._classType then
		const nSessionId = self._manager:genSessionId()
		const nCurCo = coroutine.running()
		self._waitClassCoToSid[nCurCo] = nSessionId
		self._manager:coWait(nCurCo, nSessionId, self._refer:getSelfCo())
	end
	return (assert(self._classType, "result type not setted"))
end

function ClassReferCom:getMayRecursive():Ret(Boolean)
	return self._mayRecursive
end

function ClassReferCom:getListAwait():Ret(List(class.IAtomType))
	if not self._classType then
		const nSessionId = self._manager:genSessionId()
		const nCurCo = coroutine.running()
		self._waitClassCoToSid[nCurCo] = nSessionId
		self._manager:coWait(nCurCo, nSessionId, self._refer:getSelfCo())
	end
	const nClassType = assert(self._classType, "class type is not setted")
	return {nClassType}
end

function ClassReferCom:build(vGetter:Fn():Ret(class.UTypeTuple, class.MetaObject), vFactory:class.ClassFactory)
	-- step 1. get list
	const nParTuple, nInterface = vGetter()
	const nTable = vFactory:createLuaTable(self, nParTuple, self._refer, nInterface)
	self._interface = nInterface
	self._classType = nTable
	-- nClassType:linkNamedReference(self)
	for co, sid in pairs(self._waitClassCoToSid) do
		self._manager:coWakeup(co, sid)
	end
	const co = coroutine.running()
	self._manager:coWait(co, self._startSid)
	vFactory:runBuild()
end

function ClassReferCom:startBuild()
	const co = self._refer:getSelfCo()
	self._manager:coWakeup(co, self._startSid)
end

function ClassReferCom:waitBuild()
	const nCurCo = coroutine.running()
	const nSelfCo = self._refer:getSelfCo()
	if nCurCo ~= nSelfCo then
		const nWaitCoToSid = self._waitBuildCoToSid
		if nWaitCoToSid then
			const nSessionId = self._manager:genSessionId()
			nWaitCoToSid[nCurCo] = nSessionId
			self._manager:coWait(nCurCo, nSessionId, nSelfCo)
		end
	else
		-- assert(self._buildStep >= ClassFactory.STEP_POST_SELF)
	end
end

function ClassReferCom:_wakeupBuild()
	assert(coroutine.running() == self._refer:getSelfCo(), "can only setmetatable in constructor thread")
	const nWaitCoToSid = self._waitBuildCoToSid
	if nWaitCoToSid then
		for co, sid in pairs(nWaitCoToSid) do
			self._manager:coWakeup(co, sid)
		end
		self._waitBuildCoToSid = false
	end
end

function.open ClassReferCom.is(self):isguard(class.ClassReferCom)
	return getmetatable(self) == ClassReferCom
end

return ClassReferCom
