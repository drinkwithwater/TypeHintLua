
const Exception = require "thlua.Exception"

(@let.class = import("thlua.type.TypeClass").class)

const ClassReferCom = {}
ClassReferCom.__index=ClassReferCom

function:class(class.ClassReferCom) ClassReferCom.new(vManager:class.TypeManager, vRefer:class.Reference)
	const self = setmetatable({.class
		_manager=vManager,
		_refer=vRefer,
		_startSid=(vManager:genSessionId()@OrFalse(Integer)),
		_namedRefer=vRefer,
		_classType=false@OrFalse(class.LuaTable),
		_waitClassCoToSid={} @ Dict(Thread, Integer),
		_waitBuildCoToSid={}@OrFalse(Dict(Thread, Integer)),
	}, ClassReferCom)
	return self
end

function ClassReferCom:addReference(vRefer:class.Reference)
	if vRefer:getKey() and not self._namedRefer:getKey() then
		self._namedRefer = vRefer
	end
end

function ClassReferCom:getToString():Ret(String)
	return tostring(self._refer)
end

function ClassReferCom:getResultType():Ret(OrFalse(class.LuaTable))
	return self._classType
end

function ClassReferCom:getTypeAwait():Ret(class.UAtomUnion)
	if not self._classType then
		const nSessionId = self._manager:genSessionId()
		const nCurCo = coroutine.running()
		self._waitClassCoToSid[nCurCo] = nSessionId
		self._manager:coWait(nCurCo, nSessionId, self._refer:getSelfCo())
	end
	return (assert(self._classType, "result type not setted"))
end

function ClassReferCom:getMayRecursive():Ret(Boolean)
	return true
end

function ClassReferCom:getListAwait():Ret(List(class.IAtomType))
	if not self._classType then
		const nSessionId = self._manager:genSessionId()
		const nCurCo = coroutine.running()
		self._waitClassCoToSid[nCurCo] = nSessionId
		self._manager:coWait(nCurCo, nSessionId, self._refer:getSelfCo())
	end
	const nClassType = assert(self._classType, "class type is not setted")
	return {nClassType}
end

function ClassReferCom:build(vGetInterface:Fn():Ret(class.MetaObject), vContext:class.Context, vClassBuilder:Fn(class.LuaTable))
	-- step 1. wait inteface
	const nInterface = vGetInterface()
	vContext:recordDefineLuaFunction(self)
	-- step 2. create table
	const nNewTable = self._manager:LuaTable()
	nNewTable:initByClassCom(self, nInterface)
	self._classType = nNewTable
	-- nClassType:linkNamedReference(self)
	for co, sid in pairs(self._waitClassCoToSid) do
		self._manager:coWakeup(co, sid)
	end
	const nStartSid = self._startSid
	assert(nStartSid, "ClassReferCom error state... building startSid is not true value")
	const co = coroutine.running()
	self._manager:coWait(co, nStartSid)
	-- step 3. run build
	vClassBuilder(nNewTable)
	self:_wakeupBuild()
end

function ClassReferCom:startBuild()
	const nStartSid = self._startSid
	if nStartSid then
		self._startSid = false
		const co = self._refer:getSelfCo()
		self._manager:coWakeup(co, nStartSid)
	end
end

function ClassReferCom:onSetMetaTable()
	self:_wakeupBuild()
end

function ClassReferCom:waitBuild()
	self:startBuild()
	const nCurCo = coroutine.running()
	const nSelfCo = self._refer:getSelfCo()
	if nCurCo ~= nSelfCo then
		const nWaitCoToSid = self._waitBuildCoToSid
		if nWaitCoToSid then
			const nSessionId = self._manager:genSessionId()
			nWaitCoToSid[nCurCo] = nSessionId
			self._manager:coWait(nCurCo, nSessionId, nSelfCo)
		end
	end
end

function ClassReferCom:_wakeupBuild()
	assert(coroutine.running() == self._refer:getSelfCo(), "can only setmetatable in constructor thread")
	const nWaitCoToSid = self._waitBuildCoToSid
	if nWaitCoToSid then
		self._waitBuildCoToSid = false
		for co, sid in pairs(nWaitCoToSid) do
			self._manager:coWakeup(co, sid)
		end
	end
end

function.open ClassReferCom.is(self):isguard(class.ClassReferCom)
	return getmetatable(self) == ClassReferCom
end

return ClassReferCom
