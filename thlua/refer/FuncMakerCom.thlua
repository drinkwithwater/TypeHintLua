
const Exception = require "thlua.Exception"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const FuncMakerCom = {}
FuncMakerCom.__index=FuncMakerCom

function:class(clazz.FuncMakerCom) FuncMakerCom.new(vManager:clazz.TypeManager, vRefer:clazz.Reference)
	const self = setmetatable({.class
		_manager=vManager,
		_refer=vRefer,
		_startSid=(vManager:genSessionId()@OrFalse(Integer)),
		_typeFn=false@OrFalse(clazz.TypeFunction),
		_waitCoToSid={}@OrFalse(Dict(Thread, Integer)),
	}, FuncMakerCom)
	return self
end

function FuncMakerCom:build(vAutoTuple:clazz.AutoTuple, vRetTuples:clazz.RetTuples)
	const nStartSid = self._startSid
	assert(nStartSid, "FuncMakerCom error state... building startSid is not true value")
	const co = coroutine.running()
	self._manager:coWait(co, nStartSid)
	-- step 3. run build
	self:_wakeupBuild()
end

function FuncMakerCom:getFnWait():Ret(OrFalse(clazz.TypeFunction))
	const nTypeFn = self._typeFn
	if not nTypeFn then
		self:startBuild()
		const nSessionId = self._manager:genSessionId()
		const nCurCo = coroutine.running()
		const nWaitCoToSid = assert(self._waitCoToSid)
		nWaitCoToSid[nCurCo] = nSessionId
		self._manager:coWait(nCurCo, nSessionId, self._refer:getSelfCo())
	end
	return (assert(self._typeFn, "_typeFn must existed here"))
end

function FuncMakerCom:startBuild()
	const nStartSid = self._startSid
	if nStartSid then
		self._startSid = false
		const co = self._refer:getSelfCo()
		self._manager:coWakeup(co, nStartSid)
	end
end

function FuncMakerCom:_wakeupBuild()
	assert(coroutine.running() == self._refer:getSelfCo(), "can only setmetatable in constructor thread")
	const nWaitCoToSid = self._waitCoToSid
	if nWaitCoToSid then
		self._waitCoToSid = false
		for co, sid in pairs(nWaitCoToSid) do
			self._manager:coWakeup(co, sid)
		end
	end
end

function.open FuncMakerCom.is(self):isguard(clazz.FuncMakerCom)
	return getmetatable(self) == FuncMakerCom
end

return FuncMakerCom
