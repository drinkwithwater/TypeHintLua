
const BaseTask = require "thlua.refer.BaseTask"
const Exception = require "thlua.Exception"

const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const class = require "thlua.class"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const ISealFunction = class@<clazz.ISealFunction, false>()

function.open ISealFunction:ctor(vManager:clazz.TypeManager, vNode:clazz.IAstNode, vParentContext:OrFalse(clazz.BodyContext))
	self._manager = vManager
	const nRuntime = vManager:getRuntime()
	const nNewContext = nRuntime:SealContext(vNode, vParentContext)
	self._context = nNewContext
	const nTask = BaseTask.new(vManager, nNewContext)
	self._task = nTask
	self._node = vNode
	self._headStartEvent=nTask:makeWildEvent()
	self._headFinishEvent=nTask:makeEvent()
	self._bodyStartEvent=nTask:makeWildEvent()
	self._bodyFinishEvent=nTask:makeEvent()
	self._typeFn=false@OrFalse(clazz.TypeFunction)
end

function ISealFunction:meta_call(vContext:clazz.OperContext, vTermTuple:clazz.UTermTuple):Ret(clazz.RetTuples)
	const nTypeFn = self:getFnAwait()
	return nTypeFn:meta_call(vContext, vTermTuple)
end

function.pass ISealFunction:getFnAwait():Ret(clazz.TypeFunction)
	error("ISealFunction.getFnAwait is virtual function")
end

function ISealFunction:getAssignNode()
	return self._node
end

return ISealFunction
