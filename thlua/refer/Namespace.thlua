
const Exception = require "thlua.Exception"
const AsyncUnion = require "thlua.refer.AsyncUnion"
const StringLiteral = require "thlua.type.basic.StringLiteral"
const SpaceValue = require "thlua.refer.SpaceValue"
const SpaceBuiltin = require "thlua.refer.SpaceBuiltin"
const Node = require "thlua.code.Node"
const class = require "thlua.class"

(@do
	let.clazz = import($class).clazz
end)

const Namespace = class@<clazz.Namespace, clazz.ICompletion>()
Namespace.__tostring=function(self):Ret(String)
	return "namespace-" .. tostring(self._node).."|"..tostring(self._key or "!keynotset")
end

function.open Namespace:ctor(vManager:clazz.TypeManager, vNode:clazz.IBaseNode, vRefer:clazz.Reference, ...)
	self._manager=vManager
	self._key2child={} @ Dict(clazz.IAtomType, clazz.Reference) -- (vIndexTable and setmetatable({}, {__index=vIndexTable}) or {})@StringToRefer,
	self._closed=false@Boolean
	self._node=vNode
	self._key=false@Union(False, String)
	self._refer = vRefer
end

function Namespace:getChild(vNode:clazz.IBaseNode, vKeyType:clazz.IAtomType):Ret(clazz.Reference)
	local rawgetV = self._key2child[vKeyType]
	if not rawgetV then
		rawgetV = self._manager:Reference(tostring(vKeyType))
		rawgetV:pushReferNode(vNode)
		self._key2child[vKeyType] = rawgetV
	end
	return rawgetV
end

function Namespace:close()
	self._closed=true
end

function Namespace:putCompletion(vCompletion)
	for k,v in pairs(self._key2child) do
		if StringLiteral.is(k) then
			vCompletion:putSpaceField(k:getLiteral(), v)
		end
	end
end

function Namespace:getNode()
	return self._node
end

function Namespace:getRefer():Ret(clazz.Reference)
	return self._refer
end

return Namespace
