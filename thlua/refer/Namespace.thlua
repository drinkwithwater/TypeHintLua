
const Exception = require "thlua.Exception"
const Reference = require "thlua.refer.Reference"
const AsyncUnion = require "thlua.refer.AsyncUnion"
const StringLiteral = require "thlua.type.basic.StringLiteral"
const SpaceTable = require "thlua.refer.SpaceTable"
const SpaceBuiltin = require "thlua.refer.SpaceBuiltin"
const Node = require "thlua.code.Node"
const class = require "thlua.class"

(@do
	let.clazz = import($class).clazz
	clazz.LocalSpaceValue = Union(clazz.Reference, clazz.LocalSpaceTable)
end)

const Namespace = class@<clazz.Namespace, clazz.ICompletion>()
Namespace.__tostring=function(self):Ret(String)
	return "namespace-" .. tostring(self._node).."|"..tostring(self._key or "!keynotset")
end

function.open Namespace:ctor(vManager:clazz.TypeManager, vNode:clazz.IBaseNode, vIndexTable:OrNil(Dict(clazz.IAtomType, clazz.Reference)), ...)
	self._manager=vManager
	self._key2type={} @ Dict(clazz.IAtomType, clazz.LocalSpaceValue) -- (vIndexTable and setmetatable({}, {__index=vIndexTable}) or {})@StringToRefer,
	self._closed=false@Boolean
	self._node=vNode
	self._key=false@Union(False, String)
	self._localTable = SpaceTable.createTable(self)
	if vIndexTable then -- root space
		for k,v in pairs(vIndexTable) do
			self._key2type[k] = v
		end
	end
	return self
end

function Namespace:assertSpaceKeyType(vNode:clazz.IBaseNode, vKey:Any):Ret(clazz.IAtomType)
	const nOkay, nType = self._manager:getDirtyProcessor():peasyToMustType(vKey)
	if not nOkay then
		error(Exception.new(nType, vNode))
	end
	local nFinalKey = nType:checkAtomUnion()
	if not nFinalKey:isUnion() then
		return nFinalKey
	else
		error(Exception.new("namespace's key can't be union type", vNode))
	end
end

function Namespace:pureGet(vKeyType:clazz.IAtomType):Ret(OrNil(clazz.LocalSpaceValue))
	return self._key2type[vKeyType]
end

function Namespace:parentHasKey(vKeyType:clazz.IAtomType):Ret(Boolean)
	return false
end

function Namespace:triggerGet(vNode:clazz.IBaseNode, vKeyType:clazz.IAtomType):Ret(clazz.LocalSpaceValue)
	const rawgetV = self._key2type[vKeyType]
	if rawgetV then
		return rawgetV
	end
    if self:parentHasKey(vKeyType) then
        error(Exception.new("'let' can only get symbol in current level key="..tostring(vKeyType), vNode))
    end
	if self._closed then
		error(Exception.new("namespace closed, can't create key="..tostring(vKeyType), vNode))
	end
	const refer = self._manager:Reference(tostring(vKeyType))
	refer:pushReferNode(vNode)
	self._key2type[vKeyType] = refer
	return refer
end

function Namespace:triggerSet(vNode:clazz.IBaseNode, vKeyType:clazz.IAtomType, vNewValue:Any)
	if self._closed then
		error(Exception.new("namespace closed, can't create key="..tostring(vKeyType), vNode))
	end
	const rawgetV = self._key2type[vKeyType]
	if rawgetV then
		if Reference.is(rawgetV) then
			rawgetV:setAssignAsync(vNode, function() return vNewValue end)
		else
			error(Exception.new("assign conflict: key="..tostring(vKeyType), vNode))
		end
	else
		if self:parentHasKey(vKeyType) then
            error(Exception.new("'let' shadow set key="..tostring(vKeyType), vNode))
		end
		const nAssignSpace = SpaceTable.checkSpace(vNewValue)
		if nAssignSpace then
			nAssignSpace:trySetKey(tostring(vKeyType))
			self._key2type[vKeyType] = vNewValue @? clazz.LocalSpaceTable
		elseif SpaceBuiltin.is(vNewValue) then
            error(Exception.new("space-builtin function can't assign between space"..tostring(vKeyType), vNode))
		else
			const refer = self._manager:Reference(tostring(vKeyType))
			refer:setAssignAsync(vNode, function() return vNewValue end)
			self._key2type[vKeyType] = refer
		end
	end
end

function Namespace:trySetKey(vKey:String)
	if not self._key then
		self._key = vKey
	end
end

function Namespace:close()
	self._closed=true
end

function Namespace:spaceTablePutCompletion(vSpaceTable:clazz.BaseSpaceTable, vCompletion:clazz.FieldCompletion)
    const nWhat = getmetatable(vSpaceTable).__what
	if nWhat ~= "_G" then
		self:putCompletion(vCompletion)
	end
end

function Namespace:putCompletion(vCompletion)
	for k,v in pairs(self._key2type) do
		if StringLiteral.is(k) then
			vCompletion:putSpaceField(k:getLiteral(), v)
		end
	end
end

function Namespace:getNode()
	return self._node
end

function Namespace:getGlobalTable():Ret(OrFalse(clazz.GlobalSpaceTable))
	return false
end

function Namespace:getLocalTable():Ret(clazz.LocalSpaceTable)
	return self._localTable
end

SpaceTable.checkSpace = function.open (v):mapguard({[clazz.Namespace]=clazz.BaseSpaceTable})
	local nMeta = getmetatable(v)
	if type(nMeta) == "table" then
		local self = nMeta.__namespace
		if Namespace.is(self) then
			return self
		end
	end
	return nil
end

return Namespace
