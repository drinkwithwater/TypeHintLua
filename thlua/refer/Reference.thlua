
const Exception = require "thlua.Exception"
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const Node = require "thlua.code.Node"
-- const ReferState = require "thlua.refer.ReferState"

const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const BaseUnionType = require "thlua.type.union.BaseUnionType"

const AsyncUnion = require "thlua.refer.AsyncUnion"

const AsyncUnion = require "thlua.refer.AsyncUnion"
const TemplateReferCom = require "thlua.refer.TemplateReferCom"

const ScheduleEvent = require "thlua.manager.ScheduleEvent"

const ScheduleTask = require "thlua.manager.ScheduleTask"

const class = require "thlua.class"

(@do
	let.clazz = import($class).clazz
	let.UReferCom = Union(clazz.AsyncUnion, clazz.TemplateReferCom)
end)

const Reference = {}
Reference.__index = Reference
Reference.__call=function(self:clazz.TypeReference, ...:Any):Ret(clazz.TypeReference)
	-- TODO, cast
	const nNode = Node.newDebugNode()
	const nArgList:List(clazz.UAllType) = self._manager:getDirtyProcessor():easyToTypeList(nNode, ...)
	const nKey = self._manager:signTemplateArgs(nArgList)
	const nCom = self._com
	if TemplateReferCom.is(nCom) then
		return nCom:call(nNode, nKey, nArgList)
	elseif nCom then
		error(Exception.new("template reference expected here", nNode))
	end
	const nDict = self._callDict
	local nRefer = nDict[nKey]
	if not nRefer then
		nRefer = self._manager:Reference(false)
		nRefer:setAssignAsync(nNode, function()
			const nCom = self:waitTemplateCom()
			return nCom:call(nNode, nKey, nArgList)
		end)
		nDict[nKey] = nRefer
	end
	return nRefer
end

function Reference.__tostring(self:clazz.TypeReference):Ret(String)
	return self:detailString({}, false)
end

function Reference.__bor(vLeft:clazz.UAllType, vRight:clazz.UAllType):Ret(clazz.UAtomUnion)
	return vLeft._manager:checkedUnion(vLeft, vRight)
end

function Reference.__band(vLeft:clazz.UAllType, vRight:clazz.UAllType):Ret(clazz.UAtomUnion)
	const nTypeOrFalse = vLeft:safeIntersect(vRight)
	if nTypeOrFalse then
		return nTypeOrFalse
	else
		error("unexpected intersect")
	end
end

function:class(clazz.TypeReference) Reference.new(vManager:clazz.TypeManager, vKeyOrFalse:OrFalse(String)):implements(clazz.IType)
	const nTask = vManager:getScheduleManager():newTask()
	const self = setmetatable({.class
		_manager = vManager,
		_task = nTask,
		_key=vKeyOrFalse,
		_callDict={}@Dict(String, clazz.TypeReference),
		_assignNode=false@OrFalse(clazz.IBaseNode),
		_referNodes={}@List(clazz.IBaseNode),
		id=vManager:genTypeId(),
		bits=false,
		_assignComEvent = nTask:makeEvent(),
		_com=false@OrFalse(UReferCom),
	}, Reference)
	return self
end

function Reference:getKey():Ret(OrFalse(String))
	return self._key
end

function Reference:detailString(v, vVerbose)
	const nCom = self._com
	if not nCom then
		return "Reference("..(tostring(self._key) or tostring(self._assignNode))..")"
	else
		if AsyncUnion.is(nCom) then
			return "TypeReference("..tostring(nCom:getTypeNowait())..")"
		else
			return "TemplateReference("..(tostring(self._key) or tostring(self._assignNode))..")"
		end
	end
end

function Reference:getComNowait():Ret(OrFalse(UReferCom))
	return self._com
end

function Reference:getComAwait():Ret(UReferCom)
	if not self._com then
		self._assignComEvent:wait()
	end
	const nCom = assert(self._com, "com not setted after wait finish")
	return nCom
end

function Reference:waitTypeCom():Ret(Union(clazz.AsyncUnion))
	const nCom = self:getComAwait()
	assert(AsyncUnion.is(nCom), "type reference expected, but get template reference")
	return nCom
end

function Reference:waitTemplateCom():Ret(clazz.TemplateReferCom)
	const nCom = self:getComAwait()
	assert(TemplateReferCom.is(nCom), "template reference expected, but get some other reference")
	return nCom
end

function Reference:_setComAndWakeup(vCom:UReferCom)
	self._com = vCom
	self._assignComEvent:wakeup()
end

function Reference:setAssignAsync(vNode:clazz.IBaseNode, vGetFunc:Fn():Ret(Any))
	assert(not self._assignNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._assignNode = vNode
	self._task:runAsync(function()
		const nAssignValue = vGetFunc()
		if Reference.is(nAssignValue) then
			const nCom = nAssignValue:getComAwait()
			self:_setComAndWakeup(nCom)
		elseif BaseAtomType.is(nAssignValue) then
			const nCom = self._manager:AsyncUnion()
			nCom:setAssignAsync(vNode, nAssignValue)
			self:_setComAndWakeup(nCom)
		elseif BaseUnionType.is(nAssignValue) then
			const nCom = self._manager:AsyncUnion()
			nCom:setAssignAsync(vNode, nAssignValue)
			self:_setComAndWakeup(nCom)
		else
			error("namespace assign a non-type value")
		end
	end)
end

function Reference:setTemplateAsync(vNode:clazz.IBaseNode, vFunc:AnyFunction, vParNum:Integer)
	assert(not self._assignNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._assignNode = vNode
	const nCom = TemplateReferCom.new(self._manager, self, vFunc, vParNum)
	self._task:runAsync(function()
		self:_setComAndWakeup(nCom)
	end)
end

function Reference:setUnionAsync(
	vNode:clazz.IBaseNode,
	vGetList:Fn():Ret(List(clazz.IAtomType), OrNil(Fn():Ret(OrFalse(clazz.UAtomUnion))))
)
	assert(not self._assignNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._assignNode = vNode
	const nAsyncUnion = self._manager:AsyncUnion()
	self._task:runAsync(function()
		nAsyncUnion:setListAsync(vNode, vGetList())
	end)
	self:_setComAndWakeup(nAsyncUnion)
end

function Reference:getAssignNode():Ret(OrFalse(clazz.IBaseNode))
	return self._assignNode
end

function Reference:getReferNode():Ret(List(clazz.IBaseNode))
	return self._referNodes
end

function Reference:pushReferNode(vNode:clazz.IBaseNode)
	const nNodes = self._referNodes
	nNodes[#nNodes + 1] = vNode
end

function Reference:checkAtomUnion():Ret(clazz.UAtomUnion)
	return self:waitTypeCom():getTypeAwait()
end

function Reference:isReference():Ret(True)
	return true
end

function Reference:foreachAwait(vFunc)
	return self:waitTypeCom():foreachAwait(vFunc)
end

function Reference:intersectAtom(vRightType)
	return self:waitTypeCom():intersectAtom(vRightType)
end

function Reference:includeAtom(vRightType)
	return self:waitTypeCom():includeAtom(vRightType)
end

function Reference:assumeIntersectSome(vAssumeSet, vRight)
	return self:waitTypeCom():assumeIntersectSome(vAssumeSet, vRight)
end

function Reference:assumeIncludeAll(vAssumeSet, vRight, vSelfType)
	return self:waitTypeCom():assumeIncludeAll(vAssumeSet, vRight, vSelfType)
end

function Reference:unionSign()
	return tostring(self.id)
end

function Reference:safeIntersect(vRight)
	return self:waitTypeCom():safeIntersect(vRight)
end

function Reference:includeAll(vRight)
	return self:waitTypeCom():includeAll(vRight)
end

function Reference:intersectSome(vRight)
	return self:waitTypeCom():intersectSome(vRight)
end

function Reference:mayRecursive()
	return self:waitTypeCom():mayRecursive()
end

function.open Reference.is(v):isguard(clazz.TypeReference)
	return getmetatable(v) == Reference
end

return Reference
