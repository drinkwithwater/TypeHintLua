
const TypeClass = require "thlua.type.TypeClass"
const Exception = require "thlua.Exception"
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const Node = require "thlua.code.Node"

const TypeReferCom = require "thlua.refer.TypeReferCom"
const ClassFactory = require "thlua.refer.ClassFactory"
const TemplateReferCom = require "thlua.refer.TemplateReferCom"

const AutoFunction = require "thlua.refer.AutoFunction"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.UReferCom = Union(clazz.TypeReferCom, clazz.TemplateReferCom, clazz.ClassFactory, clazz.AutoFunction)
end)

const Reference = TypeClass()

Reference.__call=function(self:clazz.Reference, ...:Any):Ret(clazz.Reference)
	-- TODO, cast
	const nNode = Node.getDebugNode(3)
	const nArgList:List(clazz.UAllType) = self._manager:easyToTypeList(...)
	const nKey = self._manager:signTemplateArgs(nArgList)
	const nCom = self._com
	if TemplateReferCom.is(nCom) then
		return nCom:call(nNode, nKey, nArgList)
	elseif nCom then
		error(Exception.new("template reference expected here", nNode))
	end
	const nDict = self._callDict
	local nRefer = nDict[nKey]
	if not nRefer then
		nRefer = self._manager:Reference(false)
		nRefer:setAssignAsync(nNode, function()
			const nCom = self:waitTemplateCom()
			return nCom:call(nNode, nKey, nArgList)
		end)
		nDict[nKey] = nRefer
	end
	return nRefer
end

function:class(clazz.Reference) Reference.new(vManager:clazz.TypeManager, vKeyOrFalse:OrFalse(String)):impl(clazz.IType)
	local self = setmetatable({.class
		_manager=vManager,
		_key=vKeyOrFalse,
		_callDict={}@Dict(String, clazz.Reference),
		_assignNode=false@OrFalse(clazz.IAstNode),
		_referNodes={}@List(clazz.IAstNode),
		_com=false@OrFalse(let.UReferCom),
		_waitComCoToSid={} @ Dict(Thread, Integer),
		id=vManager:genTypeId(),
		bits=false,
		_selfCo=nil@Thread,
	}, Reference)
	self._selfCo = coroutine.create(function(vRunFn:Fn())
		const ok, nExc = pcall(vRunFn)
		if not ok then
			if Exception.is(nExc) then
				nExc:fixNode(self:getAssignNode())
				error(nExc)
			else
				error(Exception.new(tostring(nExc), self:getAssignNode()))
			end
		end
	end)
	return self
end

function Reference:getKey():Ret(OrFalse(String))
	return self._key
end

function Reference:getSelfCo():Ret(Thread)
	return self._selfCo
end

function Reference:detailString(v, vVerbose)
	return "Reference("..(tostring(self._key) or tostring(self._assignNode))..")"
end

function Reference:getComAwait():Ret(let.UReferCom)
	if not self._com then
		const nSessionId = self._manager:genSessionId()
		const nCurCo = coroutine.running()
		self._waitComCoToSid[nCurCo] = nSessionId
		self._manager:coWait(nCurCo, nSessionId, self._selfCo)
	end
	const nCom = assert(self._com, "com not setted after wait finish")
	return nCom
end

function Reference:waitTypeCom():Ret(Union(clazz.TypeReferCom, clazz.ClassFactory))
	const nCom = self:getComAwait()
	assert(not TemplateReferCom.is(nCom) and not AutoFunction.is(nCom), "type reference expected, but get template reference")
	return nCom
end

function Reference:waitTemplateCom():Ret(clazz.TemplateReferCom)
	const nCom = self:getComAwait()
	assert(TemplateReferCom.is(nCom), "template reference expected, but get some other reference")
	return nCom
end

function Reference:_setComAndWakeup(vCom:let.UReferCom)
	self._com = vCom
	for co, sid in pairs(self._waitComCoToSid) do
		self._manager:coWakeup(co, sid)
	end
end

function Reference:setAssignAsync(vNode:clazz.IAstNode, vGetFunc:Fn():Ret(Any))
	assert(not self._assignNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._assignNode = vNode
	self._manager:coStart(self._selfCo, function()
		const nOkay, nAssignValue = self._manager:pcheckNamespaceAssigValue(vGetFunc())
		if not nOkay then
			error("namespace assign a non-type value")
		end
		if Reference.is(nAssignValue) then
			const nCom = nAssignValue:getComAwait()
			self:_setComAndWakeup(nCom)
		else
			assert(not nAssignValue:isUnion(), "TODO assign Union to reference")
			const nCom = TypeReferCom.new(self._manager, self)
			self:_setComAndWakeup(nCom)
			nCom:build(function()
				return {nAssignValue}
			end)
		end
	end)
end

function Reference:setTemplateAsync(vNode:clazz.IAstNode, vFunc:AnyFunction, vParNum:Integer)
	assert(not self._assignNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._assignNode = vNode
	const nCom = TemplateReferCom.new(self._manager, self, vFunc, vParNum)
	self._manager:coStart(self._selfCo, function()
		self:_setComAndWakeup(nCom)
	end)
end

function Reference:setAutoFunction(
	vNode:clazz.IAstNode,
	vRunner:Fn():Ret(OrFalse(clazz.TypeFunction), Fn(clazz.AutoFunction):Ret(OrFalse(clazz.TypeFunction)))
):Ret(clazz.AutoFunction)
	assert(not self._assignNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._assignNode = vNode
	const nCom = AutoFunction.new(self._manager, self)
	self._manager:coStart(self._selfCo, function()
		self:_setComAndWakeup(nCom)
		nCom:build(vRunner)
	end)
	return nCom
end

function Reference:setClassFactory(
	vNode:clazz.IAstNode,
	vRunner:Fn():Ret(
		clazz.MetaObject,
		OrFalse(clazz.TypeFunction),
		Fn(clazz.ClassFactory, clazz.LuaTable):Ret(OrFalse(clazz.TypeFunction))
	)
):Ret(clazz.ClassFactory)
	assert(not self._assignNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._assignNode = vNode
	const nCom = ClassFactory.new(self._manager, self)
	self._manager:coStart(self._selfCo, function()
		self:_setComAndWakeup(nCom)
		-- nCom:build(vGetInterface, vClassBuilder)
		nCom:build(vRunner)
	end)
	return nCom
end

function Reference:setUnionAsync(vNode:clazz.IAstNode,
	vGetList:Fn():Ret(List(clazz.IAtomType)),
	vLaterCall:OrNil(Fn(clazz.UAtomUnion))
)
	assert(not self._assignNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._assignNode = vNode
	self._manager:coStart(self._selfCo, function()
		const nCom = TypeReferCom.new(self._manager, self)
		self:_setComAndWakeup(nCom)
		nCom:build(vGetList, vLaterCall)
	end)
end

function Reference:getAssignNode():Ret(OrFalse(clazz.IAstNode))
	return self._assignNode
end

function Reference:getReferNode():Ret(List(clazz.IAstNode))
	return self._referNodes
end

function Reference:pushReferNode(vNode:clazz.IAstNode)
	const nNodes = self._referNodes
	nNodes[#nNodes + 1] = vNode
end

function Reference:checkAtomUnion():Ret(clazz.UAtomUnion)
	return self:waitTypeCom():getTypeAwait()
end

function Reference:isReference():Ret(True)
	return true
end

function Reference:foreachAwait(vFunc)
	const nTypeCom = self:waitTypeCom()
	const nResultType = nTypeCom:getResultType()
	if nResultType then
		nResultType:foreach(vFunc)
	else
		local nListType = nTypeCom:getListAwait()
		for _, v in ipairs(nListType) do
			vFunc(v)
		end
	end
end

function Reference:intersectAtom(vRightType)
	const nType = self:waitTypeCom():getTypeAwait()
	return nType:intersectAtom(vRightType)
end

function Reference:containAtom(vRightType)
	const nType = self:waitTypeCom():getTypeAwait()
	return nType:containAtom(vRightType)
end

function Reference:assumeIntersectSome(vAssumeSet, vRight)
	const nTypeCom = self:waitTypeCom()
	const nResultType = nTypeCom:getResultType()
	if nResultType then
		return nResultType:assumeIntersectSome(vAssumeSet, vRight)
	else
		local nSomeIntersect:Boolean = false
		const nTypeList = nTypeCom:getListAwait()
		vRight:foreachAwait(function(vAtomType)
			if nSomeIntersect then
				return
			end
			local nCurIntersect:Boolean = false
			for _, nType in ipairs(nTypeList) do
				if nType:assumeIntersectAtom(vAssumeSet, vAtomType) then
					nCurIntersect = true
					break
				end
			end
			if nCurIntersect then
				nSomeIntersect = true
			end
		end)
		return nSomeIntersect
	end
end

function Reference:assumeIncludeAll(vAssumeSet, vRight)
	const nTypeCom = self:waitTypeCom()
	const nResultType = nTypeCom:getResultType()
	if nResultType then
		return nResultType:assumeIncludeAll(vAssumeSet, vRight)
	else
		local nAllInclude:Boolean = true
		const nTypeList = nTypeCom:getListAwait()
		vRight:foreachAwait(function(vAtomType)
			if not nAllInclude then
				return
			end
			local nCurInclude:Boolean = false
			for _, nType in ipairs(nTypeList) do
				if nType:assumeIncludeAtom(vAssumeSet, vAtomType) then
					nCurInclude = true
					break
				end
			end
			if not nCurInclude then
				nAllInclude = false
			end
		end)
		return nAllInclude
	end
end

function Reference:mayRecursive()
	const nTypeCom = self:waitTypeCom()
	nTypeCom:getListAwait()
	return nTypeCom:getMayRecursive()
end

function.open Reference.is(v):isguard(clazz.Reference)
	return getmetatable(v) == Reference
end

return Reference
