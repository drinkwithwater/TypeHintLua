
const Exception = require "thlua.Exception"
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const Node = require "thlua.code.Node"
const SpaceTable = require "thlua.refer.SpaceTable"
const StringLiteral = require "thlua.type.basic.StringLiteral"

const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const BaseUnionType = require "thlua.type.union.BaseUnionType"

const AsyncUnion = require "thlua.refer.AsyncUnion"

const AsyncUnion = require "thlua.refer.AsyncUnion"
const TemplateReferCom = require "thlua.refer.TemplateReferCom"

const ScheduleEvent = require "thlua.manager.ScheduleEvent"
const ScheduleTask = require "thlua.manager.ScheduleTask"

const HolderState = require "thlua.refer.HolderState"
const class = require "thlua.class"

(@do
	let.clazz = import($class).clazz
	let.UReferCom = Union(clazz.AsyncUnion, clazz.TemplateReferCom)
end)

const Reference = class@<clazz.Reference, clazz.ICompletion>(HolderState)
Reference.__call=function(self:clazz.Reference, ...:Any):Ret(clazz.AsyncUnion)
	-- TODO, cast
	const nNode = Node.newDebugNode()
	const nArgList = self._manager:getDirtyProcessor():easyToAllTypeList(nNode, ...)
	const nKey = self._manager:signTemplateArgs(nArgList)
	const nCom = self._com
	if TemplateReferCom.is(nCom) then
		return nCom:call(nNode, nKey, nArgList)
	elseif nCom then
		error(Exception.new("template reference expected here", nNode))
	end
	const nDict = self._callDict
	local nTypeCom = nDict[nKey]
	if not nTypeCom then
		nTypeCom = self._manager:AsyncUnion()
		nTypeCom:setTypeAsync(nNode, function()
			const nCom = self:waitTemplateCom()
			return nCom:call(nNode, nKey, nArgList)
		end)
		nDict[nKey] = nTypeCom
	end
	return nTypeCom
end

function Reference.__tostring(self:clazz.Reference):Ret(String)
	return "Reference tostring TODO"
end

function.open Reference:ctor(vManager:clazz.TypeManager, vKey:String)
	const nTask = vManager:getScheduleManager():newTask()
	self._task = nTask
	self._key=vKey
	self._callDict={}@Dict(String, clazz.AsyncUnion)
	self._assignNode=false@OrFalse(clazz.IBaseNode)
	self._referNodes={}@List(clazz.IBaseNode)
	self._assignComEvent = nTask:makeEvent()
	self._com=false@OrFalse(UReferCom)
end

function Reference:getComNowait():Ret(OrFalse(UReferCom))
	return self._com
end

function Reference:getComAwait():Ret(UReferCom)
	if not self._com then
		self._assignComEvent:wait()
	end
	const nCom = assert(self._com, "com not setted after wait finish")
	return nCom
end

function Reference:mustType():Ret(clazz.AsyncUnion)
	const nCom = self:getComAwait()
	assert(AsyncUnion.is(nCom), "type reference expected, but get template reference")
	return nCom
end

function Reference:waitTemplateCom():Ret(clazz.TemplateReferCom)
	const nCom = self:getComAwait()
	assert(TemplateReferCom.is(nCom), "template reference expected, but get some other reference")
	return nCom
end

function Reference:_setComAndWakeup(vCom:UReferCom)
	self._com = vCom
	self._assignComEvent:wakeup()
end

function Reference:setAssignAsync(vNode:clazz.IBaseNode, vGetFunc:Fn():Ret(Any))
	assert(not self._assignNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._assignNode = vNode
	self._task:runAsync(function()
		const nAssignValue = vGetFunc()
		if Reference.is(nAssignValue) then
			const nCom = nAssignValue:getComAwait()
			self:_setComAndWakeup(nCom)
		elseif TemplateReferCom.is(nAssignValue) then
			self:_setComAndWakeup(nAssignValue)
		elseif AsyncUnion.is(nAssignValue) then
			self:_setComAndWakeup(nAssignValue)
		else
			if BaseAtomType.is(nAssignValue) then
				const nCom = self._manager:AsyncUnion()
				nCom:setTypeAsync(vNode, function()
					return nAssignValue
				end)
				self:_setComAndWakeup(nCom)
			elseif BaseUnionType.is(nAssignValue) then
				const nCom = self._manager:AsyncUnion()
				nCom:setTypeAsync(vNode, function()
					return nAssignValue
				end)
				self:_setComAndWakeup(nCom)
			else
				error("namespace assign a non-type value")
			end
		end
	end)
end

function Reference:getAssignNode():Ret(OrFalse(clazz.IBaseNode))
	return self._assignNode
end

function Reference:getReferNode():Ret(List(clazz.IBaseNode))
	return self._referNodes
end

function Reference:putCompletion(vCompletion)
	for k,v in pairs(self._childDict) do
		if StringLiteral.is(k) then
			vCompletion:putSpaceField(k:getLiteral(), v)
		end
	end
end

function Reference:pushReferNode(vNode:clazz.IBaseNode)
	const nNodes = self._referNodes
	nNodes[#nNodes + 1] = vNode
end

return Reference
