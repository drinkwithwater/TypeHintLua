
const Exception = require "thlua.Exception"
const Node = require "thlua.code.Node"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
end)

const SpaceTable = {.open}

const function:class(clazz.BaseSpaceTable) __createBaseTable(vSpace:clazz.Namespace)
	-- abstract class
	return setmetatable({.class}, {
		__index={},
		__tostring=function(_)
			return tostring(vSpace).."->BaseSpaceTable"
		end,
		__what=false@OrFalse("_ENV", "_G"),
		__refer=vSpace,
	})
end

function:class(clazz.LocalSpaceTable) SpaceTable.createTable(vRefer:clazz.Reference):extends(clazz.BaseSpaceTable)
    return setmetatable({.class
    }, {
		__index=function(_:Truth,k:Any):Ret(clazz.LocalSpaceValue)
			const nNode = Node.newDebugNode()
			const nKeyType = vRefer:assertSpaceKeyType(nNode, k)
			return vRefer:triggerGet(nNode, nKeyType)
		end,
		__newindex=function(_:Truth,k:Any,newV:Any)
			const nNode = Node.newDebugNode()
			const nKeyType = vRefer:assertSpaceKeyType(nNode, k)
			vRefer:triggerSet(nNode, nKeyType, newV)
		end,
		__tostring=function(_)
			return tostring("TODO").."->SpaceTable"
		end,
		__what=false,
		__refer=vRefer,
    })
end

function:class(clazz.EnvSpaceTable) SpaceTable.createEnvTable(vRefer:clazz.Reference):extends(clazz.BaseSpaceTable)
    return setmetatable({.class
    }, {
		__index=function(_:Truth,k:Any):Ret(Union(clazz.Reference, clazz.LocalSpaceTable))
			const nNode = Node.newDebugNode()
			const nKeyType = vRefer:assertSpaceKeyType(nNode, k)
			return vRefer:globalGet(nNode, nKeyType)
		end,
		__newindex=function(t:Truth,k:Any,v:Any)
			const nNode = Node.newDebugNode()
			error(Exception.new("global can't assign", nNode))
		end,
		__tostring=function(_)
			return tostring(vRefer).."-_ENV"
		end,
		__what="_ENV",
		__refer=vRefer,
    })
end

function.open SpaceTable.checkSpace(v):mapguard({[clazz.Reference]=clazz.BaseSpaceTable})
	local nMeta = getmetatable(v)
	if type(nMeta) == "table" then
		local self = nMeta.__refer
		if self then
			return self
		end
	end
	return nil
end

return SpaceTable