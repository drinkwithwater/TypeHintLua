
const class = require "thlua.class"
const Exception = require "thlua.Exception"

(@let.clazz = import($class).clazz)

const TemplateReferCom = class@<clazz.TemplateReferCom, false>()

function.open TemplateReferCom:ctor(
	vManager:clazz.TypeManager,
	vNode:clazz.IBaseNode,
	vFunc:AnyFunction,
	vParNum:Integer
)
	self._manager=vManager
	self._node=vNode
	self._parNum=vParNum
	self._func=vFunc
	self._cache={}@Dict(String, clazz.AsyncUnion)
end

function TemplateReferCom:call(vNode:clazz.IBaseNode, vKey:String, vArgList:IList(clazz.UAllType)):Ret(clazz.AsyncUnion)
	const nDirtyProcessor = self._manager:getDirtyProcessor()
	const nFn = self._func
	local nTypeCom = self._cache[vKey]
	if not nTypeCom then
		nTypeCom = self._manager:AsyncUnion()
		self._cache[vKey] = nTypeCom
		nTypeCom:setTypeAsync(vNode, function()
			if #vArgList ~= self._parNum then
				error(Exception.new("template args num not match", vNode))
			end
			return nDirtyProcessor:easyToMustType(vNode, nFn(table.unpack(vArgList)))
		end)
	end
	return nTypeCom
end

return TemplateReferCom
