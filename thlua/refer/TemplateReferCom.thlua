
const class = require "thlua.class"
const Exception = require "thlua.Exception"
const BaseReadyType = require "thlua.type.basic.BaseReadyType"

(@let.clazz = import($class).clazz)

const TemplateReferCom = class@<clazz.TemplateReferCom, false>()

function.open TemplateReferCom:ctor(
	vManager:clazz.TypeManager,
	vNode:clazz.IBaseNode,
	vFunc:AnyFunction,
	vParNum:Integer
)
	self._manager=vManager
	self._node=vNode
	self._parNum=vParNum
	self._func=vFunc
	self._cache={}@Dict(String, clazz.AsyncUnion)
end

function TemplateReferCom:call(vNode:clazz.IBaseNode, vArgNum:Integer, vArgList:List(clazz.USpaceAny)):Ret(clazz.AsyncUnion)
	const nDirtyProcessor = self._manager:getDirtyProcessor()
	const nFn = self._func
	const nAsyncUnion = self._manager:AsyncUnion()
	nAsyncUnion:setTypeAsync(vNode, function()
		if vArgNum ~= self._parNum then
			error(Exception.new("template args num not match", vNode))
		end
		const nMustList:List(clazz.UMustType) = {}
		for i=1, vArgNum do
			nMustList[i] = nDirtyProcessor:easyToMustType(vNode, vArgList[i])
		end
		const nKey = self._manager:signTemplateArgs(nMustList)
		const nValue = self._cache[nKey]
		if not nValue then
			self._cache[nKey] = nAsyncUnion
			return nDirtyProcessor:easyToMustType(vNode, nFn(table.unpack(nMustList)))
		else
			return nValue
		end
	end)
	return nAsyncUnion
end

return TemplateReferCom
