
const Exception = require "thlua.Exception"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const TemplateReferCom = {}
TemplateReferCom.__index = TemplateReferCom

function:class(clazz.TemplateReferCom) TemplateReferCom.new(
	vManager:clazz.TypeManager,
	vRefer:clazz.TypeReference,
	vFunc:AnyFunction,
	vParNum:Integer
)
	const self = setmetatable({.class
		_manager=vManager,
		_refer=vRefer,
		_parNum=vParNum,
		_func=vFunc,
		_cache={}@Dict(String, clazz.TypeReference),
	}, TemplateReferCom)
	return self
end

function TemplateReferCom:call(vNode:clazz.IBaseNode, vKey:String, vArgList:List(clazz.UAllType)):Ret(clazz.TypeReference)
	const nFn = self._func
	local nRefer = self._cache[vKey]
	if not nRefer then
		nRefer = self._manager:Reference(false)
		nRefer:setAssignAsync(vNode, function()
			if #vArgList ~= self._parNum then
				error(Exception.new("template args num not match", vNode))
			end
			return nFn(table.unpack(vArgList))
		end)
		self._cache[vKey] = nRefer
	end
	return nRefer
end

function.open TemplateReferCom.is(self):isguard(clazz.TemplateReferCom)
	return getmetatable(self) == TemplateReferCom
end

return TemplateReferCom
