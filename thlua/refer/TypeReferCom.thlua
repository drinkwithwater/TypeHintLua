

const AsyncUnion = require "thlua.refer.AsyncUnion"
const Exception = require "thlua.Exception"

(@let.clazz = import("thlua.type.basic.TypeClass").clazz)

const TypeReferCom = {}
TypeReferCom.__index = TypeReferCom

function:class(clazz.TypeReferCom) TypeReferCom.new(
	vManager:clazz.TypeManager,
	vTask:clazz.ScheduleTask,
	vAssignType:Union(clazz.AsyncUnion, clazz.UAtomUnion)
)
	const nIsAsync = AsyncUnion.is(vAssignType)
	const self = setmetatable({.class
        _manager=vManager,
        _task=vTask,
		_asyncType=nIsAsync and vAssignType or false,
		_readyType=(not nIsAsync) and vAssignType or false,
	}, TypeReferCom)
	return self
end

function TypeReferCom:getTypeNowait():Ret(Union(clazz.AsyncUnion, clazz.UAtomUnion))
	return assert(self._readyType or self._asyncType)
end

function TypeReferCom:getTypeAwait():Ret(clazz.UAtomUnion)
	local nReadyType = self._readyType
	if not nReadyType then
		nReadyType = assert(self._asyncType):getTypeAwait()
		self._readyType = nReadyType
	end
	return nReadyType
end

function.open TypeReferCom.is(self):isguard(clazz.TypeReferCom)
	return getmetatable(self) == TypeReferCom
end

return TypeReferCom
