
const ScheduleTask = require "thlua.manager.ScheduleTask"
const class = require "thlua.class"
const Exception = require "thlua.Exception"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const UnionReferCom = class@<clazz.UnionReferCom, false>()

function.open UnionReferCom:ctor(vManager:clazz.TypeManager, vNode:clazz.IAstNode)
	const nTask = vManager:getRuntime():getScheduleManager():newTask()
	self._manager=vManager
	self._task = nTask
	self._node = vNode
	self._mayRecursive=false@Boolean
	self._typeList=false@OrFalse(List(clazz.IAtomType))
	self._resultType=false@OrFalse(clazz.UAtomUnion)
	self._listBuildEvent=nTask:makeEvent()
	self._resultBuildEvent=nTask:makeEvent()
end

function UnionReferCom:getToString():Ret(String)
	return tostring("union tostring TODO")
end

function UnionReferCom:getResultType():Ret(OrFalse(clazz.UAtomUnion))
	return self._resultType
end

function UnionReferCom:getTypeAwait():Ret(clazz.UAtomUnion)
	if not self._resultType then
		self._resultBuildEvent:wait()
	end
	return (assert(self._resultType, "result type not setted"))
end

function UnionReferCom:getMayRecursive():Ret(Boolean)
	return self._mayRecursive
end

function UnionReferCom:getListAwait():Ret(List(clazz.IAtomType))
	if not self._typeList then
		self._listBuildEvent:wait()
	end
	return (assert(self._typeList, "type list not setted"))
end

function UnionReferCom:_build(
	vGetList:Fn():Ret(List(clazz.IAtomType)),
	vLaterCall:OrNil(Fn(clazz.UAtomUnion))
)
	-- step 1. get list
	const nAtomList = vGetList()
	self._typeList = nAtomList
	for k, v in ipairs(nAtomList) do
		if v:mayRecursive() then
			self._mayRecursive = true
		end
	end
	self._listBuildEvent:wakeup()
	-- step 2. merge to result
	local nResultType:OrNil(clazz.UAtomUnion) = nil
	if #nAtomList == 0 then
		nResultType = self._manager.type.Never
	elseif #nAtomList == 1 then
		nResultType = nAtomList[1]!
	else
		local nCollection = self._manager:TypeCollection()
		for _, v in ipairs(nAtomList) do
			nCollection:put(v)
		end
		nResultType = nCollection:mergeToAtomUnion()
	end
	self._resultType = nResultType
	if not nResultType:isUnion() then
		nResultType:linkNamedReference(self)
	end
	self._resultBuildEvent:wakeup()
	-- step 3. later call
	if vLaterCall then
		vLaterCall(nResultType)
	end
end

function UnionReferCom:build(
	vGetList:Fn():Ret(List(clazz.IAtomType)),
	vLaterCall:OrNil(Fn(clazz.UAtomUnion))
)
	self._task:runAsync(function()
		self:_build(vGetList, vLaterCall)
	end)
end

function UnionReferCom:foreachAwait(vFunc:Fn(clazz.IAtomType))
	const nResultType = self._resultType
	if nResultType then
		nResultType:foreach(vFunc)
	else
		local nListType = self:getListAwait()
		for _, v in ipairs(nListType) do
			vFunc(v)
		end
	end
end

function UnionReferCom:getAssignNode():Ret(OrFalse(clazz.IAstNode))
	return self._node
end

function.open UnionReferCom.is(self):isguard(clazz.UnionReferCom)
	return getmetatable(self) == UnionReferCom
end

return UnionReferCom
