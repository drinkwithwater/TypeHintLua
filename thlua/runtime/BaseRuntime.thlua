
const TypedFunction = require "thlua.func.TypedFunction"
const TypeManager = require "thlua.manager.TypeManager"
const OpenFunction = require "thlua.func.OpenFunction"
const BaseAtomType = require "thlua.type.BaseAtomType"
const TermTuple = require "thlua.tuple.TermTuple"
const native = require "thlua.native"
const Node = require "thlua.code.Node"
const Namespace = require "thlua.manager.Namespace"
const Exception = require "thlua.Exception"
const VariableCase = require "thlua.term.VariableCase"

const BaseStack = require "thlua.runtime.BaseStack"
const OpenStack = require "thlua.runtime.OpenStack"
const SealStack = require "thlua.runtime.SealStack"
const AutoFunction = require "thlua.func.AutoFunction"

const ScheduleManager = require "thlua.manager.ScheduleManager"
const class = require "thlua.class"
const CodeEnv = require "thlua.code.CodeEnv"

(@do
	let.clazz = import($class).clazz
	let.node = import($Node).node

	clazz.FileLoader = Struct {
		thluaSearch=Fn(clazz.BaseRuntime, String):Ret(Boolean, String),
		thluaParseFile=Fn(clazz.BaseRuntime, String):Ret(clazz.CodeEnv),
		thluaGlobalFile=Fn(clazz.BaseRuntime, OrFalse(String)):Ret(clazz.CodeEnv),
	}

	clazz.Diagnostic = Struct {
		node=clazz.IAstNode,
		msg=String,
		severity=Union(1,2,3,4),
	}

	let.LoadedState = Struct {
		openFn=clazz.OpenFunction,
		codeEnv=clazz.CodeEnv,
		path=OrNil(String),
		term=OrNil(clazz.RefineTerm),
		stack=OrNil(clazz.BaseStack),
	}

end)

const DefaultLoader:clazz.FileLoader = {
	thluaSearch=function(vRuntime, vPath)
		local fileName, err1 = package.searchpath(vPath, vRuntime:getSearchPath() or "./?.thlua;./?.d.thlua")
		if not fileName then
			return false, err1
		end
		return true, fileName
	end,
	thluaParseFile=function.pass(vRuntime, vFileName)
		local file, err = io.open(vFileName, "r")
		if not file then
			error(err)
		end
		local nContent = assert(file:read("*a"), "file "..vFileName.. " read fail")
		file:close()
		const nCodeEnv = CodeEnv.new(nContent, vFileName)
		return nCodeEnv
	end,
	thluaGlobalFile=function.pass(vRuntime, vPackage)
		local nContent:OrNil(String) = nil
		if vPackage then
			nContent = require("thlua.global."..vPackage)
		else
			nContent = require("thlua.global.global")
		end
		const nCodeEnv = CodeEnv.new(nContent, "@virtual-file:"..(vPackage or "global"))
		return nCodeEnv
	end
}

const BaseRuntime = class@<clazz.BaseRuntime, false>()

function.open BaseRuntime:ctor(vLoader:OrNil(clazz.FileLoader))
	self._searchPath = false @ OrFalse(String)
	self._loader=vLoader or DefaultLoader
	self._spaceList={}@List(clazz.Namespace)
	self._pathToFileName={}@Dict(String, String)
	self._loadedDict={}@Dict(String, LoadedState)
	self._scheduleManager=ScheduleManager.new()
	-- late init fields
	self._node=nil@!node.Root
	self._manager=nil@!clazz.TypeManager
	self._globalTable=nil@!clazz.AutoTable
	self._rootStack=nil@!clazz.SealStack
end

function BaseRuntime:getCodeEnv(vFileName:String):Ret(OrFalse(clazz.CodeEnv))
	const nState = self._loadedDict[vFileName]
	if nState then
		return nState.codeEnv
	else
		return false
	end
end

function BaseRuntime:checkAtomUnionFinish()
	for _, space in pairs(self._spaceList) do
		space:check()
	end
end

function BaseRuntime:import(vDst:Truth):Ret(clazz.SpaceTable)
	-- TODO better style?
	if type(vDst) == "string" then
		const nPath = vDst @> String
		const nNode = Node.getDebugNode(3)
		const nLoadedState = self:_cacheLoadPath(Node.getDebugNode(3), nPath)
		const nStack = nLoadedState.stack
		if not nStack then
			error(Exception.new("recursive import:"..nPath, nNode))
		end
		const nSpace = nStack:getNamespace()
		return nSpace.localExport
	elseif BaseAtomType.is(vDst) then
		const nStack = vDst:findRequireStack()
		if nStack then
			const nSpace = nStack:getNamespace()
			return nSpace.localExport
		else
			error("import can only take type in a require stack"..debug.traceback())
		end
	else
		error("import can only take string or type as first argument")
	end
end

const nGlobalPackage:List(OrFalse(String)) = {
	"coroutine",
	"debug",
	"io",
	"math",
	"os",
	"package",
	"string",
	"table",
	"utf8",
	false,
}

function BaseRuntime:pmain(vRootFileUri:String):Ret(True):Ret(False, Union(String, clazz.Exception))
	self._node=Node.newRootNode(vRootFileUri)
	self._manager=TypeManager.new(self, self._node, self._scheduleManager)
	const nAutoFn = AutoFunction.new(self._manager, self._node, false)
	const nRootStack = nAutoFn:getBuildStack()
	self._rootStack = nRootStack
	self._manager:lateInit()
	self._globalTable = native.make(self)
	nRootStack:rootSetNamespace(self:RootNamespace())
	const t1 = os.clock()
	const ok, err = pcall(function():Err(clazz.Exception)
		nAutoFn:initAsync(function()
			for _, pkg in ipairs(nGlobalPackage) do
				const nCodeEnv = self._loader.thluaGlobalFile(self, pkg)
				const nOpenFn = nCodeEnv:getTypingFn()(nCodeEnv:getNodeList(), self._rootStack, self:makeGlobalTerm())
				const nContext = self._rootStack:newNoPushContext(self._node)
				const nTermTuple = nContext:FixedTermTuple({})
				const nReturn = nOpenFn:meta_open_call(nContext, nTermTuple, true)
				if pkg == "string" then
					const nRetTerm = TermTuple.is(nReturn) and nReturn:get(nContext, 1) or nReturn
					const nRetType = nRetTerm:getType()
					assert(not nRetType:isUnion(), "string lib's return can't be union")
					self._manager:lateInitStringLib(nRetType)
				end
			end
			return false, false, function()
				const nLoadedState = self:_cacheLoadFile(self._node, vRootFileUri)
				const nParTuple = self._manager:TypeTuple(self._node)
				const nRetTuples = self._manager:VoidRetTuples(self._node)
				return nParTuple, nRetTuples
			end
		end)
		nAutoFn:startPreBuild()
		nAutoFn:startLateBuild()
	end)
	if not ok then
		if Exception.is(err) then
			self:nodeError(err.node, err.msg)
		else
			self:nodeError(self._node, err)
		end
	end
	const t2 = os.clock()
	print(t2-t1)
	-- self:diffTestExpect()
	return ok, err
end

function BaseRuntime:lateSchedule(vAutoFn:clazz.AutoFunction)
	error("implement lateSchedule function in extends class")
end

function BaseRuntime:recordBranch(vNode:node.Block, vBranch:clazz.Branch)
	-- pass
end

function BaseRuntime:recordApplyContext(vNode:clazz.IAstNode, vContext:clazz.ApplyContext)
	-- pass
end

function BaseRuntime:SealStack(...):Ret(clazz.SealStack)
	return SealStack.new(self, ...)
end

function BaseRuntime:OpenStack(...):Ret(clazz.OpenStack)
	return OpenStack.new(self, ...)
end

function BaseRuntime:_cacheLoadFile(vNode:clazz.IAstNode, vFileName:String):Ret(LoadedState)
	local nLoadedState = self._loadedDict[vFileName]
	if not nLoadedState then
		const nCodeEnv = self._loader.thluaParseFile(self, vFileName)
		const nOpenFn = nCodeEnv:getTypingFn()(nCodeEnv:getNodeList(), self._rootStack, self:makeGlobalTerm())
		nLoadedState = {
			openFn=nOpenFn,
			codeEnv=nCodeEnv,
		}
		self._loadedDict[vFileName] = nLoadedState
		const nContext = self._rootStack:newNoPushContext(vNode)
		const nTermTuple = nContext:FixedTermTuple({})
		const nRet, nStack = nOpenFn:meta_open_call(nContext, nTermTuple, true)
		nLoadedState.term = TermTuple.is(nRet) and nRet:checkFixed(nContext, 1) or nRet:checkRefineTerm(nContext)
		nLoadedState.stack = nStack
	end
	return nLoadedState
end

function BaseRuntime:_cacheLoadPath(vNode:clazz.IAstNode, vPath:String):Ret(LoadedState)
	local nFileName = self._pathToFileName[vPath]
	if not nFileName then
		const nOkay, nSearchFileName = self._loader.thluaSearch(self, vPath)
		if not nOkay then
			error(Exception.new(nSearchFileName, vNode))
		else
			nFileName = nSearchFileName
		end
	end
	const nLoadedState = self._loadedDict[nFileName] or self:_cacheLoadFile(vNode, nFileName)
	const nOldPath = nLoadedState.path
	if nOldPath and nOldPath ~= vPath then
		self:nodeWarn(vNode, "mixing path:'"..nOldPath.."','"..vPath.."'")
	end
	nLoadedState.path = vPath
	return nLoadedState
end

function BaseRuntime:require(vNode:clazz.IAstNode, vPath:String):Ret(clazz.RefineTerm, clazz.OpenFunction)
	const nLoadedState = self:_cacheLoadPath(vNode, vPath)
	const nTerm = nLoadedState.term
	if not nTerm then
		error(Exception.new("recursive require:"..vPath, vNode))
	end
	return nTerm, nLoadedState.openFn
end

function BaseRuntime:TreeNamespace():Ret(clazz.Namespace)
	local nSpace = Namespace.new(self._manager, Node.getDebugNode(4))
	self._spaceList[#self._spaceList + 1] = nSpace
	return nSpace
end

function.pass BaseRuntime:buildSimpleGlobal():Ret(Truth)
	local nGlobal = {}
	for k,v in pairs(self._manager.type) do
		nGlobal[k] = v
	end
	for k,v in pairs(self._manager.generic) do
		nGlobal[k] = v
	end
	local l = {
		Union="buildUnion",
		Struct="buildStruct",
		Interface="buildInterface",
		ExtendInterface="buildExtendInterface",
		ExtendStruct="buildExtendStruct",
		Template="buildTemplate",
		--IDict="buildIDict",
		--IList="buildIList",
		--Dict="buildDict",
		--List="buildList",
		OrNil="buildOrNil",
		OrFalse="buildOrFalse",
		Fn="buildFn",
		Pfn="buildPfn",
		Mfn="buildMfn",
	}
	local nManager = self._manager
	for k,v in pairs(l) do
		nGlobal[k]=function(...)
			return nManager[v](nManager, Node.getDebugNode(3), ...)
		end
	end
	nGlobal.Literal=function(v)
		return nManager:Literal(v)
	end
	nGlobal.namespace=function()
		return self:TreeNamespace().localExport
	end
	nGlobal.lock=function(vType)
		vType:foreach(function(vAtom)
			vAtom:setLocked()
		end)
	end
	nGlobal.import=function(vPath)
		return self:import(vPath)
	end
	nGlobal.setPath=function(vPath)
		self._searchPath = vPath
	end
	nGlobal.foreachPair=function(vObject, vFunc)
		const vObject = vObject:checkAtomUnion()
		const d = vObject:copyValueDict(vObject)
		for k,v in pairs(d) do
			vFunc(k,v)
		end
	end
	for k,v in pairs(_G) do
		nGlobal[k]=v
	end
	nGlobal.print=function(...)
		self:nodeInfo(Node.getDebugNode(3), ...)
	end
	const nRetGlobal = {}
	for k,v in pairs(nGlobal) do
		nRetGlobal[self._manager:Literal(k)] = v
	end
	return nRetGlobal
end

function BaseRuntime:RootNamespace():Ret(clazz.Namespace)
	local nSpace = Namespace.new(self._manager, self._node, self:buildSimpleGlobal())
	self._spaceList[#self._spaceList + 1] = nSpace
	nSpace:trySetKey("")
	nSpace:close()
	return nSpace
end

function BaseRuntime:LetNamespace(vParentLet:clazz.Namespace, vRegionNode:clazz.IAstNode):Ret(clazz.Namespace)
	local nSpace = Namespace.new(self._manager, vRegionNode, vParentLet:getKeyToType())
	self._spaceList[#self._spaceList + 1] = nSpace
	nSpace:trySetKey("")
	return nSpace
end

function BaseRuntime:makeGlobalTerm():Ret(clazz.RefineTerm)
	const nHeadContext = self._rootStack:inplaceOper()
	return nHeadContext:RefineTerm(self._globalTable)
end

function BaseRuntime:_save(vSeverity:Union(1,2,3,4), vNode:clazz.IAstNode, ...:Truth)
	-- pass
end

function BaseRuntime:nodeError(vNode:clazz.IAstNode, ...:Truth)
	print("[ERROR] "..tostring(vNode), ...)
	self:_save(1, vNode, ...)
end

function BaseRuntime:nodeWarn(vNode:clazz.IAstNode, ...:Truth)
	print("[WARN] "..tostring(vNode), ...)
	self:_save(2, vNode, ...)
end

function BaseRuntime:nodeInfo(vNode:clazz.IAstNode, ...:Truth)
	print("[INFO] "..tostring(vNode), ...)
	self:_save(3, vNode, ...)
end

function BaseRuntime:getNode():Ret(clazz.IAstNode)
	return self._node
end

function BaseRuntime:getTypeManager():Ret(clazz.TypeManager)
	return self._manager
end

function BaseRuntime:getScheduleManager():Ret(clazz.ScheduleManager)
	return self._scheduleManager
end

function BaseRuntime:getRootStack():Ret(clazz.SealStack)
	return self._rootStack
end

function BaseRuntime:getSearchPath():Ret(OrFalse(String))
	return self._searchPath
end

return BaseRuntime
