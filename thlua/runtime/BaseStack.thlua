
const DoBuilder = require "thlua.builder.DoBuilder"
const Branch = require "thlua.runtime.Branch"
const DotsTail = require "thlua.tuple.DotsTail"
const AutoTail = require "thlua.auto.AutoTail"
const AutoHolder = require "thlua.auto.AutoHolder"
const AutoFlag = require "thlua.auto.AutoFlag"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"
const VariableCase = require "thlua.term.VariableCase"
const Exception = require "thlua.Exception"
const Reference = require "thlua.refer.Reference"
const Node = require "thlua.code.Node"
const LocalSymbol = require "thlua.term.LocalSymbol"
const ImmutVariable = require "thlua.term.ImmutVariable"

const ClassFactory = require "thlua.func.ClassFactory"
const AutoFunction = require "thlua.func.AutoFunction"
const OpenFunction = require "thlua.func.OpenFunction"
const BaseFunction = require "thlua.func.BaseFunction"
const MetaObject = require "thlua.object.MetaObject"
const Truth = require "thlua.type.Truth"

const FunctionBuilder = require "thlua.builder.FunctionBuilder"
const TableBuilder = require "thlua.builder.TableBuilder"
const class = require "thlua.class"

const OperContext = require "thlua.context.OperContext"
const ApplyContext = require "thlua.context.ApplyContext"
const ReturnContext = require "thlua.context.ReturnContext"
const AssignContext = require "thlua.context.AssignContext"
const MorePushContext = require "thlua.context.MorePushContext"
const OnePushContext = require "thlua.context.OnePushContext"
const NoPushContext = require "thlua.context.NoPushContext"
const LogicContext = require "thlua.context.LogicContext"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
end)

const BaseStack = class@<clazz.BaseStack, false>()

function.open BaseStack:ctor(
	vRuntime:clazz.Runtime,
	vNode:clazz.IAstNode,
	vUpValueCase:OrFalse(clazz.VariableCase),
	...
)
	const nManager = vRuntime:getTypeManager()
	self._runtime=vRuntime
	self._manager=nManager
	self._node=vNode
	self._namespace=false@OrFalse(clazz.Namespace)
	self._headContext=ApplyContext.new(vNode, self, nManager)
	self._fastOper=OperContext.new(vNode, self, nManager)
	const nRootBranch = Branch.new(self, vUpValueCase or VariableCase.new())
	self._curBranch=nRootBranch
	self._branchStack={self._curBranch}@List(clazz.Branch)
	self._bodyFn=nil@clazz.UBodyFunction
	self._retList={} @ List(clazz.FixedTermTuple)
end

function BaseStack:META_CALL(
	vNode:clazz.IAstNode,
	vFuncTerm:clazz.RefineTerm,
	vLazyFunc:Fn():Ret(clazz.UTermTuple)
):Ret(clazz.UOpenReturn)
	const nNil = self._manager.type.Nil
	return self:withMorePushContextWithCase(vNode, vFuncTerm, function(vContext, vFuncType, vCase)
		local nArgTermTuple:OrNil(clazz.UTermTuple) = nil
		self:_withBranch(vCase, function()
			nArgTermTuple = vLazyFunc()
		end)
		if vFuncType == nNil then
			self._runtime:nodeWarn(vNode, "nil as call func")
		elseif BaseFunction.is(vFuncType) or Truth.is(vFuncType) then
			vFuncType:meta_call(vContext, assert(nArgTermTuple))
		else
			self._runtime:nodeError(vNode, "TODO call by a not-function value, type="..tostring(vFuncType))
		end
	end)
end

--[[function.open BaseStack:nodePcall(vNode:clazz.IAstNode, vFunc, ...)
	const ok, err = xpcall(vFunc, function(exc:Union(String, clazz.Exception)):Ret(clazz.Exception)
		if Exception.is(exc) then
			return exc
		else
			print("[ERROR] "..tostring(vNode), tostring(exc))
			print(debug.traceback())
			return Exception.new("[FATAL]"..tostring(exc), vNode)
		end
	end, ...)
	if not ok then
		error(err)
	end
	return ok, err
end]]

function BaseStack:getClassTable():Ret(OrFalse(clazz.ClassTable))
	return self:getSealStack():getClassTable()
end

function BaseStack:newAutoFunction(vNode:clazz.IAstNode, ...):Ret(clazz.AutoFunction)
	const nAutoFn = AutoFunction.new(self._manager, vNode, self, ...)
	self:getSealStack():recordAutoFunction(nAutoFn)
	return nAutoFn
end

function BaseStack:newClassFactory(vNode:clazz.IAstNode, ...):Ret(clazz.ClassFactory)
	const nFactory = ClassFactory.new(self._manager, vNode, self, ...)
	self:getSealStack():recordClassFactory(nFactory)
	return nFactory
end

function BaseStack:newOpenFunction(vNode:clazz.IAstNode, vUpValueCase:OrNil(False, clazz.VariableCase)):Ret(clazz.OpenFunction)
	const nOpenFn = OpenFunction.new(self._manager, vNode, self, vUpValueCase)
	return nOpenFn
end

function BaseStack:withOnePushContext(vNode:clazz.IAstNode, vFunc:Fn(clazz.OnePushContext), vNotnil:OrNil(Boolean)):Ret(clazz.RefineTerm)
	const nCtx = OnePushContext.new(vNode, self, self._manager, vNotnil or false)
	vFunc(nCtx)
	nCtx:finish()
	return nCtx:mergeFirst()
end

function BaseStack:withMorePushContext(vNode:clazz.IAstNode, vFunc:Fn(clazz.MorePushContext)):Ret(clazz.UOpenReturn)
	const nCtx = MorePushContext.new(vNode, self, self._manager)
	vFunc(nCtx)
	nCtx:finish()
	return nCtx:mergeReturn()
end

function BaseStack:withMorePushContextWithCase(vNode:clazz.IAstNode, vTermOrTuple:Union(clazz.FixedTermTuple, clazz.RefineTerm), vFunc:Fn(clazz.MorePushContext, clazz.IAtomType, clazz.VariableCase)):Ret(clazz.UOpenReturn)
	const nCtx = MorePushContext.new(vNode, self, self._manager)
	const nTerm = TermTuple.isFixed(vTermOrTuple) and vTermOrTuple:checkFixed(nCtx, 1) or vTermOrTuple
	nTerm:foreach(function(vType, vCase)
		nCtx:withCase(vCase, function()
			vFunc(nCtx, vType, vCase)
		end)
	end)
	nCtx:finish()
	return nCtx:mergeReturn()
end

function BaseStack:withNoPushContext(vNode:clazz.IAstNode, vFunc:Fn(clazz.NoPushContext))
	const nCtx = NoPushContext.new(vNode, self, self._manager)
	vFunc(nCtx)
	nCtx:finish()
	return nCtx
end

function BaseStack:newLogicContext(vNode:clazz.IAstNode):Ret(clazz.LogicContext)
	return LogicContext.new(vNode, self, self._manager)
end

function BaseStack:newOperContext(vNode:clazz.IAstNode):Ret(clazz.OperContext)
	return OperContext.new(vNode, self, self._manager)
end

function BaseStack:newReturnContext(vNode:clazz.IAstNode):Ret(clazz.ReturnContext)
	return ReturnContext.new(vNode, self, self._manager)
end

function BaseStack:newAssignContext(vNode:clazz.IAstNode):Ret(clazz.AssignContext)
	return AssignContext.new(vNode, self, self._manager)
end

function.pass BaseStack:getSealStack():Ret(clazz.SealStack)
	error("getSealStack not implement in BaseStack")
end

function BaseStack:seal()
end

function BaseStack:_nodeTerm(vNode:clazz.IAstNode, vType:clazz.UAllType)
	return RefineTerm.new(vNode, vType:checkAtomUnion())
end

function BaseStack:inplaceOper()
	return self._fastOper
end

function BaseStack:getNamespace():Ret(clazz.Namespace)
	local nSpace = self._namespace
	return assert(nSpace, "space is false when get")
end

function BaseStack:error(...:Truth)
	self._runtime:nodeError(self._node, ...)
end

function BaseStack:warn(...:Truth)
	self._runtime:nodeWarn(self._node, ...)
end

function BaseStack:info(...:Truth)
	self._runtime:nodeInfo(self._node, ...)
end

function BaseStack:getNode():Ret(clazz.IAstNode)
	return self._node
end

function BaseStack:getRuntime():Ret(clazz.Runtime)
	return self._runtime
end

function BaseStack:getTypeManager():Ret(clazz.TypeManager)
	return self._manager
end

function BaseStack:_withBranch(vVariableCase:clazz.VariableCase, vFunc:Fn()):Ret(clazz.Branch)
	const nStack = self._branchStack
	const nNewLen = #nStack + 1
	const nOldBranch = self._curBranch
	const nNewBranch = Branch.new(self, vVariableCase, nOldBranch)
	nStack[nNewLen] = nNewBranch
	self._curBranch = nNewBranch
	vFunc()
	nStack[nNewLen] = nil
	self._curBranch = nOldBranch
	return nNewBranch
end

function BaseStack:_topBranch():Ret(clazz.Branch)
	return self._curBranch
end

function BaseStack:nativeError()
	self:_topBranch():setStop()
end

function BaseStack:nativeAssert(vTerm:clazz.RefineTerm)
	local nTrueCase = vTerm:caseTrue()
	if nTrueCase then
		self:_topBranch():assertCase(nTrueCase)
	end
end

function BaseStack:_bodyReturn(vContext:clazz.ReturnContext, vTypeTuple:clazz.UTypeTuple)
	const nBodyFn = self._bodyFn
	if AutoFunction.is(nBodyFn) then
		local nOneOkay = false
		local nRetTuples = nBodyFn:getRetTuples()
		if nRetTuples then
			nRetTuples:foreachWithFirst(function(vDstTuple, _)
				if vTypeTuple:castOrIn(vContext, vDstTuple) then
					nOneOkay = true
				end
			end)
			if not nOneOkay then
				vContext:error("return check failed")
			end
		else
			-- error("auto return TODO")
		end
	elseif ClassFactory.is(nBodyFn) then
		const nResultType = nBodyFn:getClassTable(true)
		if nResultType ~= vTypeTuple:get(1):checkAtomUnion() or #vTypeTuple ~= 1 or vTypeTuple:getRepeatType() then
			vContext:error("class return check failed")
		end
	end
end

function BaseStack:_bodyEnd(vNode:clazz.IAstNode, vTermTupleList:List(clazz.FixedTermTuple)):Ret(clazz.FixedTermTuple)
	const nBodyFn = self._bodyFn
	if OpenFunction.is(nBodyFn) or (AutoFunction.is(nBodyFn) and not nBodyFn:getRetTuples()) then
		local nLen = #vTermTupleList
		if nLen == 0 then
			return self._fastOper:FixedTermTuple({})
		elseif nLen == 1 then
			return vTermTupleList[1]!
		else
			error("TODO : open-function or auto-return-function has more than one return")
			--[[
			local retTermTuple = vTermTupleList[1]!
			for i=2,nLen do
				retTermTuple = retTermTuple | vTermTupleList[i]!
			end
			return retTermTuple]]
		end
	end
	return self._fastOper:FixedTermTuple({})
end

return BaseStack
