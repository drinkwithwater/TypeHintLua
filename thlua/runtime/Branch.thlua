
const VariableCase = require "thlua.term.VariableCase"
const RefineTerm = require "thlua.term.RefineTerm"

const Branch = {}

(@let.clazz = import("thlua.type.TypeClass").clazz)

Branch.__index = Branch
Branch.__tostring = function(self):Ret(String)
	return "Branch"
end

function:class(clazz.Branch) Branch.new(vContext:clazz.Context, vPreBranch:OrNil(clazz.Branch), vVariableCase:clazz.VariableCase)
	(@let.VariableDict = Dict(clazz.LocalSymbol, clazz.ImmutVariable))
	const self = setmetatable({.class
		_context=vContext,
		_stop=false@Boolean,
		_case=nil@clazz.VariableCase,
		symbolToVariable={}@VariableDict,
		_headCase=vVariableCase,
	}, Branch)
	self.symbolToVariable = (setmetatable({}, {__index=vPreBranch and vPreBranch.symbolToVariable})) @ VariableDict
	local nVariableCase:OrNil(clazz.VariableCase) = nil
	if vPreBranch then
		nVariableCase = vPreBranch:getCase() & vVariableCase
	else
		nVariableCase = vVariableCase
	end
	self._case=nVariableCase
	return self
end

function Branch:immutGet(vImmutVariable:clazz.ImmutVariable):Ret(clazz.RefineTerm)
	local nType = self._case[vImmutVariable]
	if nType then
		if not nType:isNever() then
			const nTerm = vImmutVariable:getTerm():filter(nType)
			nTerm:initVariable(vImmutVariable)
			return nTerm
		else
			print("TODO type is never when get symbol"..tostring(vImmutVariable))
			return self._context:NeverTerm()
		end
	else
		return vImmutVariable:getTerm()
	end
end

function Branch:mutGet(vLocalSymbol:clazz.LocalSymbol):Ret(clazz.RefineTerm)
	local nImmutVariable = self.symbolToVariable[vLocalSymbol]
	if not nImmutVariable then
		-- TODO, consider upvalue symbol??
		nImmutVariable = vLocalSymbol:makeVariable()
		self.symbolToVariable[vLocalSymbol] = nImmutVariable
	end
	return self:immutGet(nImmutVariable)
end

function Branch:mutMark(vSymbol:clazz.LocalSymbol, vImmutVariable:clazz.ImmutVariable)
	self.symbolToVariable[vSymbol] = vImmutVariable
	vImmutVariable:addSymbol(vSymbol)
end

function Branch:mutSet(vContext:clazz.Context, vSymbol:clazz.LocalSymbol, vValueTerm:clazz.RefineTerm)
	const nValueType = vValueTerm:getType()
	const nDstType = vSymbol:getType()
	const nCastType = vContext:castLuaType(nValueType, nDstType)
	if nCastType then
		const nCastTerm = vContext:RefineTerm(nCastType)
		const nImmutVariable = nCastTerm:attachImmutVariable()
		self.symbolToVariable[vSymbol] = nImmutVariable
		nImmutVariable:addSymbol(vSymbol)
	elseif vSymbol:getType():containAll(nValueType) then
		const nImmutVariable = vValueTerm:attachImmutVariable()
		self.symbolToVariable[vSymbol] = nImmutVariable
		nImmutVariable:addSymbol(vSymbol)
	else
		vContext:error(tostring(nValueType).." can't be assigned to "..tostring(vSymbol:getType()))
	end
end

function Branch:mergeOneBranch(vContext:clazz.Context, vOneBranch:clazz.Branch, vOtherCase:OrNil(clazz.VariableCase))
	if vOneBranch:getStop() then
		if vOtherCase then
			self._case = self._case & vOtherCase
			self._headCase = self._headCase & vOtherCase
		end
	else
		const nSymbolToVariable = self.symbolToVariable
		for nLocalSymbol, nOneVariable in pairs(vOneBranch.symbolToVariable) do
			const nBeforeVariable = nSymbolToVariable[nLocalSymbol]
			if nBeforeVariable then
				const nOneType = vOneBranch:mutGet(nLocalSymbol):getType()
				if not vOtherCase then
					nSymbolToVariable[nLocalSymbol] = nLocalSymbol:makeVariable(nOneType)
				else
					const nOtherType = vOtherCase[nBeforeVariable] or self._case[nBeforeVariable] or nBeforeVariable:getType()
					const nMergeType = nOneType | nOtherType
					nSymbolToVariable[nLocalSymbol] = nLocalSymbol:makeVariable(nMergeType)
				end
			end
		end
	end
end

function Branch:merge_from(vContext:clazz.Context, vTrueBranch:clazz.Branch, vFalseBranch:clazz.Branch)
	local nTrueStop = vTrueBranch:getStop()
	local nFalseStop = vFalseBranch:getStop()
	if nTrueStop and nFalseStop then
		self._stop = true
		return
	end
	local nModLocalSymbolDict:Dict(clazz.LocalSymbol, True) = {}
	for nLocalSymbol, _ in pairs(vTrueBranch.symbolToVariable) do
		nModLocalSymbolDict[nLocalSymbol] = true
	end
	for nLocalSymbol, _ in pairs(vFalseBranch.symbolToVariable) do
		nModLocalSymbolDict[nLocalSymbol] = true
	end
	for nLocalSymbol, _ in pairs(nModLocalSymbolDict) do
		if self.symbolToVariable[nLocalSymbol] then
			local nType:OrNil(clazz.UAtomUnion)
			if nFalseStop then
				nType = vTrueBranch:mutGet(nLocalSymbol):getType()
			elseif nTrueStop then
				nType = vFalseBranch:mutGet(nLocalSymbol):getType()
			else
				const nTrueType = vTrueBranch:mutGet(nLocalSymbol):getType()
				const nFalseType = vFalseBranch:mutGet(nLocalSymbol):getType()
				nType = nTrueType | nFalseType
			end
			local nImmutVariable = nLocalSymbol:makeVariable(nType)
			self.symbolToVariable[nLocalSymbol] = nImmutVariable
		end
	end
	local nAndCase:OrNil(clazz.VariableCase)
	if nFalseStop then
		nAndCase = vTrueBranch._headCase
	elseif nTrueStop then
		nAndCase = vFalseBranch._headCase
	end
	if nAndCase then
		self._case = self._case & nAndCase
		self._headCase = self._headCase & nAndCase
	end
end

function Branch:assertCase(vVariableCase:clazz.VariableCase)
	self._case = self._case & vVariableCase
	self._headCase = self._headCase & vVariableCase
end

function Branch:setStop()
	self._stop = true
end

function Branch:getCase():Ret(clazz.VariableCase)
	return self._case
end

function Branch:getStop():Ret(Boolean)
	return self._stop
end

return Branch
