
local TermCase = require "thlua.term.TermCase"
local UnionTerm = require "thlua.term.UnionTerm"

local Branch = {}

(@let.class = import("thlua.type.TypeClass").class)

Branch.__index = Branch
Branch.__tostring = function(self)::Ret(String)
	return "Branch"
end

function Branch.new(vContext:class.Context, vPreBranch:Option(class.Branch), vTermCase:Option(class.TermCase))::RetClass(class.Branch)
	local self = setmetatable({::Self()
		_context=vContext,
		_stop=false@Boolean,
		case=nil@class.TermCase,
		headCase=vTermCase,
		symbolToTerm=nil@Dict(class.Symbol,class.UnionTerm),
	}, Branch)
	self.symbolToTerm = setmetatable({}, {__index=vPreBranch and vPreBranch.symbolToTerm})
	local nTermCase
	if vPreBranch then
		if vTermCase then
			nTermCase = vPreBranch.case & vTermCase
		else
			nTermCase = vPreBranch.case
		end
	else
		nTermCase = TermCase.new()
	end
	self.case=nTermCase
	return self
end

function Branch:symbol_get(vSymbol:class.Symbol)::Ret(class.UnionTerm)
	local nUnionTerm = self.symbolToTerm[vSymbol]
	if not nUnionTerm then
		-- TODO, set upvalue symbol in prepre...prebranch
		local nType = vSymbol:getType()
		nUnionTerm = self._context:UnionTerm(nType)
		nUnionTerm:add_self(vSymbol)
		self.symbolToTerm[vSymbol] = nUnionTerm
		return nUnionTerm
	end
	local nType = self.case[nUnionTerm]
	if nType then
		if not nType:isNever() then
			return nUnionTerm:filter(nType)
		else
			print("TODO type is never when get symbol"..tostring(vSymbol), nUnionTerm)
			return self._context:NeverTerm()
		end
	else
		return nUnionTerm
	end
end

function Branch:symbol_init(vUnionSymbol:class.Symbol, vTerm:class.UnionTerm)
	self._context:getRuntime():recordSymbol(vUnionSymbol)
	vTerm:add_self(vUnionSymbol)
	self.symbolToTerm[vUnionSymbol] = vTerm
end

function Branch:symbol_set(vUnionSymbol:class.Symbol, vValueTerm:class.UnionTerm)
	local nValueType = vValueTerm:getType()
	if vUnionSymbol:getType():contain(nValueType) then
		local nUnionTerm = self._context:UnionTerm(nValueType)
		nUnionTerm:add_self(vUnionSymbol)
		self.symbolToTerm[vUnionSymbol] = nUnionTerm
	else
		print(tostring(nValueType).." can't be assigned to "..tostring(vUnionSymbol:getType()))
	end
end

function Branch:merge_from(vContext:class.UContext, vTrueBranch:class.Branch, vFalseBranch:class.Branch)
	local nModSymbolDict:Dict(class.Symbol, True) = {}
	local nTrueStop = vTrueBranch:getStop()
	for nSymbol, nUnion in pairs(vTrueBranch.symbolToTerm) do
		nModSymbolDict[nSymbol] = true
	end
	local nFalseStop = vFalseBranch:getStop()
	for nSymbol, nUnion in pairs(vFalseBranch.symbolToTerm) do
		nModSymbolDict[nSymbol] = true
	end
	if (not nTrueStop) or (not nFalseStop) then
		for nSymbol, _ in pairs(nModSymbolDict) do
			if self.symbolToTerm[nSymbol] then
				local nType
				if nFalseStop then
					nType = vTrueBranch:symbol_get(nSymbol):getType()
				elseif nTrueStop then
					nType = vFalseBranch:symbol_get(nSymbol):getType()
				else
					local nTrueType = vTrueBranch:symbol_get(nSymbol):getType()
					local nFalseType = vFalseBranch:symbol_get(nSymbol):getType()
					nType = nTrueType | nFalseType
				end
				local nUnionTerm = self._context:UnionTerm(nType)
				self.symbolToTerm[nSymbol] = nUnionTerm
				nUnionTerm:add_self(nSymbol)
			end
		end
		local nAndCase
		if nFalseStop then
			nAndCase = vTrueBranch.headCase
		elseif nTrueStop then
			nAndCase = vFalseBranch.headCase
		end
		if nAndCase then
			self.case = self.case & nAndCase
			self.headCase = self.headCase & nAndCase
		end
	else
		nAndCase = vTrueBranch.headCase & vFalseBranch.headCase
		self.case = self.case & nAndCase
		self.headCase = self.headCase & nAndCase
		self._stop = true
	end
end

function Branch:setStop()
	self._stop = true
end

function Branch:getStop()::Ret(Boolean)
	return self._stop
end

return Branch
