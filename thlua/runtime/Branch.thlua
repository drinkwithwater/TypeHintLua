
const TermCase = require "thlua.term.TermCase"
const RefineTerm = require "thlua.term.RefineTerm"

const Branch = {}

(@let.class = import("thlua.type.TypeClass").class)

Branch.__index = Branch
Branch.__tostring = function(self)::Ret(String)
	return "Branch"
end

function Branch.new(vContext:class.Context, vPreBranch:OrNil(class.Branch), vTermCase:OrNil(class.TermCase))::RetClass(class.Branch)
	const self = setmetatable({::Self()
		_context=vContext,
		_stop=false@Boolean,
		case=nil@class.TermCase,
		headCase=vTermCase,
		symbolToShot=nil@Dict(class.LocalSymbol, class.ImmutShot),
	}, Branch)
	self.symbolToShot = setmetatable({}, {__index=vPreBranch and vPreBranch.symbolToShot})
	local nTermCase:OrNil(class.TermCase) = nil
	if vPreBranch then
		if vTermCase then
			nTermCase = vPreBranch.case & vTermCase
		else
			nTermCase = vPreBranch.case
		end
	else
		nTermCase = TermCase.new()
	end
	self.case=nTermCase
	return self
end

function Branch:immutGet(vImmutShot:class.ImmutShot)::Ret(class.RefineTerm)
	local nType = self.case[vImmutShot]
	if nType then
		if not nType:isNever() then
			const nTerm = self._context:RefineTerm(nType)
			nTerm:initShot(vImmutShot)
			return nTerm
		else
			print("TODO type is never when get symbol"..tostring(vImmutShot))
			return self._context:NeverTerm()
		end
	else
		return vImmutShot:getTerm()
	end
end

function Branch:mutGet(vLocalSymbol:class.LocalSymbol)::Ret(class.RefineTerm)
	local nImmutShot = self.symbolToShot[vLocalSymbol]
	if not nImmutShot then
		-- TODO, consider upvalue symbol??
		nImmutShot = vLocalSymbol:makeShot()
		self.symbolToShot[vLocalSymbol] = nImmutShot
	end
	return self:immutGet(nImmutShot)
end

function Branch:mutMark(vSymbol:class.LocalSymbol, vImmutShot:class.ImmutShot)
	self.symbolToShot[vSymbol] = vImmutShot
	vImmutShot:addSymbol(vSymbol)
end

function Branch:mutSet(vNode:class.AstNode, vSymbol:class.LocalSymbol, vValueTerm:class.RefineTerm)
	const nValueType = vValueTerm:getType()
	const nDstType = vSymbol:getType()
	if self._context:cast(nValueType, nDstType) or vSymbol:getType():containAll(nValueType) then
		const nImmutShot = vValueTerm:attachImmutShot()
		self.symbolToShot[vSymbol] = nImmutShot
		nImmutShot:addSymbol(vSymbol)
	else
		self._context:getRuntime():nodeError(vNode, tostring(nValueType).." can't be assigned to "..tostring(vSymbol:getType()))
	end
end

function Branch:merge_from(vContext:class.Context, vTrueBranch:class.Branch, vFalseBranch:class.Branch)
	local nModLocalSymbolDict:Dict(class.LocalSymbol, True) = {}
	local nTrueStop = vTrueBranch:getStop()
	for nLocalSymbol, _ in pairs(vTrueBranch.symbolToShot) do
		nModLocalSymbolDict[nLocalSymbol] = true
	end
	local nFalseStop = vFalseBranch:getStop()
	for nLocalSymbol, _ in pairs(vFalseBranch.symbolToShot) do
		nModLocalSymbolDict[nLocalSymbol] = true
	end
	if (not nTrueStop) or (not nFalseStop) then
		for nLocalSymbol, _ in pairs(nModLocalSymbolDict) do
			if self.symbolToShot[nLocalSymbol] then
				local nType:OrNil(class.UAtomUnion)
				if nFalseStop or not vFalseBranch.headCase then
					nType = vTrueBranch:mutGet(nLocalSymbol):getType()
				elseif nTrueStop or not vTrueBranch.headCase then
					nType = vFalseBranch:mutGet(nLocalSymbol):getType()
				else
					local nTrueType = vTrueBranch:mutGet(nLocalSymbol):getType()
					local nFalseType = vFalseBranch:mutGet(nLocalSymbol):getType()
					nType = nTrueType | nFalseType
				end
				local nImmutShot = nLocalSymbol:makeShot(nType)
				self.symbolToShot[nLocalSymbol] = nImmutShot
			end
		end
		local nAndCase:OrNil(class.TermCase)
		if nFalseStop then
			nAndCase = vTrueBranch.headCase
		elseif nTrueStop then
			nAndCase = vFalseBranch.headCase
		end
		if nAndCase then
			self.case = self.case & nAndCase
			self.headCase = self.headCase & nAndCase
		end
	else
		local nAndCase = vTrueBranch.headCase & vFalseBranch.headCase
		self.case = self.case & nAndCase
		self.headCase = self.headCase & nAndCase
		self._stop = true
	end
end

function Branch:assertCase(vTermCase:class.TermCase)
	self.case = self.case & vTermCase
	self.headCase = self.headCase & vTermCase
end

function Branch:setStop()
	self._stop = true
end

function Branch:getStop()::Ret(Boolean)
	return self._stop
end

return Branch
