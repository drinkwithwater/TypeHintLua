
const BaseRuntime = require "thlua.runtime.BaseRuntime"
const class = require "thlua.class"

(@do
	let.clazz=import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
	let.InjectFn = import("thlua.code.TriggerCode").InjectFn
end)

const CompletionRuntime = class@<clazz.CompletionRuntime, false>(BaseRuntime)

function.open CompletionRuntime:ctor(...)
	self._focusNodeSet = {} @ Dict(node.Function, True)
	self._nodeToBranch = {} @ Dict(node.Block, clazz.Branch)
end

function CompletionRuntime:getFocusNodeSet():Ret(Dict(node.Function, True))
	return self._focusNodeSet
end

function CompletionRuntime:recordBranch(vNode:node.Block, vBranch:clazz.Branch)
	self._nodeToBranch[vNode] = vBranch
end

function CompletionRuntime:focus(vPos:Integer, vCurEnv:clazz.CodeEnv, vFn:InjectFn)
	const nBlockNode, nFuncList = vCurEnv:traceBlock(vPos)
	if not nBlockNode then
		return
	end
	const nSet = self._focusNodeSet
	for k,v in pairs(nFuncList) do
		nSet[v] = true
	end
	self._rootStack:reSchedule()
	for nBlock, nBranch in pairs(self._nodeToBranch) do
		const nStack = nBranch:getStack()
		const nOpenFn = vFn(nStack, function(vIdent)
			const nName = vIdent[1]
			local nDefineIdent = nBlockNode.symbolTable[nName]
			while nDefineIdent and nDefineIdent.pos > vPos do
				nDefineIdent = nDefineIdent.lookupIdent
			end
			if nDefineIdent then
				print("TODO use branch")
				return nStack:SYMBOL_GET(vIdent, nDefineIdent, false)
			end
			const nName = "_ENV"
			local nDefineIdent = nBlockNode.symbolTable[nName]
			while nDefineIdent and nDefineIdent.pos > vPos do
				nDefineIdent = nDefineIdent.lookupIdent
			end
			if nDefineIdent then
				return nStack:GLOBAL_GET(vIdent, nDefineIdent)
			end
			return nStack:NIL_TERM(vIdent)
		end)
	end
end

return CompletionRuntime
