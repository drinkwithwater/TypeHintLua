
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"
const BaseRuntime = require "thlua.runtime.BaseRuntime"
const class = require "thlua.class"

(@do
	let.clazz=import("thlua.type.TypeClass").clazz
	let.node = import("thlua.code.Node").node
	let.InjectFn = import("thlua.code.TriggerCode").InjectFn
	let.lsp=import("thlua.server.protocol").lsp
end)

const CompletionRuntime = class@<clazz.CompletionRuntime, false>(BaseRuntime)

function.open CompletionRuntime:ctor(...)
	self._focusNodeSet = {} @ Dict(node.Function, True)
	self._nodeToBranch = {} @ Dict(node.Block, List(clazz.Branch))
end

function CompletionRuntime:getFocusNodeSet():Ret(Dict(node.Function, True))
	return self._focusNodeSet
end

function CompletionRuntime:recordBranch(vNode:node.Block, vBranch:clazz.Branch)
	local nList = self._nodeToBranch[vNode]
	if not nList then
		nList = {vBranch}
		self._nodeToBranch[vNode] = nList
	else
		nList[#nList + 1] = vBranch
	end
end

function CompletionRuntime:injectType(vServer:lsp.FastServer, vTracePos:Integer, vBlockNode:node.Block, vFuncList:List(node.Function), vFn:InjectFn):Ret(clazz.UAtomUnion)
	-- 1. set focus functions
	const nSet = self._focusNodeSet
	for k,v in pairs(vFuncList) do
		nSet[v] = true
	end
	-- 2. schedule to activate block & function
	self._rootStack:reSchedule()
	const nBranchList = self._nodeToBranch[vBlockNode]
	if not nBranchList then
		return self._manager.type.Never
	end
	-- 3. run inject fn in each branches
	const nCollection = self._manager:TypeCollection()
	for _, nBranch in pairs(nBranchList) do
		const nStack = nBranch:getStack()
		const nOpenFn = vFn(nStack, function(vIdent)
			-- 1. lookup local symbol
			const nName = vIdent[1]
			local nDefineIdent = vBlockNode.symbolTable[nName]
			while nDefineIdent and nDefineIdent.pos > vTracePos do
				nDefineIdent = nDefineIdent.lookupIdent
			end
			if nDefineIdent then
				const nAutoTerm = nBranch:SYMBOL_GET(vIdent, nDefineIdent, false)
				if RefineTerm.is(nAutoTerm) then
					return nAutoTerm
				else
					return nStack:NIL_TERM(vIdent)
				end
			end
			-- 2. lookup global symbol
			const nName = "_ENV"
			local nDefineIdent = vBlockNode.symbolTable[nName]
			while nDefineIdent and nDefineIdent.pos > vTracePos do
				nDefineIdent = nDefineIdent.lookupIdent
			end
			if nDefineIdent then
				const nEnvTerm = nBranch:SYMBOL_GET(vIdent, nDefineIdent, false)
				assert(RefineTerm.is(nEnvTerm), "auto can't be used here")
				const nAutoTerm = nStack:META_GET(vIdent, nEnvTerm, nStack:LITERAL_TERM(vIdent, vIdent[1]), false)
				if RefineTerm.is(nAutoTerm) then
					return nAutoTerm
				else
					return nStack:NIL_TERM(vIdent)
				end
			else
				return nStack:NIL_TERM(vIdent)
			end
		end)
		const nContext = self._rootStack:newNoPushContext(self._node)
		const nTermTuple = nContext:FixedTermTuple({})
		const nRet, nStack = nOpenFn:meta_open_call(nContext, nTermTuple)
		const nRetTerm = TermTuple.is(nRet) and nRet:checkFixed(nContext, 1) or nRet:checkRefineTerm(nContext)
		nCollection:put(nRetTerm:getType())
	end
	return nCollection:mergeToAtomUnion()
end

return CompletionRuntime
