
const CodeEnv = require "thlua.code.CodeEnv"
const FieldCompletion = require "thlua.context.FieldCompletion"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"
const BaseRuntime = require "thlua.runtime.BaseRuntime"
const Namespace = require "thlua.refer.Namespace"
const SpaceTable = require "thlua.refer.SpaceTable"
const ListDict = require "thlua.manager.ListDict"
const TypeReference = require "thlua.refer.Reference"
const BaseUnionType = require "thlua.union.BaseUnionType"
const BaseAtomType = require "thlua.type.BaseAtomType"
const class = require "thlua.class"

(@do
	let.clazz=import($class).clazz
	let.node = import("thlua.code.Node").node
	let.InjectFn = import("thlua.code.CodeEnv").InjectFn
end)

const CompletionRuntime = class@<clazz.CompletionRuntime, false>(BaseRuntime)

function.open CompletionRuntime:ctor(...)
	self._focusNodeSet = {} @ Dict(clazz.IAstNode, True)
	self._nodeToAutoFnList = ListDict@<clazz.IAstNode, clazz.AutoFunction>()
	self._nodeToBranchList = ListDict@<node.Block, clazz.Branch>()
	self._nodeToApplyContextList = ListDict@<clazz.IAstNode, clazz.ApplyContext>()
end

function CompletionRuntime:lateSchedule(vAutoFn:clazz.AutoFunction)
	if self._focusNodeSet[vAutoFn:getNode()] then
		vAutoFn:startLateBuild()
	else
		self._nodeToAutoFnList:putOne(vAutoFn:getNode(), vAutoFn)
	end
end

function.pass CompletionRuntime:_save(vSeverity:Union(1,2,3,4), vNode:clazz.IAstNode, ...:Truth)
	--const nServer = self._loader
	--nServer:info(vNode, ...)
end

function CompletionRuntime:recordBranch(vNode:node.Block, vBranch:clazz.Branch)
	self._nodeToBranchList:putOne(vNode, vBranch)
end

function CompletionRuntime:recordApplyContext(vNode:clazz.IAstNode, vContext:clazz.ApplyContext)
	self._nodeToApplyContextList:putOne(vNode, vContext)
end

function CompletionRuntime:focusSchedule(vFuncList:List(node.Function))
	-- 1. set focus functions
	const nSet = self._focusNodeSet
	const nAutoFnList:List(clazz.AutoFunction) = {}
	for _,nNode in pairs(vFuncList) do
		nSet[nNode] = true
		const nList = self._nodeToAutoFnList:pop(nNode)
		if nList then
			for i=1,#nList do
				nAutoFnList[#nAutoFnList + 1] = nList[i]
			end
		end
	end
	for _, nAutoFn in ipairs(nAutoFnList) do
		nAutoFn:startLateBuild()
	end
end

function CompletionRuntime:_injectForeach(vTracePos:Integer, vBlockNode:node.Block, vFn:InjectFn, vCallback:Fn(Union(clazz.RefineTerm, clazz.UAllType, clazz.BaseSpaceTable)))
	const nBranchList = self._nodeToBranchList:get(vBlockNode)
	if not nBranchList then
		return
	end
	-- 3. run inject fn in each branches
	for _, nBranch in pairs(nBranchList) do
		const nStack = nBranch:getStack()
		const nResult = vFn(nStack, function(vIdent)
			-- 1. lookup local symbol
			const nName = vIdent[1]
			local nDefineIdent = vBlockNode.symbolTable[nName]
			while nDefineIdent and nDefineIdent.pos > vTracePos do
				nDefineIdent = nDefineIdent.lookupIdent
			end
			if nDefineIdent then
				const nAutoTerm = nBranch:SYMBOL_GET(vIdent, nDefineIdent, false)
				if RefineTerm.is(nAutoTerm) then
					return nAutoTerm
				else
					return nStack:NIL_TERM(vIdent)
				end
			end
			-- 2. lookup global symbol
			const nName = "_ENV"
			local nDefineIdent = vBlockNode.symbolTable[nName]
			while nDefineIdent and nDefineIdent.pos > vTracePos do
				nDefineIdent = nDefineIdent.lookupIdent
			end
			if nDefineIdent then
				const nEnvTerm = nBranch:SYMBOL_GET(vIdent, nDefineIdent, false)
				assert(RefineTerm.is(nEnvTerm), "auto can't be used here")
				const nAutoTerm = nStack:META_GET(vIdent, nEnvTerm, nStack:LITERAL_TERM(vIdent, vIdent[1]), false)
				if RefineTerm.is(nAutoTerm) then
					return nAutoTerm
				else
					return nStack:NIL_TERM(vIdent)
				end
			else
				return nStack:NIL_TERM(vIdent)
			end
		end)
		if RefineTerm.is(nResult) then
			vCallback(nResult)
		else
			if TypeReference.is(nResult) then
				vCallback(nResult)
			elseif BaseAtomType.is(nResult) or BaseUnionType.is(nResult) then
				vCallback(nResult)
			else
				if SpaceTable.checkSpace(nResult) then
					vCallback(nResult)
				end
			end
		end
	end
end

function CompletionRuntime:injectCompletion(vTracePos:Integer, vBlockNode:node.Block, vFn:InjectFn, vServer:Truth):Ret(clazz.FieldCompletion)
	const nFieldCompletion = FieldCompletion.new()
	self:_injectForeach(vTracePos, vBlockNode, vFn, function(vResult)
		if RefineTerm.is(vResult) then
			vResult:getType():putCompletion(nFieldCompletion)
		else
			const nNamespace = SpaceTable.checkSpace(vResult)
			if nNamespace then
				nNamespace:spaceTablePutCompletion(vResult, nFieldCompletion)
			end
		end
	end)
	return nFieldCompletion
end

function CompletionRuntime:gotoNodeByParams(vIsLookup:Boolean, vFileUri:String, vDirtySplitCode:clazz.SplitCode, vLine:Integer, vColumn:Integer):Ret(False, String):Ret(List(clazz.IAstNode))
	const nSuccEnv = self:getCodeEnv(vFileUri)
	if not nSuccEnv then
		return false, "goto failed, success compiled code not found"
	end
	const nSuccSplitCode = nSuccEnv:getSplitCode()
	const nPos = nSuccSplitCode:lcToPos(vLine, vColumn)
	if nSuccSplitCode:getLine(vLine) ~= vDirtySplitCode:getLine(vLine) or nPos ~= vDirtySplitCode:lcToPos(vLine, vColumn) then
		return false, "goto failed, code is dirty before pos"
	end
	-- 1. lookup Ident_use and Ident_def
	const nIdentNode = nSuccEnv:searchIdent(nPos)
	if nIdentNode then
		if vIsLookup then
			if nIdentNode.kind == "def" then
				return false, "goto failed, lookup not work for Ident_def"
			end
			const nDefineNode = nIdentNode.defineIdent
			if nDefineNode then
				return {nDefineNode}
			-- else, global identity, don't return, continue
			end
		else
			if nIdentNode.kind == "use" and nIdentNode.defineIdent then
				return false, "goto failed, lookdown not work for Ident_use"
			end
			if nIdentNode.kind == "def" then
				return false, "symbol find reference TODO"
			end
		end
	end
	-- 2. lookup expr
	const nExprNode, nFocusList = nSuccEnv:searchExprBySuffix(nPos)
	if nExprNode then
		self:focusSchedule(nFocusList)
		const nNodeList = vIsLookup and self:exprLookup(nExprNode) or self:exprLookdown(nExprNode)
		if #nNodeList <= 0 then
			return false, "no lookup or lookdown expr node searched, node="..tostring(nExprNode)..",tag="..(nExprNode.tag)
		end
		return nNodeList
	end
	-- 3. search hint expr
	const nHintExprNode, nBlockNode, nFocusList = nSuccEnv:searchHintExprBySuffix(nPos)
	if not nHintExprNode then
		return false, "no target expr"
	end
	const nExprContent = nSuccSplitCode:getContent():sub(nHintExprNode.pos, nHintExprNode.posEnd - 1)
	const nWrongContent = string.rep(" ", nHintExprNode.pos) .. "(@" .. nExprContent .. "."
	const nInjectFn, nInjectTrace = CodeEnv.genInjectFnByError(nSuccSplitCode, vFileUri, nWrongContent)
	if not nInjectFn then
		return false, "gen inject fn fail"
	end
	self:focusSchedule(nFocusList)
	-- 3.1 run inject for hint expr
	return vIsLookup
		and self:injectLookup(nInjectTrace.pos, nBlockNode, nInjectFn)
		or self:injectLookdown(nInjectTrace.pos, nBlockNode, nInjectFn)
end

function CompletionRuntime:injectLookup(vTracePos:Integer, vBlockNode:node.Block, vFn:InjectFn):Ret(List(clazz.IAstNode))
	local nNodeList:List(clazz.IAstNode) = {}
	self:_injectForeach(vTracePos, vBlockNode, vFn, function(vResult)
		if TypeReference.is(vResult) then
			const nAssignNode = vResult:getAssignNode()
			if nAssignNode then
				nNodeList[#nNodeList+1] = nAssignNode
			end
		else
			const nNamespace = SpaceTable.checkSpace(vResult)
			if nNamespace then
				nNodeList[#nNodeList + 1]= nNamespace:getNode()
			end
		end
	end)
	return nNodeList
end

function CompletionRuntime:injectLookdown(vTracePos:Integer, vBlockNode:node.Block, vFn:InjectFn):Ret(List(clazz.IAstNode))
	-- lookdown implement in DiagnosticRuntime
	return {}
end

function CompletionRuntime:exprLookup(vNode:clazz.IAstNode):Ret(List(clazz.IAstNode))
	const nList = self._nodeToApplyContextList:get(vNode)
	if nList and #nList > 0 then
		for _, nContext in pairs(nList) do
			const nLookupNode = next(nContext:getLookupNodeSet())
			if nLookupNode then
				return {nLookupNode}
			end
		end
	end
	return {}
end

function CompletionRuntime:exprLookdown(vNode:clazz.IAstNode):Ret(List(clazz.IAstNode))
	-- lookdown implement in DiagnosticRuntime
	return {}
end

return CompletionRuntime
