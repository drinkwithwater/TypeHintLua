
local TermTuple = require "thlua.tuple.TermTuple"
local Region = require "thlua.runtime.Region"
local RefineTerm = require "thlua.term.RefineTerm"
local TermCase = require "thlua.term.TermCase"
local TypeFunction = require "thlua.func.TypeFunction"
local ContextClass = require "thlua.runtime.ContextClass"
local Exception = require "thlua.Exception"
local Reference = require "thlua.type.Reference"
local Node = require "thlua.code.Node"

local Context = ContextClass()

(@let.class = import("thlua.type.TypeClass").class)

function Context.new(vRuntime:class.Runtime,
	vApplyNode:class.AstNode, vSealContext:Union(False, class.UContext), vParentContext:class.UContext)::RetClass(class.Context)
	local self = setmetatable({::Self()
		_runtime=vRuntime,
		_manager=vRuntime:getTypeManager(),
		_node=vApplyNode,
		_namespace=false@Union(False, class.Namespace),
		_region=false@Union(False, class.Region),
		_classFnSet={} @ Dict(class.ClassFnCom, True),
		_lateFnSet={} @ Dict(class.LateFnCom, True),
	}, Context)
	self._parentContext = vParentContext
	self._sealContext = vSealContext or self
	return self
end

function Context:BEGIN(vLexContext:class.UContext, vBlockNode:class.AstNode, vLuaFunc)
	assert(not self._region, "context can only begin once")
	local nRegion = Region.new(self, vLuaFunc:getFnCom())
	self._region = nRegion
	local nSpace = self._runtime:LetNamespace(vLexContext:getNamespace(), vBlockNode)
	self._namespace = nSpace
	return nRegion, nSpace.localExport, nSpace.globalExport
end

-- pack explist to termtuple or lazyfunc
function Context:EXPLIST_PACK(vNode, vLazy:Boolean,
		l:List(class.TermTuple|class.RefineTerm|Fn():Ret(class.TermTuple|class.RefineTerm)))
	local nTermList = {}
	local nIndexToFunc:Dict(Number, Fn():Ret(Union(class.TermTuple, class.TermTuple))) = {}
	for i=1, #l-1 do
		local cur = l[i]
		if TermTuple.is(cur) then
			if #cur ~= 1 then
				self._runtime:nodeWarn(vNode, "tuple expect 1 value but get "..#cur)
			end
			nTermList[i] = cur:get(1) or self:RefineTerm(self._manager.type.Nil)
		elseif RefineTerm.is(cur) then
			nTermList[i] = cur
		elseif type(cur) == "function" then
			nIndexToFunc[i] = cur
			nTermList[i] = false
		else
			error("unexcept branch")
		end
	end
	local lazyEvalFunc = function()
		for i, nFunc in pairs(nIndexToFunc) do
			nTermList[i] = nFunc()
		end
	end
	local reFunc
	local nIndex = #l
	local nLast = l[nIndex]
	if not nLast then
		reFunc = function()
			return self:TermTuple({})
		end
	else
		if TermTuple.is(nLast) then
			reFunc = function()
				lazyEvalFunc()
				return self:TermTuple(nTermList, nLast)
			end
		else
			if RefineTerm.is(nLast) then
				nTermList[nIndex] = nLast
			elseif type(nLast) == "function" then
				nIndexToFunc[nIndex] = nLast
				nTermList[nIndex] = false
			else
				error("unexcept branch")
			end
			reFunc = function()
				lazyEvalFunc()
				return self:TermTuple(nTermList)
			end
		end
	end
	if vLazy then
		return reFunc
	else
		return reFunc()
	end
end

-- unpack explist to vNum term | termtuple
function Context:EXPLIST_UNPACK(vNode, vNum, ...:Truth)
	local l = {...}
	local re = {}
	for i=1, vNum do
		if i > #l then
			local last = l[#l]
			if TermTuple.is(last) then
				local value = last:get(i - #l + 1)
				if not value then
					self._runtime:nodeError(vNode, "tuple_unpack but right tuple value not enough")
					re[i] = self:RefineTerm(self._manager.type.Nil)
				else
					re[i] = value
				end
			else
				self._runtime:nodeError(vNode, "tuple_unpack but right value not enough")
				re[i] = self:RefineTerm(self._manager.type.Nil)
			end
		else
			local cur = l[i]
			if TermTuple.is(cur) then
				if (i < #l and #cur ~= 1) then
					self._runtime:nodeWarn(vNode, "tuple_unpack except 1 value but has "..#cur)
				end
				re[i] = cur:get(1) or self:RefineTerm(self._manager.type.Nil)
			else
				re[i] = cur
			end
		end
	end
	return table.unpack(re)
end

-- unpack in function's argument & for_in
function Context:TUPLE_UNPACK(vNode, vTuple:class.TermTuple, vNum:Number, vUseDots:Boolean)
	local l = {}
	for i=1, vNum do
		l[i] = vTuple:get(i)
	end
	if vUseDots then
		l[vNum + 1] = vTuple:getDots(vNum + 1)
	end
	return table.unpack(l)
end

-- meta items
function Context:META_GET(vNode, vTerm, vKeyTerm, vNotnil)
	local nGetContext = self:newSealContext(vNode)
	local nTypeCaseList = {}
	local nOkay = self:nodePcall(vNode, function()
		vTerm:foreach(function(vType, vTermCase)
			vKeyTerm:foreach(function(vKeyType, vKeyTermCase)
				local nReType = vType:meta_get(nGetContext, vKeyType)
				if vNotnil then
					nReType = nReType:notnilType()
				end
				nTypeCaseList[#nTypeCaseList + 1] = {nReType, vTermCase & vKeyTermCase}
			end)
		end)
	end)
	if nOkay then
		return self._manager:mergeToRefineTerm(nTypeCaseList)
	else
		return self:TruthTerm()
	end
end

function Context:META_SET(vNode, vTerm, vKeyTerm, vValueTerm, vOverride)
	local nSetContext = self:newSealContext(vNode)
	self:nodePcall(vNode, function()
		local nNil = self._manager.type.Nil
		vTerm:foreach(function(vType, _)
			vKeyTerm:foreach(function(vKeyType)
				if vOverride then
					vType:meta_set_override(nSetContext, vKeyType, vValueTerm:getType())
				else
					vType:meta_set(nSetContext, vKeyType, vValueTerm:getType())
				end
			end)
		end)
	end)
end

function Context:_apply(vNode, vNativePair, vFuncArgCaseList)::Ret(class.TermTuple)
	local ok, err = self:nodePcall(vNode, function()
		local nListLen = #vFuncArgCaseList
		if vNativePair then
			if nListLen ~= 0 then
				self._runtime:nodeError(vNode, "can't mix call native function & not-native function")
				return self:TermTuple({})
			end
			return vNativePair[1]:meta_native_call(self:newOpenContext(vNode), vNativePair[2])
		elseif nListLen >= 1 then
			local nType1TupleCaseList = {}
			local nMaxLength = 0
			local nNil = self._manager.type.Nil
			for i, nFuncArgCase in ipairs(vFuncArgCaseList) do
				local f,a,c = nFuncArgCase[1], nFuncArgCase[2], nFuncArgCase[3]
				local nRetTuples = f:meta_call(self:newSealContext(vNode), a)
				nRetTuples:foreach(function(vTypeTuple)
					local nLength = #vTypeTuple
					if nLength > nMaxLength then
						nMaxLength = nLength
					end
					nType1TupleCaseList[#nType1TupleCaseList + 1] = {
						vTypeTuple:get(1), vTypeTuple, TermCase.new() & c
					}
				end)
			end
			if nMaxLength <= 0 then
				return self:TermTuple({})
			end
			local nTermList = {}
			for i=2,nMaxLength do
				local nCollection = self._manager:TypeCollection()
				for _, nType1TupleCase in pairs(nType1TupleCaseList) do
					nCollection:put(nType1TupleCase[2]:get(i) or nNil)
				end
				local nTypeI = nCollection:mergeToAtomUnion()
				nTermList[i] = self:RefineTerm(nTypeI)
			end
			local nTypeCaseList = {}
			for _, nType1TupleCase in pairs(nType1TupleCaseList) do
				local nType1 = nType1TupleCase[1]
				local nTypeTuple = nType1TupleCase[2]
				local nCase = nType1TupleCase[3]
				for i=2,nMaxLength do
					nCase:put_and(nTermList[i]:attachSymbolShot(), nTypeTuple:get(i))
				end
				nTypeCaseList[#nTypeCaseList + 1] = {
					nType1, nCase
				}
			end
			nTermList[1] = self._manager:mergeToRefineTerm(nTypeCaseList)
			return self:TermTuple(nTermList)
		else
			self._runtime:nodeError(vNode, "meta_call function can't be Never")
			return self:TermTuple({})
		end
	end)
	if ok then
		return err
	else
		return self:TermTuple({})
	end
end

function Context:META_CALL(vNode, vFuncTerm, vLazyFunc)::Ret(class.TermTuple)
	local nNativePair = nil
	local nFuncArgCaseList = {}
	local nNil = self._manager.type.Nil
	vFuncTerm:foreach(function(vFuncType, vTermCase)
		self._region:push_branch(vTermCase)
		local nArgTermTuple = vLazyFunc()
		if vFuncType == nNil then
			self._runtime:nodeWarn(vNode, "nil as call func")
		elseif vFuncType:isNative() then
			if not nNativePair then
				nNativePair = {vFuncType, nArgTermTuple}
			else
				error("can't mix use native function")
			end
		else
			nFuncArgCaseList[#nFuncArgCaseList + 1] = {
				vFuncType, nArgTermTuple:getTypeTuple() , vTermCase
			}
		end
		self._region:pop_branch()
	end)
	return self:_apply(vNode, nNativePair, nFuncArgCaseList)
end

function Context:META_INVOKE(vNode, vTerm, vName, vArgTuple)::Ret(class.TermTuple)
	local nGetContext = self:newSealContext(vNode)
	local nNativePair = nil
	local nFuncArgCaseList = {}
	local nNil = self._manager.type.Nil
	vTerm:foreach(function(vType, vTermCase)
		if vType == nNil then
			self._runtime:nodeWarn(vNode, "nil as invoke self")
		else
			local nNewArgTuple = self:TermTuple({self:RefineTerm(vType)}, vArgTuple)
			local nFuncType = vType:meta_get(nGetContext, self:Literal(vName))
			nFuncType:foreach(function(vSingleFuncType)
				if vSingleFuncType == nNil then
					self._runtime:nodeWarn(vNode, "nil as invoke func")
				elseif vSingleFuncType:isNative() then
					if not nNativePair then
						nNativePair = {vSingleFuncType, nNewArgTuple}
					else
						error("can't mix use native function")
					end
				else
					nFuncArgCaseList[#nFuncArgCaseList + 1] = {
						vSingleFuncType, nNewArgTuple:getTypeTuple() , vTermCase
					}
				end
			end)
		end
	end)
	return self:_apply(vNode, nNativePair, nFuncArgCaseList)
end

function Context:META_EQ_NE(vNode, vIsEq, vLeftTerm, vRightTerm)::Ret(class.RefineTerm)
	local nTypeCaseList = {}
	vLeftTerm:foreach(function(vLeftType, vLeftTermCase)
		vRightTerm:foreach(function(vRightType, vRightTermCase)
			local nReType
			if vLeftType:isSingleton() and vRightType:isSingleton() then
				-- TODO check for named type
				local nTypeIsEq = vLeftType == vRightType
				if vIsEq == nTypeIsEq then
					nReType = self._manager.type.True
				else
					nReType = self._manager.type.False
				end
			elseif not (vLeftType & vRightType):isNever() then
				nReType = self._manager.type.Boolean
			else
				if vIsEq then
					nReType = self._manager.type.False
				else
					nReType = self._manager.type.True
				end
			end
			nTypeCaseList[#nTypeCaseList + 1] = {nReType, vLeftTermCase & vRightTermCase}
		end)
	end)
	return self._manager:mergeToRefineTerm(nTypeCaseList)
end

function Context:META_BOP_SOME(vNode, vOper, vLeftTerm, vRightTerm)::Ret(class.RefineTerm)
	local nBopContext = self:newSealContext(vNode)
	local nCollection = self._manager:TypeCollection()
	vLeftTerm:foreach(function(vLeftType, vLeftTermCase)
		local nLeftHigh, nLeftFunc = vLeftType:meta_bop_func(nBopContext, vOper)
		if nLeftHigh then
			local nTypeTuple = self._manager:Tuple(vLeftType, vRightTerm:getType())
			local nRetTuples = nLeftFunc:meta_call(self:newSealContext(vNode), nTypeTuple)
			nCollection:put(nRetTuples:makeFirstType())
		else
			vRightTerm:foreach(function(vRightType, vRightTermCase)
				local nRightHigh, nRightFunc = vRightType:meta_bop_func(nBopContext, vOper)
				if nRightHigh then
					local nTypeTuple = self._manager:Tuple(vLeftType, vRightType)
					local nRetTuples = nLeftFunc:meta_call(self:newSealContext(vNode), nTypeTuple)
					nCollection:put(nRetTuples:makeFirstType())
				else
					if nLeftFunc and nRightFunc and nLeftFunc == nRightFunc then
						local nTypeTuple = self._manager:Tuple(vLeftType, vRightType)
						local nRetTuples = nLeftFunc:meta_call(self:newSealContext(vNode), nTypeTuple)
						nCollection:put(nRetTuples:makeFirstType())
					else
						self._runtime:nodeError(vNode, "invalid bop:"..vOper)
					end
				end
			end)
		end
	end)
	return self._manager:RefineTerm(nCollection:mergeToAtomUnion())
end

function Context:META_UOP(vNode, vOper, vData)
	local nUopContext = self:newSealContext(vNode)
	local nTypeCaseList = {}
	if vOper == "#" then
		vData:foreach(function(vType, vTermCase)
			nTypeCaseList[#nTypeCaseList + 1] = {
				vType:meta_len(nUopContext),
				vTermCase
			}
		end)
	else
		vData:foreach(function(vType, vTermCase)
			nTypeCaseList[#nTypeCaseList + 1] = {
				vType:meta_uop_some(nUopContext, vOper),
				vTermCase
			}
		end)
	end
	return self._manager:mergeToRefineTerm(nTypeCaseList)
end

function Context:nodePcall(vNode, vFunc, ...:Truth)
	local ok, err = xpcall(vFunc, function(exc)
		if Exception.is(exc) then
			return exc
		else
			print("[ERROR] "..tostring(vNode), tostring(exc))
			print(debug.traceback())
			return Exception.new("[FATAL]"..tostring(exc), vNode)
		end
	end, ...)
	if not ok then
		error(err)
	end
	return ok, err
end

function Context:getRegion()::Ret(class.Region)
	assert(self._region, "region not create when context getRegion")
	return self._region
end

function Context:getParentContext()::Ret(class.UContext)
	return self._parentContext
end

return Context
