
local FunctionBuilder = require "thlua.builder.FunctionBuilder"
local TableBuilder = require "thlua.builder.TableBuilder"
local UnionTerm = require "thlua.term.UnionTerm"
local Variable = require "thlua.func.Variable"
local AutoArguments = require "thlua.func.AutoArguments"
local Exception = require "thlua.Exception"

local LuaFunction = require "thlua.func.LuaFunction"
local TypeFunction = require "thlua.func.TypeFunction"
local LuaTable = require "thlua.object.LuaTable"
local Struct = require "thlua.object.Struct"

(@let.class = import("thlua.type.TypeClass").class)

local function ContextClass()::open()
	local Context = {}
	Context.__index=Context
	function Context:__tostring()
		return "context:"..self:getNode()
	end

	function Context:TABLE_NEW(vNode, vHinterHandler, vPairMaker)
		local nData, nHintMethod = TableBuilder.Begin(self, vNode, vPairMaker)
		vHinterHandler(nHintMethod)
		local nTableType = TableBuilder.End(nData)
		return nTableType
	end

	function Context:FUNC_NEW(vNode, vHintCallback, vAutoArgs, vHasRet, vFunc)
		local nBuilder = FunctionBuilder.new(self, vNode, vAutoArgs, vHasRet, vFunc)
		local ok, err = pcall(vHintCallback, nBuilder:newLongHint())
		if not ok then
			error(Exception.new(err, vNode))
		end
		local nLuaFunc = nBuilder:build()
		return nLuaFunc
	end

	function Context:AutoArguments(vArgList, vArgDots)
		return AutoArguments.new(self._manager, vArgList, vArgDots)
	end

	function Context:HINT(vNode, vTerm, vType)
		-- TODO check cast valid
		return self._manager:UnionTerm(vType)
	end

	function Context:TermTuple(a,b)
		return self._manager:TermTuple(a,b)
	end

	function Context:UnionTerm(vType)
		return self._manager:UnionTerm(vType)
	end

	function Context:NumberTerm()
		return UnionTerm.new(self._manager, self._manager.type.Number)
	end

	function Context:NeverTerm()
		return UnionTerm.new(self._manager, self._manager.type.Never)
	end

	function Context:TruthTerm()
		return UnionTerm.new(self._manager, self._manager.type.Truth)
	end

	function Context:NilTerm()
		return UnionTerm.new(self._manager, self._manager.type.Nil)
	end

	function Context:LiteralTerm(v)
		return UnionTerm.new(self._manager, self:Literal(v))
	end

	function Context:Literal(vValue)
		return self._manager:Literal(vValue)
	end

	function Context:error(...:Truth)
		self._runtime:nodeError(self._node, ...)
	end

	function Context:warn(...:Truth)
		self._runtime:nodeWarn(self._node, ...)
	end

	function Context:info(...:Truth)
		self._runtime:nodeInfo(self._node, ...)
	end

	function Context:getNode()
		return self._node
	end

	function Context:getNamespace()
		return self._namespace
	end

	function Context:getRuntime()
		return self._runtime
	end

	function Context:Variable(vIsGeneric)
		return self._manager:Variable(vIsGeneric)
	end

	function Context:getTypeManager()::Ret(class.TypeManager)
		return self._manager
	end

	function Context:cast(vSrcType, vDstType)::Ret(Boolean)
		vSrcType = vSrcType:checkType()
		vDstType = vDstType:checkType()
		if LuaFunction.is(vSrcType) and TypeFunction.is(vDstType) then
			return vSrcType:cast(self, vDstType)
		elseif LuaTable.is(vSrcType) and Struct.is(vDstType) then
			return vSrcType:cast(self, vDstType)
		end
		return false
	end

	return Context
end

return ContextClass
