
const DotsTail = require "thlua.tuple.DotsTail"
const TermTuple = require "thlua.tuple.TermTuple"
const AutoHolder = require "thlua.auto.AutoHolder"
const RefineTerm = require "thlua.term.RefineTerm"
const Exception = require "thlua.Exception"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const function.open ContextClass()
	const Context = {}
	Context.__index=Context
	function Context:__tostring():Ret(String)
		return "context:"..tostring(self:getNode())
	end

	function Context:TermTupleByAppend(vTermList:List(clazz.UAutoTerm), vTermTuple:OrNil(False, clazz.UTermTuple)):Ret(clazz.UTermTuple)
		local nHasAuto = TermTuple.isAuto(vTermTuple)
		for _, v in ipairs(vTermList) do
			if AutoHolder.is(v) then
				nHasAuto = true
			end
		end
		if vTermTuple then
			for i=1, #vTermTuple do
				const nTerm = (assert(vTermTuple:rawget(i), "term tuple length error"))
				vTermList[#vTermList + 1] = nTerm
			end
		end
		if nHasAuto then
			return TermTuple.new@<true>(self, true, vTermList, vTermTuple and vTermTuple:getTail() or false, false)
		else
			const nList = vTermList @ List(clazz.RefineTerm)
			local nTail:OrFalse(clazz.DotsTail) = false
			if vTermTuple then
				assert(not TermTuple.isAuto(vTermTuple))
				nTail = vTermTuple:getTail()
			end
			return TermTuple.new@<false>(self, false, nList, nTail, false)
		end
	end

	function Context:AutoTermTuple(vTermList:List(clazz.UAutoTerm), vTail:OrNil(False, clazz.DotsTail, clazz.AutoTail)):Ret(clazz.AutoTermTuple)
		return TermTuple.new@<true>(self, true, vTermList, vTail or false, false)
	end

	function Context:FixedTermTuple(vTermList:List(clazz.RefineTerm), vDotsType:OrNil(False, clazz.UAllType), vTypeTuple:OrNil(clazz.UTypeTuple)):Ret(clazz.FixedTermTuple)
		if vDotsType then
			const nTail = DotsTail.new(self, vDotsType)
			return TermTuple.new@<false>(self, false, vTermList, nTail, vTypeTuple or false)
		else
			return TermTuple.new@<false>(self, false, vTermList, false, vTypeTuple or false)
		end
	end

	function Context:TermTuple(vTermList:List(clazz.RefineTerm)):Ret(clazz.FixedTermTuple)
		return TermTuple.new@<false>(self, false, vTermList, false, false)
	end

	function Context:RefineTerm(vType:clazz.UAllType):Ret(clazz.RefineTerm)
		return self._manager:RefineTerm(vType)
	end

	function Context:NumberTerm():Ret(clazz.RefineTerm)
		return RefineTerm.new(self._manager, self._manager.type.Number)
	end

	function Context:NeverTerm():Ret(clazz.RefineTerm)
		return RefineTerm.new(self._manager, self._manager.type.Never)
	end

	function Context:TruthTerm():Ret(clazz.RefineTerm)
		return RefineTerm.new(self._manager, self._manager.type.Truth)
	end

	function Context:NilTerm():Ret(clazz.RefineTerm)
		return RefineTerm.new(self._manager, self._manager.type.Nil)
	end

	function Context:BooleanTerm(vValue:Boolean):Ret(clazz.RefineTerm)
		return RefineTerm.new(self._manager, self._manager:Boolean(vValue))
	end

	function Context:LiteralTerm(v:Union(String, Number)):Ret(clazz.RefineTerm)
		return RefineTerm.new(self._manager, self:Literal(v))
	end

	function Context:Literal(vValue:Union(String, Number)):Ret(Union(clazz.StringLiteral, clazz.NumberLiteral))
		return self._manager:Literal(vValue)
	end

	function Context:error(...:Truth)
		self._runtime:nodeError(self._node, ...)
	end

	function Context:warn(...:Truth)
		self._runtime:nodeWarn(self._node, ...)
	end

	function Context:info(...:Truth)
		self._runtime:nodeInfo(self._node, ...)
	end

	function Context:newSealContext(vNode:clazz.IAstNode):Ret(clazz.Context)
		return self._runtime:newContext(vNode, false, self)
	end

	function Context:newOpenContext(vNode:clazz.IAstNode):Ret(clazz.Context)
		return self._runtime:newContext(vNode, self._sealContext, self)
	end

	function Context:getNode():Ret(clazz.IAstNode)
		return self._node
	end

	function Context:getNamespace():Ret(clazz.Namespace)
		local nSpace = self._namespace
		return assert(nSpace, "space is false when get")
	end

	function Context:getRuntime():Ret(clazz.Runtime)
		return self._runtime
	end

	function Context:getTypeManager():Ret(clazz.TypeManager)
		return self._manager
	end

	function Context:recordLateLuaFunction(vFunc:clazz.LateFnCom)
		if self._sealContext == self then
			self._lateFnSet[vFunc] = true
		else
			self._sealContext:recordLateLuaFunction(vFunc)
		end
	end

	function Context:recordAutoFunction(vFunc:clazz.AutoFunction)
		if self._sealContext ~= self then
			self._sealContext:recordAutoFunction(vFunc)
			return
		else
			const nSet = self._funcMakerSet
			if nSet then
				nSet[vFunc] = true
			else
				vFunc:startBuild()
			end
		end
	end

	function Context:recordClassFactory(vFunc:clazz.ClassFactory)
		if self._sealContext ~= self then
			self._sealContext:recordClassFactory(vFunc)
			return
		else
			const nSet = self._clazzFnSet
			if nSet then
				nSet[vFunc] = true
			else
				vFunc:startBuild()
			end
		end
	end

	function Context:seal()
		if self._sealContext == self then
			const nClassFnSet = assert(self._clazzFnSet, "class set must be true here")
			self._clazzFnSet = false
			for fn, v in pairs(nClassFnSet) do
				fn:startBuild()
			end
			for fn, v in pairs(self._lateFnSet) do
				fn:checkLateRun()
			end
			const nFuncMakerSet = assert(self._funcMakerSet, "maker set must be true here")
			self._funcMakerSet = false
			for fn, v in pairs(nFuncMakerSet) do
				fn:startBuild()
			end
		end
	end

	return Context
end

return ContextClass
