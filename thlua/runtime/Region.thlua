
const Enum = require "thlua.Enum"
const VariableCase = require "thlua.term.VariableCase"
const AutoHolder = require "thlua.auto.AutoHolder"
const AutoTail = require "thlua.auto.AutoTail"
const Branch = require "thlua.runtime.Branch"
const LocalSymbol = require "thlua.term.LocalSymbol"
const ImmutVariable = require "thlua.term.ImmutVariable"
const Exception = require "thlua.Exception"
const TermTuple = require "thlua.tuple.TermTuple"

const DoBuilder = require "thlua.builder.DoBuilder"

const DotsTail = require "thlua.tuple.DotsTail"
const AutoFlag = require "thlua.auto.AutoFlag"
const OpenFunction = require "thlua.func.OpenFunction"
const AutoFunction = require "thlua.func.AutoFunction"
const ClassFactory = require "thlua.func.ClassFactory"

(@let.clazz = import("thlua.type.TypeClass").clazz)
(@let.node = import("thlua.code.Node").node)

const Region = {}
Region.__index = Region
Region.__tostring = function(self):Ret(String)
	return "Region-"..tostring(self._stack:getNode())
end

function:class(clazz.Region) Region.new(vStack:clazz.BaseStack, vBodyFn:clazz.UBodyFunction, vUpCase:OrFalse(clazz.VariableCase))
	const nRootBranch = Branch.new(vStack, nil, vUpCase or VariableCase.new())
	const self = setmetatable({.class
		_stack=vStack,
		_headContext=vStack._headOper,
		_tailContext=vStack._tailOper,
		_curBranch=nRootBranch,
		_branchStack={nRootBranch}@List(clazz.Branch),
		_bodyFn=vBodyFn,
		_retList={} @ List(clazz.FixedTermTuple),
	}, Region)
	return self
end

function Region:withBranch(vVariableCase:clazz.VariableCase, vFunc:Fn()):Ret(clazz.Branch)
	const nStack = self._branchStack
	const nNewLen = #nStack + 1
	const nOldBranch = self._curBranch
	const nNewBranch = Branch.new(self._stack, nOldBranch, vVariableCase)
	nStack[nNewLen] = nNewBranch
	self._curBranch = nNewBranch
	vFunc()
	nStack[nNewLen] = nil
	self._curBranch = nOldBranch
	return nNewBranch
end

function Region:topBranch():Ret(clazz.Branch)
	return self._curBranch
end

function Region:SYMBOL_SET(vNode:clazz.IAstNode, vSymbol:clazz.LocalSymbol, vTerm:clazz.RefineTerm)
	assert(not AutoHolder.is(vSymbol), "auto symbol can't set"..tostring(vNode))
	assert(not ImmutVariable.is(vSymbol), "immutable symbol can't set"..tostring(vNode))
	const nSymbolContext = self._stack:newOperContext(vNode)
	self:topBranch():mutSet(nSymbolContext, vSymbol, vTerm)
end

function Region:SYMBOL_GET(vNode:clazz.IAstNode, vSymbol:clazz.USymbol, vAllowAuto:Boolean):Ret(clazz.UAutoTerm)
	const nSymbolContext = self._stack:newOperContext(vNode)
	const nBranch = self:topBranch()
	if LocalSymbol.is(vSymbol) then
		return nBranch:mutGet(nSymbolContext, vSymbol)
	elseif ImmutVariable.is(vSymbol) then
		return nBranch:immutGet(nSymbolContext, vSymbol)
	else
		const nTerm = vSymbol:getRefineTerm()
		if nTerm then
			return nBranch:immutGet(nSymbolContext, nTerm:attachImmutVariable())
		else
			if not vAllowAuto then
				error(Exception.new("auto term can't be used when it's undeduced", vNode))
			else
				return vSymbol
			end
		end
	end
end

function Region:PARAM_PACKOUT(
	vNode:clazz.IAstNode,
	vList:List(clazz.UAutoTerm),
	vDots:OrFalse(clazz.UTermTuple)
):Ret(clazz.UTermTuple)
	return self._headContext:UTermTupleByAppend(vList, vDots)
end

function Region:PARAM_UNPACK(
	vNode:clazz.IAstNode,
	vTermTuple:OrFalse(clazz.UTermTuple),
	vIndex:Integer,
	vHintType:Union(clazz.AutoFlag, clazz.UAllType)
):Ret(clazz.UAutoTerm)
	const nHeadContext = self._headContext
	if vHintType == AutoFlag then
		if vTermTuple then
			return vTermTuple:get(nHeadContext, vIndex)
		else
			return AutoHolder.new(nHeadContext)
		end
	else
		if vTermTuple then
			const nAutoTerm = vTermTuple:get(nHeadContext, vIndex)
			if not nAutoTerm:getType() then
				nAutoTerm:setAutoCastType(nHeadContext, vHintType)
			end
		end
		-- TODO check type match here...
		return nHeadContext:RefineTerm(vHintType)
	end
end

function Region:PARAM_NODOTS_UNPACK(
	vNode:clazz.IAstNode,
	vTermTuple:OrFalse(clazz.UTermTuple),
	vParNum:Integer
)
	if vTermTuple then
		self._headContext:matchParToDots(vNode, vTermTuple, vParNum, false)
	end
end

function Region:PARAM_DOTS_UNPACK(
	vNode:clazz.IAstNode,
	vTermTuple:OrFalse(clazz.UTermTuple),
	vParNum:Integer,
	vHintDots:Union(clazz.AutoFlag, clazz.UAllType)
):Ret(OrFalse(clazz.UTermTuple))
	if vTermTuple then
		return self._headContext:matchParToDots(vNode, vTermTuple, vParNum, vHintDots)
	else
		if vHintDots == AutoFlag then
			return self._headContext:UTermTupleByTail({}, AutoTail.new(self._headContext))
		else
			return self._headContext:UTermTupleByTail({}, DotsTail.new(self._headContext, vHintDots))
		end
	end
end

function Region:SYMBOL_NEW(vNode:clazz.IAstNode, vKind:node.SymbolKindEnum, vModify:Boolean, vTerm:OrNil(clazz.UAutoTerm), vHintType:OrNil(clazz.UAllType)):Ret(clazz.USymbol)
	const nSymbolContext = self._stack:newOperContext(vNode)
	if AutoHolder.is(vTerm) then
		const nAutoRefineTerm = vTerm:getRefineTerm()
		if not nAutoRefineTerm then
			if vKind ~= Enum.SymbolKind_PARAM then
				error(Exception.new("undeduced auto variable can't be assigned to other variable", vNode))
			end
			return vTerm
		else
			vTerm = nAutoRefineTerm
		end
	end
	if not vTerm then
		vTerm = nSymbolContext:NilTerm()
	end
	if vHintType then
		local nSrcType = vTerm:getType()
		if not nSymbolContext:castLuaType(nSrcType, vHintType) then
			if not vHintType:includeAll(nSrcType) then
				nSymbolContext:error("symbol init but type not match")
			end
		end
		vTerm = nSymbolContext:RefineTerm(vHintType)
	else
		-- convert string literal to string, number literal to number, boolean literal to boolean
		if vModify and vKind == Enum.SymbolKind_LOCAL then
			const nFromType = vTerm:getType()
			const nToType = nSymbolContext:getTypeManager():literal2Primitive(nFromType)
			if nFromType ~= nToType then
				vTerm = nSymbolContext:RefineTerm(nToType)
			end
		end
		nSymbolContext:getTypeManager():basingByDefault(vTerm:getType())
	end
	const nImmutVariable = vTerm:attachImmutVariable()
	if vModify then
		local nLocalSymbol = LocalSymbol.new(nSymbolContext, vNode, vTerm:getType(), vTerm)
		self._stack:getRuntime():recordSymbol(nLocalSymbol)
		self:topBranch():mutMark(nLocalSymbol, nImmutVariable)
		return nLocalSymbol
	else
		nImmutVariable:setNode(vNode)
		return nImmutVariable
	end
end

function Region:IF(vNode:clazz.IAstNode, vTerm:clazz.RefineTerm, vTrueFunction:Fn(), vFalseFunction:OrNil(Fn()))
	const nIfContext = self._stack:newOperContext(vNode)
	const nTrueCase = vTerm:caseTrue()
	const nFalseCase = vTerm:caseFalse()
	const nBeforeBranch = self:topBranch()
	if nTrueCase then
		const nTrueBranch = self:withBranch(nTrueCase, function()
			vTrueFunction()
		end)
		if nFalseCase and vFalseFunction then
			const nFalseBranch = self:withBranch(nFalseCase, function()
				vFalseFunction()
			end)
			nBeforeBranch:mergeTwoBranch(nIfContext, nTrueBranch, nFalseBranch)
		else
			nBeforeBranch:mergeOneBranch(nIfContext, nTrueBranch, nFalseCase)
		end
	elseif nFalseCase and vFalseFunction then
		const nFalseBranch = self:withBranch(nFalseCase, function()
			vFalseFunction()
		end)
		nBeforeBranch:mergeOneBranch(nIfContext, nFalseBranch, nTrueCase)
	end
end

function Region:WHILE(vNode:clazz.IAstNode, vTerm:clazz.RefineTerm, vTrueFunction:Fn())
	const nTrueCase = vTerm:caseTrue()
	if nTrueCase then
		self:withBranch(nTrueCase, function()
			vTrueFunction()
		end)
	else
		self._stack:getRuntime():nodeWarn(vNode, "while loop is unreachable scope")
	end
end

function Region:DO(vNode:clazz.IAstNode, vHintInfo:clazz.TLongHintInfo(Nil), vDoFunc:Fn())
	const nBuilder = DoBuilder.new(self._stack, vNode)
	nBuilder:build(vHintInfo)
	if not nBuilder.pass then
		vDoFunc()
	end
end

function Region:FOR_IN(vNode:clazz.IAstNode, vFunc:Fn(clazz.FixedTermTuple), vNextSelfInit:clazz.FixedTermTuple)
	const nForContext = self._stack:newOperContext(vNode)
	const nLenNext = #vNextSelfInit
	if nLenNext < 1 or nLenNext > 3 then
		nForContext:error("FOR_IN iterator error, arguments number must be 1 or 2 or 3")
		return
	end
	const nNext = vNextSelfInit:get(nForContext, 1)
	const nTuple = self._stack:META_CALL(vNode, nNext, function ()
		if nLenNext == 1 then
			return nForContext:FixedTermTuple({})
		else
			const nSelf = vNextSelfInit:get(nForContext, 2)
			if nLenNext == 2 then
				return nForContext:FixedTermTuple({nSelf})
			else
				if nLenNext == 3 then
					const nInit = vNextSelfInit:get(nForContext, 3)
					return nForContext:FixedTermTuple({nSelf, nInit})
				else
					error("NextSelfInit tuple must be 3, this branch is impossible")
				end
			end
		end
	end)
	if #nTuple <= 0 then
		self._stack:getRuntime():nodeError(vNode, "FOR_IN must receive at least 1 value when iterator")
		return
	end
	assert(TermTuple.isFixed(nTuple), "iter func can't return auto term")
	local nFirstTerm = nTuple:get(nForContext, 1)
	const nFirstType = nFirstTerm:getType()
	if not nFirstType:isNilable() then
		self._stack:getRuntime():nodeError(vNode, "FOR_IN must receive nilable type, TODO : still run logic?? ")
		return
	end
	if nFirstType:notnilType():isNever() then
		return
	end
	nFirstTerm:foreach(function(vAtomType, vCase)
		if vAtomType:isNilable() then
			return
		end
		const nTermList:List(clazz.RefineTerm) = {nForContext:RefineTerm(vAtomType)}
		--[[for i=2, #nTuple do
			nTermList[i] = nTuple:get(i)
		end]]
		for i=2, #nTuple do
			local nTerm = nTuple:get(nForContext, i)
			const nType = vCase[nTerm:attachImmutVariable()]
			if nType then
				nTerm = nForContext:RefineTerm(nType)
			end
			nTermList[i] = nTerm
		end
		local nNewTuple = nForContext:FixedTermTuple(nTermList)
		self:withBranch(vCase, function()
			vFunc(nNewTuple)
		end)
	end)
end

function Region:FOR_NUM(
	vNode:clazz.IAstNode,
	vStart:clazz.RefineTerm,
	vStop:clazz.RefineTerm,
	vStepOrNil:OrNil(clazz.RefineTerm),
	vFunc:Fn(clazz.RefineTerm)
)
	const nForContext = self._stack:newOperContext(vNode)
	vFunc(nForContext:RefineTerm(self._stack:getTypeManager().type.Integer))
end

function Region:LOGIC_OR(vNode:clazz.IAstNode, vLeftTerm:clazz.RefineTerm, vRightFunction:Fn():Ret(clazz.RefineTerm)):Ret(clazz.RefineTerm)
	const nOrContext = self._stack:newLogicContext(vNode)
	const nLeftTrueTerm = nOrContext:logicTrueTerm(vLeftTerm)
	const nLeftFalseCase = vLeftTerm:caseFalse()
	if not nLeftFalseCase then
		return nLeftTrueTerm
	else
		local nRightTerm:OrNil(clazz.RefineTerm) = nil
		self:withBranch(nLeftFalseCase, function()
			nRightTerm = vRightFunction()
		end)
		assert(nRightTerm, "term must be true value here")
		return nOrContext:logicCombineTerm(nLeftTrueTerm, nRightTerm, nLeftFalseCase)
	end
end

function Region:LOGIC_AND(vNode:clazz.IAstNode, vLeftTerm:clazz.RefineTerm, vRightFunction:Fn():Ret(clazz.RefineTerm)):Ret(clazz.RefineTerm)
	const nAndContext = self._stack:newLogicContext(vNode)
	const nLeftFalseTerm = nAndContext:logicFalseTerm(vLeftTerm)
	const nLeftTrueCase = vLeftTerm:caseTrue()
	if not nLeftTrueCase then
		return nLeftFalseTerm
	else
		local nRightTerm:OrNil(clazz.RefineTerm) = nil
		self:withBranch(nLeftTrueCase, function()
			nRightTerm = vRightFunction()
		end)
		assert(nRightTerm, "term must be true value here")
		return nAndContext:logicCombineTerm(nLeftFalseTerm, nRightTerm, nLeftTrueCase)
	end
end

function Region:LOGIC_NOT(vNode:clazz.IAstNode, vData:clazz.RefineTerm):Ret(clazz.RefineTerm)
	const nNotContext = self._stack:newLogicContext(vNode)
	return nNotContext:logicNotTerm(vData)
end

function Region:nativeError()
	self:topBranch():setStop()
end

function Region:nativeAssert(vTerm:clazz.RefineTerm)
	local nTrueCase = vTerm:caseTrue()
	if nTrueCase then
		self:topBranch():assertCase(nTrueCase)
	end
end

function Region:BREAK(vNode:clazz.IAstNode)
	self:topBranch():setStop()
end

function Region:_bodyReturn(vNode:clazz.IAstNode, vTypeTuple:clazz.UTypeTuple)
	const nRetContext = self._stack:newOperContext(vNode)
	const nBodyFn = assert(self._bodyFn)
	if AutoFunction.is(nBodyFn) then
		local nOneOkay = false
		local nRetTuples = nBodyFn:getRetTuples()
		if nRetTuples then
			nRetTuples:foreachWithFirst(function(vDstTuple, _)
				if vTypeTuple:castOrIn(nRetContext, vDstTuple) then
					nOneOkay = true
				end
			end)
			if not nOneOkay then
				nRetContext:error("return check failed")
			end
		else
			-- error("auto return TODO")
		end
	elseif ClassFactory.is(nBodyFn) then
		const nResultType = nBodyFn:getClassAwait()
		if nResultType ~= vTypeTuple:get(1):checkAtomUnion() or #vTypeTuple ~= 1 or vTypeTuple:getRepeatType() then
			nRetContext:error("class return check failed")
		end
	end
end

function Region:_bodyEnd(vNode:clazz.IAstNode, vTermTupleList:List(clazz.FixedTermTuple)):Ret(clazz.FixedTermTuple)
	const nBodyFn = assert(self._bodyFn)
	if OpenFunction.is(nBodyFn) or (AutoFunction.is(nBodyFn) and not nBodyFn:getRetTuples()) then
		local nLen = #vTermTupleList
		if nLen == 0 then
			return self._tailContext:FixedTermTuple({})
		elseif nLen == 1 then
			return vTermTupleList[1]!
		else
			error("TODO : open-function or auto-return-function has more than one return")
			--[[
			local retTermTuple = vTermTupleList[1]!
			for i=2,nLen do
				retTermTuple = retTermTuple | vTermTupleList[i]!
			end
			return retTermTuple]]
		end
	end
	return self._tailContext:FixedTermTuple({})
end

function Region:RETURN(vNode:clazz.IAstNode, vTermTuple:clazz.FixedTermTuple)
	const nRetContext = self._stack:newOperContext(vNode)
	table.insert(self._retList, vTermTuple)
	if #vTermTuple <= 0 or vTermTuple:getTail() then
		self:_bodyReturn(vNode, vTermTuple:checkTypeTuple())
	else
		const nManager = self._stack:getTypeManager()
		const nFirstTerm = vTermTuple:get(nRetContext, 1)
		nFirstTerm:foreach(function(vAtomType, vCase)
			const nTypeList:List(clazz.UAtomUnion) = {vAtomType}
			for i=2, #vTermTuple do
				local nTerm = vTermTuple:get(nRetContext, i)
				const nType = vCase[nTerm:attachImmutVariable()]
				if not nType then
					nTypeList[i] = nTerm:getType()
				else
					nTypeList[i] = assert(nTerm:getType():safeIntersect(nType), "unexcepted intersect when return")
				end
			end
			const nTypeTuple = nManager:TypeTuple(vNode, table.unpack(nTypeList))
			self:_bodyReturn(vNode, nTypeTuple)
		end)
	end
	self:topBranch():setStop()
end

function Region:RUN_AFTER_IF(vNode:clazz.IAstNode, vFunc:Fn())
	if self:topBranch():getStop() then
		self._stack:getRuntime():nodeError(vNode, "unreachable code")
	end
	vFunc()
end

function Region:END(vNode:clazz.IAstNode):Ret(clazz.FixedTermTuple)
	local re = self:_bodyEnd(vNode, self._retList)
	self._stack:getNamespace():close()
	self._stack:seal()
	return re
end

return Region
