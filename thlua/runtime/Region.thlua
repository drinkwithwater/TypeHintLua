
const Region = {}
const TermCase = require "thlua.term.TermCase"
const Branch = require "thlua.runtime.Branch"
const LocalSymbol = require "thlua.runtime.LocalSymbol"

(@let.class = import("thlua.type.TypeClass").class)

Region.__index = Region
Region.__tostring = function(self)::Ret(String)
	return "Region-"..tostring(self._context:getNode())
end

function Region.new(vContext:class.Context, vFnCom:class.UFnCom)::RetClass(class.Region)
	const nRootBranch = Branch.new(vContext, nil, TermCase.new())
	const self = setmetatable({::Self()
		_context=vContext,
		_curBranch=nRootBranch,
		_branchStack={nRootBranch}@List(class.Branch),
		_fnCom=vFnCom,
		_retList={} @ List(class.TermTuple),
	}, Region)
	return self
end

function Region:getFnCom()::Ret(class.UFnCom)
	return self._fnCom
end

function Region:push_branch(vTermCase:OrNil(class.TermCase))
	local nNewBranch = Branch.new(self._context, self._curBranch, vTermCase)
	self._branchStack[#self._branchStack + 1] = nNewBranch
	self._curBranch = nNewBranch
end

function Region:pop_branch()::Ret(class.Branch)
	local len = #self._branchStack
	self._branchStack[len] = nil
	local old_branch = self._curBranch
	self._curBranch = self._branchStack[len - 1]!
	return old_branch
end

function Region:top_branch()::Ret(class.Branch)
	return self._curBranch
end

function Region:SYMBOL_SET(vNode:class.AstNode, vSymbol:class.LocalSymbol, vTerm:class.RefineTerm, vOverride:Boolean)
	assert(LocalSymbol.is(vSymbol), "set immutable symbol"..tostring(vNode))
	self:top_branch():symbol_set(vNode, vSymbol, vTerm)
end

function Region:SYMBOL_GET(vNode:class.AstNode, vSymbol:class.USymbol)::Ret(class.RefineTerm)
	local nBranch = self:top_branch()
	if LocalSymbol.is(vSymbol) then
		return nBranch:mutGetSymbol(vSymbol)
	else
		return nBranch:immutGetSymbol(vSymbol)
	end
end

function Region:SYMBOL(vNode:class.AstNode, vMutable:Boolean, vTerm:OrNil(class.RefineTerm), vHintType:OrNil(class.UAllType))::Ret(class.USymbol)
	if not vTerm then
		vTerm = self._context:NilTerm()
	end
	if vHintType then
		local nSrcType = vTerm:getType()
		if not self._context:cast(nSrcType, vHintType) then
			if not vHintType:containAll(nSrcType) then
				self._context:getRuntime():nodeError(vNode, "symbol init but type not match")
			end
		end
		vTerm = self._context:RefineTerm(vHintType)
	end
	if vMutable then
		local nLocalSymbol = LocalSymbol.new(self._context, vNode, vTerm:getType(), vTerm)
		self:top_branch():symbol_init(nLocalSymbol, vTerm)
		return nLocalSymbol
	else
		return vTerm:attachImmutShot()
	end
end

function Region:IF(vNode, vTerm, vTrueFunction, vFalseFunction)
	local nTrueCase = vTerm:caseTrue()
	self:push_branch(nTrueCase)
	if nTrueCase then
		vTrueFunction()
	end
	local nTrueBranch = self:pop_branch()
	local nFalseCase = vTerm:caseFalse()
	self:push_branch(nFalseCase)
	if vFalseFunction and nFalseCase then
		vFalseFunction()
	end
	local nFalseBranch = self:pop_branch()
	self:top_branch():merge_from(self._context, nTrueBranch, nFalseBranch)
end

function Region:WHILE(vNode:class.AstNode, vTerm, vTrueFunction)
	local nTrueCase = vTerm:caseTrue()
	self:push_branch(nTrueCase)
	if nTrueCase then
		vTrueFunction()
	else
		self._context:getRuntime():nodeWarn(vNode, "while loop is unreachable scope")
	end
	local nTrueBranch = self:pop_branch()
end

function Region:FOR_IN(vNode:class.AstNode, vFunc:Fn(class.TermTuple), vNext:class.RefineTerm, vSelf:class.RefineTerm, vInit:class.RefineTerm)
	const nTuple = self._context:META_CALL(vNode, vNext, function () return self._context:TermTuple({vSelf, vInit}) end)
	if #nTuple <= 0 then
		self._context:getRuntime():nodeError(vNode, "FOR_IN must receive at least 1 value")
		return
	end
	local nFirstTerm = nTuple:get(1)
	if not nFirstTerm:getType():isNilable() then
		self._context:getRuntime():nodeError(vNode, "FOR_IN must receive nilable type, TODO : run logic when error")
		return
	end
	local nCase = nFirstTerm:caseNotnil()
	if not nCase then
		self._context:getRuntime():nodeError(vNode, "FOR_IN into a empty loop")
		return
	end
	-- TODO, maybe symbolshot info is loss
	const nTermList:List(class.RefineTerm) = {nFirstTerm:notnilTerm()}
	for i=2, #nTuple do
		local nTerm = nTuple:get(i)
		const nType = nCase[nTerm:attachImmutShot()]
		if nType then
			nTerm = self._context:RefineTerm(nType)
		end
		nTermList[i] = nTerm
	end
	--local nNewTuple = self._context:TermTuple({nFirstTerm:notnilTerm()}, nTuple:select(2))
	local nNewTuple = self._context:TermTuple(nTermList)
	--self:push_branch(nCase)
	vFunc(nNewTuple)
	--self:pop_branch()
end

function Region:FOR_NUM(vNode, vFunc, vStart, vStop, vStepOrNil)
	vFunc(self._context:NumberTerm())
end

function Region:LOGIC_OR(vNode, vLeftTerm, vRightFunction)
	local nLeftTrueTerm = vLeftTerm:trueTerm()
	local nLeftFalseCase = vLeftTerm:caseFalse()
	if not nLeftFalseCase then
		return nLeftTrueTerm
	else
		self:push_branch(nLeftFalseCase)
		local nRightUnion = vRightFunction()
		self:pop_branch()
		nRightUnion:and_case(nLeftFalseCase)
		return nLeftTrueTerm | nRightUnion
	end
end

function Region:LOGIC_AND(vNode, vLeftTerm, vRightFunction)
	local nLeftFalseTerm = vLeftTerm:falseTerm()
	local nLeftTrueCase = vLeftTerm:caseTrue()
	if not nLeftTrueCase then
		return nLeftFalseTerm
	else
		self:push_branch(nLeftTrueCase)
		local nRightUnion = vRightFunction()
		self:pop_branch()
		nRightUnion:and_case(nLeftTrueCase)
		return nLeftFalseTerm | nRightUnion
	end
end

function Region:LOGIC_NOT(vNode:class.AstNode, vData:class.RefineTerm)::Ret(class.RefineTerm)
	return vData:notTerm()
end

function Region:nativeError()
	self:top_branch():setStop()
end

function Region:nativeAssert(vTerm:class.RefineTerm)
	local nTrueCase = vTerm:caseTrue()
	if nTrueCase then
		self:top_branch():assertCase(nTrueCase)
	end
end

function Region:BREAK(vNode:class.AstNode)
	self:top_branch():setStop()
end

function Region:RETURN(vNode:class.AstNode, vTermTuple:class.TermTuple)
	table.insert(self._retList, vTermTuple)
	self._fnCom:regionReturn(self._context, vNode, vTermTuple:getTypeTuple())
	self:top_branch():setStop()
end

function Region:END(vNode:class.AstNode)
	local re = self._fnCom:regionEnd(self._context, vNode, self._retList)
	self._context:getNamespace():close()
	self._context:seal()
	return re or self._context:TermTuple({})
end

return Region
