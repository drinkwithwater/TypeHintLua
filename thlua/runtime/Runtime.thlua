
local TypeFunction = require "thlua.func.TypeFunction"
local TypeManager = require "thlua.manager.TypeManager"
local NativeFunction = require "thlua.func.NativeFunction"
local LuaFunction = require "thlua.func.LuaFunction"
local TermTuple = require "thlua.tuple.TermTuple"
local Context = require "thlua.runtime.Context"
local ContextClass = require "thlua.runtime.ContextClass"
local native = require "thlua.native"
local CodeEnv = require "thlua.code.CodeEnv"
local Node = require "thlua.code.Node"
local Namespace = require "thlua.manager.Namespace"

(@do
	let.class = import("thlua.type.TypeClass").class

	let.RequireState = Struct {
		fn=class.LuaFunction,
		term=Union(False, class.UnionTerm),
		context=class.Context,
	}

	let.LoadFn = Fn(class.Runtime, class.AstNode):Ret(class.GenFunc)

	let.FileState = Struct {
		env=class.CodeEnv,
		func=LoadFn,
	}
end)


local Runtime = ContextClass()


function Runtime.new()::RetNew(class.Runtime)
	local self = setmetatable({::New()
	}, {
		__index=Runtime,
	})
	self._runtime = self
	self._node = Node.newRootNode()
	self._fileStateDict = {}
	self:clear()
	return self
end

function Runtime:clear()::open()
	self._spaceList = {} @ List(class.Namespace)
	self._manager = TypeManager.new(self)
	self._namespace = self:RootNamespace()
	self._namespace:close()
	self._global_term = native.make(self)
	self._requireDict = {}
	self._lateFnDict = {} @ Dict(class.LuaFunction, True)
	self._defineFnDict = {} @ Dict(class.LuaFunction, True)
end

function Runtime:recordLateLuaFunction(vFunc)
	self._lateFnDict[vFunc] = true
end

function Runtime:recordDefineLuaFunction(vFunc)
	self._defineFnDict[vFunc] = true
end

function Runtime:checkDefineLuaFunction()
	for fn, v in pairs(self._defineFnDict) do
		fn:checkDefine()
	end
end

function Runtime:checkTypeFinish()
	for _, space in pairs(self._spaceList) do
		space:check()
	end
end

function Runtime:checkLateLuaFunction()
	for fn, v in pairs(self._lateFnDict) do
		fn:checkLateRun()
	end
end

function Runtime:import(vPath)
	-- TODO better style
	self:require(vPath)
	local nContext = self._requireDict[vPath].context
	local nSpace = nContext:getNamespace()
	return nSpace.localExport
end

function Runtime:main(vFileName, vContent)
	self:clear()
	local nLuaFunc = self:load(vContent, vFileName)
	local nTermTuple = self._manager:TermTuple({})
	nLuaFunc:meta_native_call(nLuaFunc:newInplaceContext(), nTermTuple)
end

function Runtime:trySyncFile(vFileName, vContent)::Ret(True):Ret(False, class.AstNode):Ret(True)
	local ok, fnOrErr, codeEnv = pcall(self._parse, self, vContent, vFileName)
	if not ok then
		return ok, fnOrErr
	else
		return true
	end
end

function Runtime:newContext(vApplyNode)
	return Context.new(self, vApplyNode)
end

function Runtime:load(vCode, vPath)::Ret(class.LuaFunction)
	local nLoadFn, nEnv = self:_parse(vCode, "hint:"..vPath)
	return nLoadFn(self, nEnv:getNodeList())
end

function Runtime:_parse(vCode, vChunkName)::Ret(LoadFn, class.CodeEnv)
	local nEnv = CodeEnv.new(vCode, vChunkName, vChunkName, self._node)
	local nAfterContent = nEnv:genTypingCode()
	local nFunc, nInfo = load(nAfterContent, vChunkName, "t", setmetatable({}, {
		__index=function(t,k)
			-- TODO, give node pos
			error("indexing global is fatal error")
		end
	}))
	if not nFunc then
		-- TODO, give node pos
		error(nInfo)
	end
	return nFunc, nEnv
end

function Runtime:require(vPath)
	local nRequireState = self._requireDict[vPath]
	if not nRequireState then
		local nOkay, nContent, nFileName = CodeEnv.thluaSearchContent(vPath, true)
		if not nOkay then
				error(nContent)
		end
		local nLuaFunc = self:load(nContent, vPath)
		nRequireState = {
			term=false,
			fn=nLuaFunc,
			context=false,
		}
		self._requireDict[vPath] = nRequireState
		local nTermTuple = self._manager:TermTuple({})
		local nContext = nLuaFunc:newInplaceContext()
		local ret = nLuaFunc:meta_native_call(nContext, nTermTuple)
		nRequireState.term = ret:get(1)
		nRequireState.context = nContext
	end
	local nTerm = nRequireState.term
	if not nTerm then
			error("recursive require:"..vPath)
	end
	return nTerm
end

function Runtime:TreeNamespace()
	local nSpace = Namespace.new(self._manager, Node.getDebugNode(4))
	self._spaceList[#self._spaceList + 1] = nSpace
	return nSpace
end

function Runtime:RootNamespace()
	local nSpace = Namespace.new(self._manager, self._node, self._manager:buildSimpleGlobal())
	self._spaceList[#self._spaceList + 1] = nSpace
	nSpace:trySetKey("")
	nSpace:close()
	return nSpace
end

function Runtime:LetNamespace(vParentLet, vBlockNode)
	local nSpace = Namespace.new(self._manager, vBlockNode, vParentLet:getKeyToType())
	self._spaceList[#self._spaceList + 1] = nSpace
	nSpace:trySetKey("")
	return nSpace
end

function Runtime:makeDebugNode(vDepth)
	return Node.getDebugNode(vDepth)
end

function Runtime:getGlobalTerm()
	return self._global_term
end

return Runtime
