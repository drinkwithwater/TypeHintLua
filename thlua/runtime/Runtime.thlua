
local TypeFunction = require "thlua.func.TypeFunction"
local TypeManager = require "thlua.manager.TypeManager"
local NativeFunction = require "thlua.func.NativeFunction"
local LuaFunction = require "thlua.func.LuaFunction"
local TermTuple = require "thlua.tuple.TermTuple"
local Context = require "thlua.runtime.Context"
local ContextClass = require "thlua.runtime.ContextClass"
local native = require "thlua.native"
local CodeEnv = require "thlua.code.CodeEnv"
local Node = require "thlua.code.Node"
local Namespace = require "thlua.manager.Namespace"
local Symbol = require "thlua.runtime.Symbol"

(@do
	let.class = import("thlua.type.TypeClass").class

	let.LoadedState = Struct {
		fn=class.LuaFunction,
		term=Union(False, class.UnionTerm),
		context=class.Context,
	}

	let.LoadFn = Fn(class.Runtime, class.AstNode):Ret(class.GenFunc)

	let.FileState = Struct {
		succCodeEnv=Option(class.CodeEnv),
		dirtyCodeEnv=class.CodeEnv,
	}
end)


local Runtime = ContextClass()


function Runtime.new()::RetClass(class.Runtime)
	local self = setmetatable({::Self()
	}, {
		__index=Runtime,
	})
	self._runtime = self
	self._node = Node.newRootNode()
	self._fileStateDict = {}
	self._thPath = ""
	self:clear()
	return self
end

function Runtime:setRootPath(vPath)
	self._thPath = vPath
end

function Runtime:getRootPath()::Ret(String)
	return self._thPath
end

function Runtime:clear()::open()
	self._spaceList = {} @ List(class.Namespace)
	self._manager = TypeManager.new(self)
	self._namespace = self:RootNamespace()
	self._namespace:close()
	self._globalTable = native.make(self)
	self._loadedDict = {}
	self._lateFnDict = {} @ Dict(class.LuaFunction, True)
	self._defineFnDict = {} @ Dict(class.LuaFunction, True)
	self._nodeToSymbolSet = {} @ Dict(class.AstNode, Dict(class.AstNode, True))
end

function Runtime:recordSymbol(vSymbol)
	local nNode = vSymbol:getNode()
	local nSymbolSet = self._nodeToSymbolSet[nNode]
	if not nSymbolSet then
		nSymbolSet = {}
		self._nodeToSymbolSet[nNode] = nSymbolSet
	end
	nSymbolSet[vSymbol] = true
end

function Runtime:getNodeSymbolSet(vNode)
	local nSymbolSet = self._nodeToSymbolSet[vNode]
	if not nSymbolSet then
		nSymbolSet = {}
		self._nodeToSymbolList = nSymbolSet
	end
	return nSymbolSet
end

function Runtime:recordLateLuaFunction(vFunc)
	self._lateFnDict[vFunc] = true
end

function Runtime:recordDefineLuaFunction(vFunc)
	self._defineFnDict[vFunc] = true
end

function Runtime:checkDefineLuaFunction()
	for fn, v in pairs(self._defineFnDict) do
		fn:checkDefine()
	end
end

function Runtime:checkTypeFinish()
	for _, space in pairs(self._spaceList) do
		space:check()
	end
end

function Runtime:checkLateLuaFunction()
	for fn, v in pairs(self._lateFnDict) do
		fn:checkLateRun()
	end
end

function Runtime:import(vPath)
	-- TODO better style
	self:require(vPath)
	local nContext = self._loadedDict[vPath].context
	local nSpace = nContext:getNamespace()
	return nSpace.localExport
end

function Runtime:runOpen(vFileName)
	self:clear()
	return pcall(function()
		local nLuaFunc = self:cacheLoadFile(vFileName)
		local nTermTuple = self._manager:TermTuple({})
		nLuaFunc:meta_native_call(nLuaFunc:newInplaceContext(), nTermTuple)
	end)
end

function Runtime:runCheck()
	return pcall(function()
		self:checkDefineLuaFunction()
		self:checkLateLuaFunction()
	end)
end

function Runtime:trySyncFile(vFileName, vContent)::Ret(True):Ret(False, class.AstNode):Ret(True)
	local nCodeEnv = CodeEnv.new(vContent, vFileName)
	nCodeEnv:loadTyping()
	local nFileState = self._fileStateDict[vFileName]
	if not nFileState then
		nFileState = {
			dirtyCodeEnv = nCodeEnv
		}
		self._fileStateDict[vFileName] = nFileState
	else
		nFileState.dirtyCodeEnv = nCodeEnv
	end
	local ok, err = nCodeEnv:checkOkay()
	if ok then
		nFileState.succCodeEnv = nCodeEnv
		return ok
	else
		return ok, err
	end
end

function Runtime:newContext(vApplyNode)
	return Context.new(self, vApplyNode)
end

function Runtime:cacheLoadFile(vFileName)
	if not self._fileStateDict[vFileName] then
		local file, err = io.open(vFileName, "r")
		if not file then
			error(err)
		end
		local nContent = file:read("*a")
		file:close()
		local ok, err = self:trySyncFile(vFileName, nContent)
		if not ok then
			error(err)
		end
	end
	local nCodeEnv = self._fileStateDict[vFileName].dirtyCodeEnv
	local ok, err = nCodeEnv:checkOkay()
	if not ok then
		error(err)
	end
	return nCodeEnv:getTypingFn()(self, nCodeEnv:getNodeList())
end

function Runtime:thluaSearch(vPath)::Ret(True, String, String):Ret(False, String)
	local fileName, err1 = package.searchpath(vPath, self._thPath)
	if not fileName then
		return false, err1
	end
	return true, fileName
end

function Runtime:require(vPath)
	local nLoadedState = self._loadedDict[vPath]
	if not nLoadedState then
		local nOkay, nFileName = self:thluaSearch(vPath)
		if not nOkay then
			error(nFileName)
		end
		local nLuaFunc = self:cacheLoadFile(nFileName)
		nLoadedState = {
			term=false,
			fn=nLuaFunc,
			context=false,
		}
		self._loadedDict[vPath] = nLoadedState
		local nTermTuple = self._manager:TermTuple({})
		local nContext = nLuaFunc:newInplaceContext()
		local ret = nLuaFunc:meta_native_call(nContext, nTermTuple)
		nLoadedState.term = ret:get(1)
		nLoadedState.context = nContext
	end
	local nTerm = nLoadedState.term
	if not nTerm then
			error("recursive require:"..vPath)
	end
	return nTerm
end

function Runtime:TreeNamespace()
	local nSpace = Namespace.new(self._manager, Node.getDebugNode(4))
	self._spaceList[#self._spaceList + 1] = nSpace
	return nSpace
end

function Runtime:RootNamespace()
	local nSpace = Namespace.new(self._manager, self._node, self._manager:buildSimpleGlobal())
	self._spaceList[#self._spaceList + 1] = nSpace
	nSpace:trySetKey("")
	nSpace:close()
	return nSpace
end

function Runtime:LetNamespace(vParentLet, vBlockNode)
	local nSpace = Namespace.new(self._manager, vBlockNode, vParentLet:getKeyToType())
	self._spaceList[#self._spaceList + 1] = nSpace
	nSpace:trySetKey("")
	return nSpace
end

function Runtime:makeDebugNode(vDepth)
	return Node.getDebugNode(vDepth)
end

function Runtime:makeSymbol_ENV(vNode)
	local nTerm = self:UnionTerm(self._globalTable)
	return Symbol.new(self, false, vNode, self._globalTable, nTerm)
end

function Runtime:getSuccCodeEnv(vFileName)::Ret(Nil):Ret(class.CodeEnv)
	local nState = self._fileStateDict[vFileName]
	if nState then
		return nState.succCodeEnv
	else
		return nil
	end
end

function Runtime:getDirtyCodeEnv(vFileName)::Ret(Nil):Ret(class.CodeEnv)
	return self._fileStateDict[vFileName].dirtyCodeEnv
end

function Runtime:nodeError(vNode, ...:Truth)
  print("[ERROR] "..tostring(vNode), ...)
end

function Runtime:nodeWarn(vNode, ...:Truth)
  print("[WARN] "..tostring(vNode), ...)
end

function Runtime:nodeInfo(vNode, ...:Truth)
  print("[INFO] "..tostring(vNode), ...)
end

return Runtime
