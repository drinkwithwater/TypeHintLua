
const TermTuple = require "thlua.tuple.TermTuple"
const Exception = require "thlua.Exception"
const class = require "thlua.class"
const InstStack = require "thlua.runtime.InstStack"
const ClassFactory = require "thlua.func.ClassFactory"
const SealFunction = require "thlua.func.SealFunction"
const AutoFunction = require "thlua.func.AutoFunction"

(@do
	let.clazz = import($class).clazz
	let.node = import("thlua.code.Node").node
end)

const SealStack = class@<clazz.SealStack, false>(InstStack)

function.open SealStack:ctor(
	vRuntime:clazz.BaseRuntime,
	vNode:clazz.IAstNode,
	vUpState:OrFalse(clazz.LexState),
	vBodyFn:Union(clazz.ClassFactory, clazz.AutoFunction)
)
	self._classFnSet={} @ OrFalse(Dict(clazz.ClassFactory, True))
	self._autoFnSet={} @ OrFalse(Dict(clazz.AutoFunction, True))
	self._bodyFn = vBodyFn
	self._classTable=false@OrFalse(clazz.ClassTable)
end

function SealStack:setClassTable(vClassTable:clazz.ClassTable)
	self._classTable = vClassTable
end

function SealStack:getClassTable():Ret(OrFalse(clazz.ClassTable))
	return self._classTable
end

function SealStack:_returnCheck(vContext:clazz.ReturnContext, vTypeTuple:clazz.UTypeTuple)
	const nBodyFn = self._bodyFn
	if AutoFunction.is(nBodyFn) then
		local nOneOkay = false
		local nRetTuples = nBodyFn:getRetTuples()
		if nRetTuples then
			const nMatchSucc, nCastSucc = vContext:returnMatchTuples(vTypeTuple, nRetTuples)
			if not nMatchSucc then
				vContext:error("return match failed")
			elseif not nCastSucc then
				vContext:error("return cast failed")
			end
		end
	elseif ClassFactory.is(nBodyFn) then
		const nResultType = nBodyFn:getClassTable(true)
		if nResultType ~= vTypeTuple:get(1):checkAtomUnion() or #vTypeTuple ~= 1 or vTypeTuple:getRepeatType() then
			vContext:error("class return not match")
		end
	end
end

function SealStack:RAISE_ERROR(vContext:clazz.OperContext, vRaiseErr:clazz.UAllType)
	const nBodyFn = self._bodyFn
	assert(SealFunction.is(nBodyFn))
	const nRetTuples = nBodyFn:getRetTuples()
	const nString = self._manager.type.String
	if nRetTuples then
		const nHintErr = nRetTuples:getErrType()
		if not nHintErr:includeAll(vRaiseErr) then
			if nString:includeAll(nHintErr) then
				vContext:error("can't implicit throw a non-string error")
			else
				vContext:error("err type not match")
			end
		end
	else
		if not nString:includeAll(vRaiseErr) then
			vContext:error("can't implicit throw a non-string error")
		end
	end
end

function SealStack:RETURN(vNode:clazz.IAstNode, vTermTuple:clazz.UTermTuple)
	assert(TermTuple.isFixed(vTermTuple), Exception.new("can't return auto term", vNode))
	const nRetContext = self:newReturnContext(vNode)
	table.insert(self._retList, vTermTuple)
	if #vTermTuple <= 0 or vTermTuple:getTail() then
		self:_returnCheck(nRetContext, vTermTuple:checkTypeTuple())
	else
		const nManager = self:getTypeManager()
		const nFirstTerm = vTermTuple:get(nRetContext, 1)
		nFirstTerm:foreach(function(vAtomType, vCase)
			const nTypeList:List(clazz.UAtomUnion) = {vAtomType}
			for i=2, #vTermTuple do
				local nTerm = vTermTuple:get(nRetContext, i)
				const nType = vCase[nTerm:attachImmutVariable()]
				if not nType then
					nTypeList[i] = nTerm:getType()
				else
					nTypeList[i] = assert(nTerm:getType():safeIntersect(nType), "unexcepted intersect when return")
				end
			end
			const nTypeTuple = nManager:TypeTuple(vNode, table.unpack(nTypeList))
			self:_returnCheck(nRetContext, nTypeTuple)
		end)
	end
	self:_topBranch():setStop()
end

function SealStack:END(vNode:clazz.IAstNode):Ret(clazz.FixedTermTuple, clazz.UAtomUnion)
	self:getNamespace():close()
	self:seal()
	const nBodyFn = self._bodyFn
	const nRetList = self._retList
	if AutoFunction.is(nBodyFn) and not nBodyFn:getRetTuples() then
		const nLen = #nRetList
		if nLen == 0 then
			return self._fastOper:FixedTermTuple({}), self._manager.type.String
		elseif nLen == 1 then
			return nRetList[1]!, self._manager.type.String
		else
			error("TODO : auto-return-function has more than one return")
		end
	else
		return nil@!clazz.FixedTermTuple, nil@!clazz.UAtomUnion
	end
end

function SealStack:seal()
	const nClassFnSet = assert(self._classFnSet, "class set must be true here")
	self._classFnSet = false
	for fn, v in pairs(nClassFnSet) do
		fn:startTask()
	end
	const nAutoFnSet = assert(self._autoFnSet, "maker set must be true here")
	self._autoFnSet = false
	for fn, v in pairs(nAutoFnSet) do
		self._runtime:scheduleAutoFn(fn)
	end
end

function SealStack:getSealStack():Ret(clazz.SealStack)
	return self
end

function SealStack:scheduleSealType(vType:clazz.SealFunction)
	if ClassFactory.is(vType) then
		const nSet = self._classFnSet
		if nSet then
			nSet[vType] = true
		else
			vType:startTask()
		end
	elseif AutoFunction.is(vType) then
		const nSet = self._autoFnSet
		if nSet then
			nSet[vType] = true
		else
			self._runtime:scheduleAutoFn(vType)
		end
	end
end

function SealStack:rootSetNamespace(vRootSpace:clazz.Namespace)
	assert(not self._namespace, "namespace has been setted")
	self._namespace = vRootSpace
end

function SealStack:getBodyFn():Ret(Union(clazz.AutoFunction,clazz.ClassFactory))
	return self._bodyFn @> Union(clazz.AutoFunction,clazz.ClassFactory)
end

function SealStack:isRoot():Ret(Boolean)
	return not self._lexState
end

return SealStack
