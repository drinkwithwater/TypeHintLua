
const json = require "thlua.server.json"
const Exception = require "thlua.Exception"
const lpath = require "path"
const ErrorCodes = require "thlua.server.protocol".ErrorCodes
const CodeEnv = require "thlua.code.CodeEnv"
const FileState = require "thlua.server.FileState"
const class = require "thlua.class"
const platform = require "thlua.platform"
const uv = require@<let.uv_async_t> "luv"
const stdio = require "thlua.server.stdio"
const LuaPromise = require@<let.LuaPromise> "thlua.LuaPromise"

(@do
	let.clazz=import($class).clazz
	let.lsp=import("thlua.server.protocol").lsp
	let.node=import("thlua.code.Node").node
end)

const BaseServer = class@<lsp.BaseServer, clazz.LevelLogger>()

function.open BaseServer:ctor(vGlobalPath:OrNil(String))
	self.initialize=false@Boolean
	self.shutdown=false@Boolean
	self._rootPath=""@String
	self._fileStateDict={}@Dict(String, lsp.FileState)
	self._globalPath = vGlobalPath or lpath.cwd().."/global"
	self._bufList = {} @ List(String)
end

function.pass BaseServer:getMethodHandler():Ret(Truth)
	error("get method handler is not implement in BaseServer")
end

function BaseServer:scanAllFile()
	const nRmList:List(String) = {}
	for nUri, nFileState in pairs(self._fileStateDict) do
		const ok = pcall(function()
			nFileState:syncFile()
		end)
		if not ok then
			nRmList[#nRmList + 1] = nUri
		end
	end
	for _, nUri in pairs(nRmList) do
		self._fileStateDict[nUri] = nil
	end
end


function BaseServer:attachFileState(vFileUri:String):Ret(lsp.FileState)
	local nFileState = self._fileStateDict[vFileUri]
	if not nFileState then
		const nNewState = FileState.new(self, vFileUri)
		self._fileStateDict[vFileUri] = nNewState
		return nNewState
	else
		return nFileState
	end
end

function BaseServer:makeLoader():Ret(clazz.IPlatform)
	return {
		searchPath=function(vPrefix, vPath)
			const nSearchPath = vPrefix or lpath.abs(self._rootPath.."/?.thlua")..";"..lpath.abs(self._rootPath.."/?.d.thlua")
			const nList:List(String) = {}
			const nSet:Dict(String, True) = {}
			for nOnePath in nSearchPath:gmatch("[^;]+") do
				const nAbsPath = lpath.abs(nOnePath)
				if not nSet[nAbsPath] then
					nList[#nList + 1] = nAbsPath
				end
			end
			const nSearchPath = table.concat(nList, ";")
			local fileName, err1 = package.searchpath(vPath, nSearchPath)
			if not fileName then
				return false, err1
			end
			return true, platform.path2uri(fileName)
		end,
		parseFile=function(vFileUri)
			if not self._fileStateDict[vFileUri] then
				self:attachFileState(vFileUri):syncFile()
			end
			return self._fileStateDict[vFileUri]!:checkLatestEnv()
		end,
		parseGlobal=function(vPackage)
			const nFilePath = self._globalPath.."/"..vPackage..".d.thlua"
			const nFileUri = platform.path2uri(nFilePath)
			if not self._fileStateDict[nFileUri] then
				self:attachFileState(nFileUri):syncFile()
            end
			return self._fileStateDict[nFileUri]!:checkLatestEnv(), nFileUri
		end,
		createAsync=function(fn)
			return uv.new_async(fn)
		end,
		logger=self,
	}
end

function BaseServer:checkFileState(vFileUri:String):Ret(lsp.FileState)
	return (assert(self._fileStateDict[vFileUri], "file not existed:"..vFileUri))
end

function BaseServer:mainLoop()
	self:notify("$/status/report", {
		text="hello",
		tooltip="hello",
	})
	self:info("global path:", self._globalPath)
	local rpcAsync = nil@!uv_async_t
	rpcAsync = uv.new_async(function()
		self:info("read request")
		self:_readRequest():next@<Nil>(function(msg)
			self:info("read request:"..json.encode(msg))
			self:_handleRequest(msg)
			rpcAsync:send()
		end)
	end)
	rpcAsync:send()
	uv.run()
end

local function reqToStr(vRequest:lsp.RequestMessage):Ret(String)
	return "["..tostring(vRequest.method)..(vRequest.id and ("$"..vRequest.id) or "").."]"
end

function.pass BaseServer:_handleRequest(request:lsp.RequestMessage)
	local methodName = request.method
	local nId = request.id
	if not methodName then
		if nId then
			self:writeError(nId, ErrorCodes.ParseError, "method name not set", "")
		else
			self:warn(reqToStr(request), "method name not set")
		end
		return
	end
	const handler = self:getMethodHandler()[methodName]
	if not handler then
		if nId then
			self:writeError(nId, ErrorCodes.MethodNotFound, "method not found", "method="..tostring(methodName))
		else
			self:warn(reqToStr(request), "method not found")
		end
		return
	end
	const ok, result = pcall(handler, request.params)
	if not ok then
		self:error("request handle error"..tostring(result))
	elseif result then
		if nId then
			self:writeResult(nId, result)
			-- self:info("write response:$"..tostring(nId))
		else
			self:warn(reqToStr(request), "request without id ")
		end
		return
	else
		if nId then
			self:warn(reqToStr(request), "request with id but no resposne")
		end
	end
end

function BaseServer:_readRequest():Ret(LuaPromise(lsp.RequestMessage))
	-- 1 get header
	local nLength:Integer = -1
	const nHeadPromise = LuaPromise.new@<Nil>()
	const function readhead()
		stdio.readline():next@<Nil>(function(line)
			if not line then
				nHeadPromise:reject("read failed")
				return
			end
			line = line:gsub("\13", "")
			if line == "" then
				nHeadPromise:resolve(nil)
				return
			end
			local key, val = line:match("([^:]+): (.+)")
			if not key or not val then
				nHeadPromise:reject("header format error:"..line)
			end
			if key == "Content-Length" then
				const toInt = math.tointeger(val)
				if not toInt then
					nHeadPromise:reject("Content-Length can't convert to integer"..tostring(val))
					return
				else
					nLength = toInt
				end
			end
			readhead()
		end)
	end
	readhead()

	-- 2 get body
	const nBodyPromise = LuaPromise.new@<lsp.RequestMessage>()
	nHeadPromise:next@<Nil>(function(_)
		if nLength < 0 then
			nBodyPromise:reject("Content-Length failed in rpc")
			return
		end
		stdio.readlen(nLength):next@<Nil>(function(data)
			data = data:gsub("\13", "")
			local obj, err = json.decode(data)
			if type(obj) ~= "table" then
				nBodyPromise:reject("json decode error:"..tostring(err))
				return
			end
			const req = obj @? lsp.RequestMessage
			if req.jsonrpc ~= "2.0" then
				nBodyPromise:reject("json-rpc is not 2.0, "..tostring(req.jsonrpc))
				return
			end
			nBodyPromise:resolve(obj)
		end, function(err)
			nBodyPromise:reject(err)
		end)
	end, function(err)
		nBodyPromise:reject(err)
	end)
	return nBodyPromise
end

function BaseServer:writeError(vId:Union(Integer, String, Nil), vCode:Integer, vMsg:String, vData:String):Ret()
	self:_write({
		jsonrpc = "2.0",
		id = vId,
		error = {
			code = vCode,
			message = vMsg,
			data = vData,
		}
	})
end

function BaseServer:writeResult(vId:Union(Integer, String, Nil), vResult:Truth):Ret()
	self:_write({
		jsonrpc = "2.0",
		id = vId,
		result = vResult,
	})
end

function BaseServer:notify(vMethod:String, vParams:Truth):Ret()
	self:_write({
		jsonrpc = "2.0",
		method = vMethod,
		params = vParams,
	})
end

function BaseServer:_write(vPacket:Truth)
	local data:String = json.encode(vPacket)
	if platform.iswin() then
		data = ("Content-Length: %d\n\n%s"):format(#data, data)
	else
		data = ("Content-Length: %d\r\n\r\n%s"):format(#data, data)
	end
	-- stdio.writeout(data)
	io.write(data)
	io.flush()
end

local MessageType = {}

MessageType.ERROR = 1
MessageType.WARNING = 2
MessageType.INFO = 3
MessageType.DEBUG = 4

function BaseServer:packToString(vDepth, ...:Truth):Ret(String)
	local nInfo = debug.getinfo(vDepth)
	local nPrefix = nInfo.source..":"..nInfo.currentline
	local l = {nPrefix} @ List(String)
	for i=1,select("#", ...) do
		l[#l + 1] = tostring(select(i, ...))
	end
	return table.concat(l, " ")
end

function BaseServer:error(...:Truth):Ret()
	const str = self:packToString(3, ...)
	self:notify("window/logMessage", {
		message = str,
		type = MessageType.ERROR,
	})
end

function BaseServer:warn(...:Truth):Ret()
	const str = self:packToString(3, ...)
	self:notify("window/logMessage", {
		message = str,
		type = MessageType.WARNING,
	})
end

function BaseServer:info(...:Any)
	const str = self:packToString(3, ...)
	self:notify("window/logMessage", {
		message = str,
		type = MessageType.INFO,
	})
end

function BaseServer:debug(...)
	const str = self:packToString(3, ...)
	self:notify("window/logMessage", {
		message = str,
		type = MessageType.DEBUG,
	})
end

function BaseServer:setRoot(vRoot:String)
	--self.root = vRoot:gsub("/*$", "")
	--self:info("root:", self.root, vRoot)
	self._rootPath = vRoot
end

return BaseServer
