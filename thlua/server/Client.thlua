
local json = require "thlua.server.json"
local methodHandler = require "thlua.server.methodHandler"
local ErrorCodes = require "thlua.server.protocol".ErrorCodes
local Runtime = require "thlua.runtime.Runtime"

(@let.class=import("thlua.type.TypeClass").class)
(@let.lsp=import("thlua.server.protocol").lsp)

local Client = {}

Client.__index = Client

function Client.new()::RetClass(lsp.Client)
	return setmetatable({::Self()
		initialize=false@Boolean,
		shutdown=false,
		root=false,
		runtime=Runtime.new(),
	}, Client)
end

function Client:mainLoop()
	while not self.shutdown do
		self:rpc()
	end
end

local function reqToStr(vRequest)::Ret(String)
	return "["..tostring(vRequest.method)..(vRequest.id and ("$"..vRequest.id) or "").."]"
end

function Client:rpc()::Ret()
	local request = self:readRequest()
	local methodName = request.method
	local nId = request.id
	if not methodName then
		if nId then
			self:writeError(nId, ErrorCodes.ParseError, "method name not set", "")
		else
			self:warn(reqToStr(request), "method name not set")
		end
		return
	end
	local handler = methodHandler[methodName]
	if not handler then
		if nId then
			self:writeError(nId, ErrorCodes.MethodNotFound, "method not found", "method="..tostring(methodName))
		else
			self:warn(reqToStr(request), "method not found")
		end
		return
	end
	local result = handler(self, request.params)
	if result then
		if nId then
			self:writeResult(nId, result)
		else
			self:warn(reqToStr(request), "request without id ")
		end
		return
	else
		if nId then
			self:warn(reqToStr(request), "request with id but no resposne")
		end
	end
end

function Client:readRequest()::Ret(lsp.RequestMessage)
	-- 1 get header
	local length:Number = -1
	while true do
		local line = io.read("*l")
		if not line then
			error("io.read fail")
			return
		end
		line = line:gsub("\13", "")
		if line == "" then
			break
		end
		local key, val = line:match("([^:]+): (.+)")
		if not key or not val then
			error("header format error:"..line)
		end
		if key == "Content-Length" then
			length = math.tointeger(val)
		end
	end

	if length < 0 then
		error("Content-Length failed in rpc")
	end

	-- 2 get body
	local data = io.read(length)
	if not data then
		error("read nothing")
		return
	end
	data = data:gsub("\13", "")
	local obj, err = json.decode(data)
	if type(obj) ~= "table" then
		error("json decode error:"..tostring(err))
		return
	end
	if obj.jsonrpc ~= "2.0" then
		error("json-rpc is not 2.0, "..tostring(obj.jsonrpc))
	end
	self:info("recv:"..reqToStr(obj) ) -- , json.encode(obj.params))
	return obj
end

function Client:writeError(vId:Union(Number, String, Nil), vCode:Number, vMsg:String, vData:String)::Ret()
	self:_write({
		jsonrpc = "2.0",
		id = vId,
		error = {
			code = vCode,
			message = vMsg,
			data = vData,
		}
	})
end

function Client:writeResult(vId:Union(Number, String, Nil), vResult:Truth)::Ret()
	self:_write({
		jsonrpc = "2.0",
		id = vId,
		result = vResult,
	})
end

function Client:notify(vMethod:String, vParams:Truth)::Ret()
	self:_write({
		jsonrpc = "2.0",
		method = vMethod,
		params = vParams,
	})
end

function Client:publishError(vDocIdent:lsp.VersionedTextDocumentIdentifier, vErrNode:Union(class.AstNode, Nil))
	self:_write({
		jsonrpc = "2.0",
		method = "textDocument/publishDiagnostics",
		params = {
			uri=vDocIdent.uri,
			version=vDocIdent.version,
			diagnostics={ vErrNode and {
				range={
					start={
						line=vErrNode.l-1,
						character=vErrNode.c-1,
					},
					["end"]={
						line=vErrNode.l-1,
						character=vErrNode.c,
					}
				},
				message=vErrNode[1] or "unknown"
			} }
		},
	})
end

function Client:_write(vPacket:Truth)
	local data = json.encode(vPacket)
	io.write("Content-Length: "..#data.."\r\n\r\n"..data)
	io.flush()
end

local MessageType = {}

MessageType.ERROR = 1
MessageType.WARNING = 2
MessageType.INFO = 3
MessageType.DEBUG = 4

function Client:packToString(vDepth, ...:Truth)::Ret(String)
	local nInfo = debug.getinfo(vDepth)
	local nPrefix = nInfo.source..":"..nInfo.currentline
	local l = {nPrefix} @ List(String)
	for i=1,select("#", ...) do
		l[#l + 1] = tostring(select(i, ...))
	end
	return table.concat(l, " ")
end

function Client:error(...:Truth)::Ret()
	self:notify("window/logMessage", {
		message = self:packToString(3, ...),
		type = MessageType.ERROR,
	})
end

function Client:warn(...:Truth)::Ret()
	self:notify("window/logMessage", {
		message = self:packToString(3, ...),
		type = MessageType.WARNING,
	})
end

function Client:info(...:Truth)::Ret()
	self:notify("window/logMessage", {
		message = self:packToString(3, ...),
		type = MessageType.INFO,
	})
end

function Client:debug(...)
	self:notify("window/logMessage", {
		message = self:packToString(3, ...),
		type = MessageType.DEBUG,
	})
end

function Client:setRoot(vRoot:String)
	vRoot = vRoot:gsub("/*$", "")
	--package.path = vRoot.."/?.lua;"..package.path
	--package.cpath = vRoot.."/?.so;"..package.cpath
	self.runtime:setPath(vRoot.."/?.thlua")
	--[[local nMainFileName = vRoot .. "thMain.thlua"
	local f, err2 = io.open(nMainFileName, "r")
	if not f then
		return
	end]]
	-- local content = f:read("*a")
	-- self.runtime:trySyncFile(nMainFileName, content)
end

return Client
