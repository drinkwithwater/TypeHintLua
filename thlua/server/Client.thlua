
local json = require "thlua.server.json"
local methodHandler = require "thlua.server.methodHandler"
local Exception = require "thlua.Exception"
local ErrorCodes = require "thlua.server.protocol".ErrorCodes
local Runtime = require "thlua.runtime.Runtime"
local CodeEnv = require "thlua.code.CodeEnv"

(@do
	let.clazz=import("thlua.type.TypeClass").clazz
	let.lsp=import("thlua.server.protocol").lsp
	let.node = import("thlua.code.Node").node
	let.FileState = Struct {
		succCodeEnv=OrNil(clazz.CodeEnv),
		dirtyCodeEnv=clazz.CodeEnv,
		version=Number,
	}
end)

local Client = {}

Client.__index = Client

function:class(lsp.Client) Client.new(vMode:OrNil("fast", "slow")):impl(clazz.ILoader)
	local self = setmetatable({.class
		initialize=false@Boolean,
		shutdown=false@Boolean,
		_mode=vMode or false,
		_root=""@String,
		_runtime=nil@OrNil(clazz.Runtime),
		_fileStateDict={}@Dict(String, FileState),
		logFile=false,
	}, Client)
	return self
end

function Client:searchDefine(vFileName, vLine, vColumn):Ret(OrNil(node.Ident_def))
	local nSuccEnv = self:getSuccCodeEnv(vFileName)
	if nSuccEnv then
		local nPos = nSuccEnv:lcToPos(vLine, vColumn)
		const nNode = nSuccEnv:searchName(nPos)
		if nNode and nNode.kind == "def" then
			return nNode
		end
	end
	return nil
end

function Client:syncFile(vContent:String, vFileName:String, vVersion:Integer)
	local nCodeEnv = CodeEnv.new(vContent, vFileName, vVersion)
	local nFileState = self._fileStateDict[vFileName]
	if not nFileState then
		nFileState = {
			dirtyCodeEnv = nCodeEnv,
			version = vVersion,
		}
		self._fileStateDict[vFileName] = nFileState
	else
		nFileState.dirtyCodeEnv = nCodeEnv
	end
	if nCodeEnv:checkOkay() then
		nFileState.succCodeEnv = nCodeEnv
	end
end

function Client:rerun(vFileName:String)
	local ok, mainFileName = self:thluaSearch("main")
	if not ok then
		mainFileName = vFileName
		self:info("main.thlua not found, run single file:", mainFileName)
	else
		self:info("main.thlua found:", mainFileName)
	end
	const nRuntime=Runtime.new(self, mainFileName)
	const ok, exc = nRuntime:main()
	if not ok then
		if not self._runtime then
			self._runtime = nRuntime
		end
		self:publishException(tostring(exc))
		return
	end
	self._runtime = nRuntime
	collectgarbage()
	self:publishNormal()
end

function Client:thluaSearch(vPath:String):Ret(Boolean, String)
	local thluaPath = self._root.."/?.thlua"
	local fileName, err1 = package.searchpath(vPath, thluaPath)
	if not fileName then
		return false, err1
	end
	return true, fileName
end

function Client:thluaParseFile(vFileName:String)
	if not self._fileStateDict[vFileName] then
		local file, err = io.open(vFileName, "r")
		if not file then
			error(err)
		end
		const nContent = file:read("*a")
		file:close()
		self:syncFile(nContent, vFileName, -1)
	end
	local nCodeEnv = self._fileStateDict[vFileName]!.dirtyCodeEnv
	local ok, err = nCodeEnv:checkOkay()
	if not ok then
		error(err)
	end
	return nCodeEnv
end

function Client:getSuccCodeEnv(vFileName:String):Ret(OrNil(clazz.CodeEnv))
	local nState = self._fileStateDict[vFileName]
	if nState then
		return nState.succCodeEnv
	else
		return nil
	end
end

function Client:getDirtyCodeEnv(vFileName:String):Ret(clazz.CodeEnv)
	local nFileState = self._fileStateDict[vFileName]
	if not nFileState then
		error(tostring(vFileName).." has no file state")
	else
		return nFileState.dirtyCodeEnv
	end
end

function Client:mainLoop()
	self:notify("$/status/report", {
		text="hello",
		tooltip="hello",
	})
	self:info("mode=", self._mode)
	while not self.shutdown do
		self:rpc()
	end
end

local function reqToStr(vRequest:lsp.RequestMessage):Ret(String)
	return "["..tostring(vRequest.method)..(vRequest.id and ("$"..vRequest.id) or "").."]"
end

function.pass Client:rpc()
	local request = self:readRequest()
	local methodName = request.method
	local nId = request.id
	if not methodName then
		if nId then
			self:writeError(nId, ErrorCodes.ParseError, "method name not set", "")
		else
			self:warn(reqToStr(request), "method name not set")
		end
		return
	end
	const handler = methodHandler[methodName]
	if not handler then
		if nId then
			self:writeError(nId, ErrorCodes.MethodNotFound, "method not found", "method="..tostring(methodName))
		else
			self:warn(reqToStr(request), "method not found")
		end
		return
	end
	const result = handler(self, request.params)
	if result then
		if nId then
			self:writeResult(nId, result)
			self:info("write response:$"..tostring(nId))
		else
			self:warn(reqToStr(request), "request without id ")
		end
		return
	else
		if nId then
			self:warn(reqToStr(request), "request with id but no resposne")
		end
	end
end

function Client:debugPrint(vStr:String):Ret()
	const nLogFile = self.logFile
	if nLogFile then
		nLogFile:write(vStr)
		nLogFile:write("\n")
		nLogFile:flush()
	end
end

function Client:readRequest():Ret(lsp.RequestMessage)
	-- 1 get header
	local length:Integer = -1
	while true do
		local line = io.read("*l")
		if not line then
			self:debugPrint("io read fail")
			error("io.read fail")
		end
		line = line:gsub("\13", "")
		if line == "" then
			break
		end
		self:debugPrint("read line:"..line)
		local key, val = line:match("([^:]+): (.+)")
		if not key or not val then
			self:debugPrint("header format error")
			error("header format error:"..line)
		end
		if key == "Content-Length" then
			length = assert(math.tointeger(val), "Content-Length can't convert to integer"..tostring(val))
		end
	end

	if length < 0 then
		self:debugPrint("Context-Length failed in rpc"..length)
		error("Content-Length failed in rpc")
	end
	self:debugPrint("read length ="..tostring(length))

	-- 2 get body
	local data = io.read(length)
	if not data then
		error("read nothing")
	end
	self:debugPrint("read packet:"..data)
	data = data:gsub("\13", "")
	local obj, err = json.decode(data)
	if type(obj) ~= "table" then
		error("json decode error:"..tostring(err))
	end
	const req = obj @? lsp.RequestMessage
	if req.jsonrpc ~= "2.0" then
		error("json-rpc is not 2.0, "..tostring(req.jsonrpc))
	end
	self:info("recv:"..reqToStr(req) ) -- , json.encode(obj.params))
	return req
end

function Client:writeError(vId:Union(Number, String, Nil), vCode:Number, vMsg:String, vData:String):Ret()
	self:_write({
		jsonrpc = "2.0",
		id = vId,
		error = {
			code = vCode,
			message = vMsg,
			data = vData,
		}
	})
end

function Client:writeResult(vId:Union(Number, String, Nil), vResult:Truth):Ret()
	self:_write({
		jsonrpc = "2.0",
		id = vId,
		result = vResult,
	})
end

function Client:notify(vMethod:String, vParams:Truth):Ret()
	self:_write({
		jsonrpc = "2.0",
		method = vMethod,
		params = vParams,
	})
end

function Client:publishNormal()
	local nFileToList = self._runtime!:getAllDiagnostic()
	for nFileName, nFileState in pairs(self._fileStateDict) do
		const nRawDiaList:List(clazz.Diagnostic) = nFileToList[nFileName] or {}
		local nCodeEnv = nFileState.succCodeEnv or nFileState.dirtyCodeEnv
		local nVersion = nCodeEnv:getVersion()
		local nDiaList:List(lsp.Diagnostic) = {}
		for _, dia in ipairs(nRawDiaList) do
			local nNode = dia.node
			local nMsg = dia.msg
			nDiaList[#nDiaList + 1] = {
				range={
					start={
						line=nNode.l-1,
						character=nNode.c-1,
					},
					["end"]={
						line=nNode.l-1,
						character=nNode.c,
					}
				},
				message=nMsg,
				severity=dia.severity,
			}
		end
		self:_write({
			jsonrpc = "2.0",
			method = "textDocument/publishDiagnostics",
			params = {
				uri=self:pathToUri(nFileName),
				version=nVersion,
				diagnostics=json.array(nDiaList),
			},
		})
	end
end

function Client:publishException(vException:Union(clazz.Exception, String))
	local nNode:OrNil(clazz.IAstNode) = nil
	local nMsg:String = ""
	if Exception.is(vException) then
		nNode = vException.node or self._runtime!:getNode()
		nMsg = vException.msg or "exception's msg field is missing"
	else
		nNode = self._runtime!:getNode()
		nMsg = "root error:"..tostring(vException)
	end
	const nCodeEnv = self:getDirtyCodeEnv(nNode.path)
	self:_write({
		jsonrpc = "2.0",
		method = "textDocument/publishDiagnostics",
		params = {
			uri=self:pathToUri(nCodeEnv:getChunkName()),
			version=nCodeEnv:getVersion(),
			diagnostics={ {
				range={
					start={
						line=nNode.l-1,
						character=nNode.c-1,
					},
					["end"]={
						line=nNode.l-1,
						character=nNode.c,
					}
				},
				message=nMsg,
			} }
		},
	})
end

function Client:getPlatform():Ret(String)
	if package.config:sub(1,1) == "\\" then
		return "win"
	else
		return "not-win"
	end
end

function Client:_write(vPacket:Truth)
	local data:String = json.encode(vPacket)
	if self:getPlatform() == "win" then
		data = ("Content-Length: %d\n\n%s"):format(#data, data)
	else
		data = ("Content-Length: %d\r\n\r\n%s"):format(#data, data)
	end
	io.write(data)
	io.flush()
end

local MessageType = {}

MessageType.ERROR = 1
MessageType.WARNING = 2
MessageType.INFO = 3
MessageType.DEBUG = 4

function Client:packToString(vDepth, ...:Truth):Ret(String)
	local nInfo = debug.getinfo(vDepth)
	local nPrefix = nInfo.source..":"..nInfo.currentline
	local l = {nPrefix} @ List(String)
	for i=1,select("#", ...) do
		l[#l + 1] = tostring(select(i, ...))
	end
	return table.concat(l, " ")
end

function Client:error(...:Truth):Ret()
	const str = self:packToString(3, ...)
	self:notify("window/logMessage", {
		message = str,
		type = MessageType.ERROR,
	})
	const nLogFile = self.logFile
	if nLogFile then
		nLogFile:write("[ERROR]")
		nLogFile:write(str)
		nLogFile:write("\n")
		nLogFile:flush()
	end
end

function Client:warn(...:Truth):Ret()
	const str = self:packToString(3, ...)
	self:notify("window/logMessage", {
		message = str,
		type = MessageType.WARNING,
	})
	const nLogFile = self.logFile
	if nLogFile then
		nLogFile:write("[WARN]")
		nLogFile:write(str)
		nLogFile:write("\n")
		nLogFile:flush()
	end
end

function Client:info(...:Any)
	const str = self:packToString(3, ...)
	self:notify("window/logMessage", {
		message = str,
		type = MessageType.INFO,
	})
	const nLogFile = self.logFile
	if nLogFile then
		nLogFile:write("[INFO]")
		nLogFile:write(str)
		nLogFile:write("\n")
		nLogFile:flush()
	end
end

function Client:debug(...)
	const str = self:packToString(3, ...)
	self:notify("window/logMessage", {
		message = str,
		type = MessageType.DEBUG,
	})
	const nLogFile = self.logFile
	if nLogFile then
		nLogFile:write("[DEBUG]")
		nLogFile:write(str)
		nLogFile:write("\n")
		nLogFile:flush()
	end
end

function Client:setRoot(vRoot:String)
	--self.root = vRoot:gsub("/*$", "")
	--self:info("root:", self.root, vRoot)
	self._root = vRoot
end

function Client:uriToPath(vUri:String):Ret(String)
	const nPath = vUri:gsub("+", ""):gsub("%%(..)", function(c)
		return string.char(tonumber(c, 16))
	end)
	if self:getPlatform() == "win" then
		return (nPath:gsub("^file:///", ""):gsub("/$", ""))
	else
		return (nPath:gsub("^file://", ""):gsub("/$", ""))
	end
end

function Client:pathToUri(vPath:String):Ret(String)
	if self:getPlatform() == "win" then
		const nUri = vPath:gsub("\\", "/"):gsub("([a-zA-Z]):", function(driver)
			return driver.."%3A"
		end)
		return "file:///"..nUri
	else
		return "file://"..vPath
	end
end

function Client:checkRuntime()
	return assert(self._runtime)
end

return Client
