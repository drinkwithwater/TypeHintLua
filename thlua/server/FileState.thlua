
const CodeEnv = require "thlua.code.CodeEnv"
const SplitCode = require "thlua.code.SplitCode"
const class = require "thlua.class"

(@do
	let.clazz=import("thlua.type.TypeClass").clazz
	let.lsp=import("thlua.server.protocol").lsp
	let.node=import("thlua.code.Node").node
end)

const FileState = class@<lsp.FileState, false>()

function.open FileState:ctor(vFileName:String)
	self._succEnv = false@OrFalse(clazz.CodeEnv)
	self._rightEnv = false@OrFalse(clazz.CodeEnv)
	self._fileName = vFileName
	self._splitCode = nil@!clazz.SplitCode
	self._errOrEnv = nil@!Union(clazz.Exception, clazz.CodeEnv)
	self._version = (-1) @Integer
end

function FileState:getWellformedRange(vRange:lsp.Range):Ret(lsp.Range)
	const nStart = vRange.start
	const nEnd = vRange["end"]
	if nStart.line > nEnd.line or (nStart.line == nEnd.line and nStart.character > nEnd.character) then
		return { start=nEnd, ["end"]=nStart }
	else
		return vRange
	end
end

function FileState:syncChange(vParams:lsp.DidChangeTextDocumentParams)
	const nChanges = vParams.contentChanges
	local nSplitCode = self._splitCode
	for _, nChange in ipairs(nChanges) do
		const nRawRange = nChange.range
		if nRawRange then
			const nRange = self:getWellformedRange(nRawRange)
			const nContent = nSplitCode:getContent()
			const nStartPos = nSplitCode:lcToPos(nRange.start.line + 1, nRange.start.character + 1)
			const nFinishPos = nSplitCode:lcToPos(nRange["end"].line + 1, nRange["end"].character + 1)
			const nNewContent = nContent:sub(1, nStartPos - 1) .. nChange.text .. nContent:sub(nFinishPos, #nContent)
			nSplitCode = SplitCode.new(nNewContent)
		else
			nSplitCode = SplitCode.new(nChange.text)
		end
	end
	self._splitCode = nSplitCode
end

function FileState:syncContent(vContent:String, vVersion:Integer):Ret(Boolean)
	self._version = vVersion
	const nCodeEnv = CodeEnv.new(vContent, self._fileName, vVersion)
	const ok, err = pcall(function()
		nCodeEnv:lateInit()
	end)
	if ok then
		self._rightEnv = nCodeEnv
		self._errOrEnv = nCodeEnv
		self._splitCode = nCodeEnv
		return true
	else
		self._errOrEnv = err
		self._splitCode = SplitCode.new(vContent)
		return false
	end
end

function FileState:getRightEnv():Ret(OrFalse(clazz.CodeEnv))
	return self._rightEnv
end

function FileState:getSuccEnv():Ret(OrFalse(clazz.CodeEnv))
	return self._succEnv
end

function FileState:checkLatestEnv():Ret(clazz.CodeEnv)
	const nLatest = self._errOrEnv
	if CodeEnv.is(nLatest) then
		self._succEnv = nLatest
		return nLatest
	else
		error(nLatest)
	end
end

function FileState:getSplitCode():Ret(clazz.SplitCode)
	return self._splitCode
end

function FileState:getVersion():Ret(Integer)
	return self._version
end

return FileState
