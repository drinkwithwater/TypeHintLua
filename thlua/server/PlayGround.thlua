

const class = require "thlua.class"
const json = require "thlua.server.json"

const SplitCode = require "thlua.code.SplitCode"
const CodeEnv = require "thlua.code.CodeEnv"
const DiagnosticRuntime = require "thlua.runtime.DiagnosticRuntime"

(@do
    let.clazz = import($class).clazz
    let.UpdateInput = Struct {
        position=OrFalse(Struct {
            l=Integer,
            c=Integer,
        }),
        content=String,
    }
    let.UpdateOutput = Struct {
        syntaxErr=Boolean,
        diaList=List(clazz.Diagnostic),
        luaContent=String,
    }
end)

const PlayGround = class@<clazz.PlayGround, clazz.ILoader>()

function.open PlayGround:ctor()
    self._splitCode = SplitCode.new("")
    self._codeEnv = nil@!clazz.CodeEnv
end

function PlayGround:thluaParseFile(vFileName)
    return CodeEnv.new(self._splitCode, vFileName)
end

function PlayGround:thluaSearch(vPath)
    return false, "can't use require on playground"
end

function PlayGround:update(vName:String, vData:String):Ret(String)
    const nInput = json.decode(vData) @> UpdateInput
    const ret = self:_update(vName, nInput)
    return json.encode(ret)
end

function PlayGround:_update(vName:String, vInput:UpdateInput):Ret(UpdateOutput)
    const nContent = vInput.content
    const nCode = SplitCode.new(nContent)
    self._splitCode = nCode
    const nParseOkay, nCodeEnv = pcall(CodeEnv.new, nCode, vName)
    if not nParseOkay then
        return {
            syntaxErr=true,
            diaList=json.array({} @List(clazz.Diagnostic)),
            luaContent=tostring(nCodeEnv),
        }
    end
    const nRuntime = DiagnosticRuntime.new(self)
    const nRunOkay, nExc = nRuntime:pmain(vName)
    const nDiaList:List(clazz.Diagnostic) = nRuntime:getAllDiagnostic()[vName] or {}
    const nAfterDiaList:List(clazz.Diagnostic) = {}
    for i, dia in ipairs(nDiaList) do
        nAfterDiaList[i] = {
            msg = dia.msg,
            severity = dia.severity,
            node = {
                l=dia.node.l,
                c=dia.node.c,
                path=dia.node.path
            } @? clazz.IAstNode,
        }
    end
    return {
        syntaxErr=false,
        diaList=json.array(nAfterDiaList),
        luaContent=nCodeEnv:genLuaCode()
    }
end

return PlayGround