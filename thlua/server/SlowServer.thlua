
const lpath = require "path"
const json = require "thlua.server.json"
const Exception = require "thlua.Exception"
const ErrorCodes = require "thlua.server.protocol".ErrorCodes
const DiagnosticRuntime = require "thlua.runtime.DiagnosticRuntime"
const CodeEnv = require "thlua.code.CodeEnv"
const FileState = require "thlua.server.FileState"
const ApiServer = require "thlua.server.ApiServer"
const FastServer = require "thlua.server.FastServer"
const class = require "thlua.class"

(@do
	let.clazz=import($class).clazz
	let.lsp=import("thlua.server.protocol").lsp
	let.node=import("thlua.code.Node").node
end)

const SlowServer = class@<lsp.SlowServer, false>(FastServer)

function SlowServer:checkDiagnosticRuntime()
	return assert(self._runtime) @> clazz.DiagnosticRuntime
end

function SlowServer:getInitializeResult():Ret(lsp.InitializeResult)
	self:info("slow server")
	return {
		capabilities = {
			textDocumentSync = {
				openClose = true,
				change = 2, -- 1 is non-incremental, 2 is incremental
				save = { includeText = true },
			},
			referencesProvider = true,
		},
	}
end

function SlowServer:publishNormal()
	const nRuntime = self:checkDiagnosticRuntime()
	local nFileToList = nRuntime:getAllDiagnostic()
	for nFileName, nFileState in pairs(self._fileStateDict) do
		const nRawDiaList:List(clazz.Diagnostic) = nFileToList[nFileName] or {}
		const nVersion = nFileState:getVersion()
		const nDiaList:List(lsp.Diagnostic) = {}
		const nSplitCode = nFileState:getSplitCode()
		for _, dia in ipairs(nRawDiaList) do
			local nNode = dia.node
			const nLineContent = nSplitCode:getLine(nNode.l)
			const nRangeEnd = nNode.pos == nNode.posEnd and {
				nNode.l, nNode.c + (nLineContent and #nLineContent + 10 or 100)
			} or {nSplitCode:fixupPos(nNode.posEnd)}
			local nMsg = dia.msg
			nDiaList[#nDiaList + 1] = {
				range={
					start={
						line=nNode.l-1,
						character=nNode.c-1,
					},
					["end"]={
						line=nRangeEnd[1]-1,
						character=nRangeEnd[2]-1,
					}
				},
				message=nMsg,
				severity=dia.severity,
			}
		end
		self:_write({
			jsonrpc = "2.0",
			method = "textDocument/publishDiagnostics",
			params = {
				uri=nFileName,
				version=nVersion,
				diagnostics=json.array(nDiaList),
			},
		})
	end
end

function SlowServer:publishException(vException:Union(clazz.Exception, String))
	local nNode:OrNil(clazz.IBaseNode) = nil
	local nMsg:String = ""
	if Exception.is(vException) then
		nNode = vException.node or self._runtime!:getNode()
		nMsg = vException.msg or "exception's msg field is missing"
	else
		nNode = self._runtime!:getNode()
		nMsg = "root error:"..tostring(vException)
	end
	const nFileState = self._fileStateDict[nNode.path]!
	self:_write({
		jsonrpc = "2.0",
		method = "textDocument/publishDiagnostics",
		params = {
			uri=nNode.path,
			version=nFileState:getVersion(),
			diagnostics={ {
				range={
					start={
						line=nNode.l-1,
						character=0,
					},
					["end"]={
						line=nNode.l-1,
						character=100,
					}
				},
				message=nMsg,
			} }
		},
	})
end

function SlowServer:rerun(vFileUri:String)
	local rootFileUri = lpath.isfile(self._rootPath .. "/root.thlua")
	if not rootFileUri then
		rootFileUri = vFileUri
		self:info("root.thlua not found, run single file:", rootFileUri)
	else
		rootFileUri = self:pathToUri(rootFileUri)
		self:info("root.thlua found:", rootFileUri)
	end
	const nRuntime=DiagnosticRuntime.new(self:makeLoader())
	const ok, exc = nRuntime:pmain(rootFileUri)
	if not ok then
		if not self._runtime then
			self._runtime = nRuntime
		end
		self:publishException(exc @? Union(clazz.Exception, String))
		return
	else
		self._runtime = nRuntime
		collectgarbage()
		self:publishNormal()
	end
end

function SlowServer:onDidChange(vParams:lsp.DidChangeTextDocumentParams)
	self:attachFileState(vParams.textDocument.uri):syncChangeNoRerun(vParams)
end

function SlowServer:onDidOpen(vParams:lsp.DidOpenTextDocumentParams)
	const nContent = vParams.textDocument.text
	const nFileUri = vParams.textDocument.uri
	const nFileState = self:attachFileState(nFileUri)
	if nFileState:contentMismatch(nContent) then
		nFileState:syncContent(nContent, vParams.textDocument.version)
		self:rerun(nFileUri)
	end
end

function SlowServer:onDidSave(vParams:lsp.DidSaveTextDocumentParams)
	const nFileUri = vParams.textDocument.uri
	const nContent = vParams.text
	const nFileState = self:attachFileState(nFileUri)
	nFileState:onSaveAndGetChange()
	self:rerun(nFileUri)
end

function SlowServer:onReferences(vParams:lsp.ReferenceParams):Ret(OrNil(List(lsp.Location)))
	const nFileUri = vParams.textDocument.uri
	const nFileState = self:checkFileState(nFileUri)
	const nDiagnosticRuntime = self:checkDiagnosticRuntime()
	const nNodeSet, nErrMsg = nDiagnosticRuntime:gotoNodeByParams(
		false, nFileUri, nFileState:getSplitCode(),
		vParams.position.line + 1,
		vParams.position.character + 1
	)
	if not nNodeSet then
		self:info("find references fail:", nErrMsg)
		return nil
	else
		const nRetList:List(lsp.Location) = {}
		for nLookupNode, _ in pairs(nNodeSet) do
			nRetList[#nRetList + 1] = {
				uri=nLookupNode.path,
				range={
					start={ line=nLookupNode.l - 1, character=nLookupNode.c-1, },
					["end"]={ line=nLookupNode.l - 1, character=nLookupNode.c + 10 },
				}
			}
		end
		return nRetList
	end
end

return SlowServer
