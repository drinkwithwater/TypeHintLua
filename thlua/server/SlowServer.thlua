
const lpath = require "path"
const json = require "thlua.server.json"
const Exception = require "thlua.Exception"
const ErrorCodes = require "thlua.server.protocol".ErrorCodes
const DiagnosticRuntime = require "thlua.runtime.DiagnosticRuntime"
const CodeEnv = require "thlua.code.CodeEnv"
const FileState = require "thlua.server.FileState"
const ApiServer = require "thlua.server.ApiServer"
const FastServer = require "thlua.server.FastServer"
const class = require "thlua.class"

(@do
	let.clazz=import($class).clazz
	let.lsp=import("thlua.server.protocol").lsp
	let.node=import("thlua.code.Node").node
end)

const SlowServer = class@<lsp.SlowServer, false>(FastServer)

function SlowServer:checkDiagnosticRuntime()
	return assert(self._runtime) @> clazz.DiagnosticRuntime
end

function SlowServer:getInitializeResult():Ret(lsp.InitializeResult)
	self:info("slow server")
	return {
		capabilities = {
			textDocumentSync = {
				openClose = true,
				change = 2, -- 1 is non-incremental, 2 is incremental
				save = { includeText = true },
			},
			referencesProvider = true,
		},
	}
end

function SlowServer:publishNormal()
	const nRuntime = self:checkDiagnosticRuntime()
	local nFileToList = nRuntime:getAllDiagnostic()
	for nFileName, nFileState in pairs(self._fileStateDict) do
		const nRawDiaList:List(clazz.Diagnostic) = nFileToList[nFileName] or {}
		const nVersion = nFileState:getVersion()
		const nDiaList:List(lsp.Diagnostic) = {}
		const nSplitCode = nFileState:getSplitCode()
		for _, dia in ipairs(nRawDiaList) do
			local nNode = dia.node
			const nLineContent = nSplitCode:getLine(nNode.l)
			const nRangeEnd = nNode.pos == nNode.posEnd and {
				nNode.l, nNode.c + (nLineContent and #nLineContent + 10 or 100)
			} or {nSplitCode:fixupPos(nNode.posEnd)}
			local nMsg = dia.msg
			nDiaList[#nDiaList + 1] = {
				range={
					start={
						line=nNode.l-1,
						character=nNode.c-1,
					},
					["end"]={
						line=nRangeEnd[1]-1,
						character=nRangeEnd[2]-1,
					}
				},
				message=nMsg,
				severity=dia.severity,
			}
		end
		self:_write({
			jsonrpc = "2.0",
			method = "textDocument/publishDiagnostics",
			params = {
				uri=nFileName,
				version=nVersion,
				diagnostics=json.array(nDiaList),
			},
		})
	end
end

function SlowServer:publishException(vException:Union(clazz.Exception, String))
	local nNode:OrNil(clazz.IAstNode) = nil
	local nMsg:String = ""
	if Exception.is(vException) then
		nNode = vException.node or self._runtime!:getNode()
		nMsg = vException.msg or "exception's msg field is missing"
	else
		nNode = self._runtime!:getNode()
		nMsg = "root error:"..tostring(vException)
	end
	const nFileState = self._fileStateDict[nNode.path]!
	self:_write({
		jsonrpc = "2.0",
		method = "textDocument/publishDiagnostics",
		params = {
			uri=nNode.path,
			version=nFileState:getVersion(),
			diagnostics={ {
				range={
					start={
						line=nNode.l-1,
						character=0,
					},
					["end"]={
						line=nNode.l-1,
						character=100,
					}
				},
				message=nMsg,
			} }
		},
	})
end

function SlowServer:rerun(vFileUri:String)
	local rootFileUri = lpath.isfile(self._rootPath .. "/root.thlua")
	if not rootFileUri then
		rootFileUri = vFileUri
		self:info("root.thlua not found, run single file:", rootFileUri)
	else
		rootFileUri = self:pathToUri(rootFileUri)
		self:info("root.thlua found:", rootFileUri)
	end
	const nRuntime=DiagnosticRuntime.new(self:makeLoader())
	const ok, exc = nRuntime:pmain(rootFileUri)
	if not ok then
		if not self._runtime then
			self._runtime = nRuntime
		end
		self:publishException(exc @? Union(clazz.Exception, String))
		return
	else
		self._runtime = nRuntime
		collectgarbage()
		self:publishNormal()
	end
end

function SlowServer:onDidChange(vParams:lsp.DidChangeTextDocumentParams)
	self:attachFileState(vParams.textDocument.uri):syncChangeNoRerun(vParams)
end

function SlowServer:onDidOpen(vParams:lsp.DidOpenTextDocumentParams)
	const nContent = vParams.textDocument.text
	const nFileUri = vParams.textDocument.uri
	const nFileState = self:attachFileState(nFileUri)
	if nFileState:contentMismatch(nContent) then
		nFileState:syncContent(nContent, vParams.textDocument.version)
		self:rerun(nFileUri)
	end
end

function SlowServer:onDidSave(vParams:lsp.DidSaveTextDocumentParams)
	const nFileUri = vParams.textDocument.uri
	const nContent = vParams.text
	const nFileState = self:attachFileState(nFileUri)
	nFileState:onSaveAndGetChange()
	self:rerun(nFileUri)
end

function SlowServer:onReferences(vParams:lsp.ReferenceParams):Ret(OrNil(List(lsp.Location)))
	const nFileUri = vParams.textDocument.uri
	const nFileState = self:checkFileState(nFileUri)
	const nSplitCode = nFileState:getSplitCode()
	const nLine = vParams.position.line + 1
	const nColumn = vParams.position.character + 1
	const nPos = nSplitCode:lcToPos(nLine, nColumn)
	-- 1. find Ident_use to target Ident_def
	const nRightEnv = nFileState:getRightEnv()
	if nRightEnv then
		const nNode = nRightEnv:searchIdent(nPos)
		if nNode then
			if nNode.kind == "def" then
				-- TODO, return location list
				return nil
			end
			if nNode.defineIdent then
				-- not def ident
				return nil
			end
		end
	end
	-- 2. other case, get position in succ env, find by expr lookup
	const nDiagnosticRuntime = self:checkDiagnosticRuntime()
	const nSuccEnv = nDiagnosticRuntime:getCodeEnv(nFileUri)
	if not nSuccEnv then
		self:info("find reference fail, maybe some error in code")
		return nil
	end
	if nSuccEnv:getSplitCode():getLine(nLine) ~= nSplitCode:getLine(nLine) then
		self:info("TODO, if line not same, need rerun or check if split code has syntax error")
		return nil
	end
	const nPos = nSuccEnv:getSplitCode():lcToPos(nLine, nColumn)
	-- 3. search expr
	const nExprNode, nFocusList = nSuccEnv:searchExprBySuffix(nPos)
	if nExprNode then
		const nLookdownList = nDiagnosticRuntime:nodeLookdown(nExprNode)
		if not nLookdownList then
			self:info("not found lookdown node"..tostring(nExprNode), nExprNode.tag)
			return nil
		end
		const nRetList:List(lsp.Location) = {}
		for i, nLookdownNode in ipairs(nLookdownList) do
			nRetList[i] = {
				uri=nLookdownNode.path,
				range={
					start={ line=nLookdownNode.l - 1, character=nLookdownNode.c-1, },
					["end"]={ line=nLookdownNode.l - 1, character=nLookdownNode.c + 10 },
				}
			}
		end
		return nRetList
	end
	-- 4. search hint expr
	const nHintExprNode, nBlockNode, nFocusList = nSuccEnv:searchHintExprBySuffix(nPos)
	if not nHintExprNode then
		self:info("no target expr")
		return nil
	end
	const nExprContent = nSuccEnv:getSplitCode():getContent():sub(nHintExprNode.pos, nHintExprNode.posEnd - 1)
	const nWrongContent = string.rep(" ", nHintExprNode.pos) .. "(@" .. nExprContent .. "."
	const nInjectFn, nInjectTrace = CodeEnv.genInjectFnByError(nSplitCode, nFileUri, nWrongContent)
	if not nInjectFn then
		return nil
	end
	-- 5. run inject for hint expr
	const nFieldCompletion = nDiagnosticRuntime:injectCompletion(nInjectTrace.pos, nBlockNode, nInjectFn, self)
	if not nFieldCompletion then
		self:info("completion fail for no branch", nBlockNode, nBlockNode.tag)
		return nil
	end
	const nLookupNode = nDiagnosticRuntime:injectLookup(nInjectTrace.pos, nBlockNode, nInjectFn)
	if not nLookupNode then
		return nil
	end
	return nil
end

return SlowServer
