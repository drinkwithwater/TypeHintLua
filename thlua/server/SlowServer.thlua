
const json = require "thlua.server.json"
const Exception = require "thlua.Exception"
const ErrorCodes = require "thlua.server.protocol".ErrorCodes
const DiagnosticRuntime = require "thlua.runtime.DiagnosticRuntime"
const CodeEnv = require "thlua.code.CodeEnv"
const FileState = require "thlua.server.FileState"
const ApiServer = require "thlua.server.ApiServer"
const FastServer = require "thlua.server.FastServer"
const class = require "thlua.class"

(@do
	let.clazz=import("thlua.type.TypeClass").clazz
	let.lsp=import("thlua.server.protocol").lsp
	let.node=import("thlua.code.Node").node
end)

const SlowServer = class@<lsp.SlowServer, false>(FastServer)

function SlowServer:checkDiagnosticRuntime()
	return assert(self._runtime) @> clazz.DiagnosticRuntime
end

function SlowServer:getInitializeResult():Ret(lsp.InitializeResult)
	self:info("slow server")
	return {
		capabilities = {
			textDocumentSync = {
				openClose = true,
				change = 2, -- 1 is non-incremental, 2 is incremental
				save = { includeText = true },
			},
		},
	}
end

function SlowServer:publishNormal()
	const nRuntime = self:checkDiagnosticRuntime()
	local nFileToList = nRuntime:getAllDiagnostic()
	for nFileName, nFileState in pairs(self._fileStateDict) do
		const nRawDiaList:List(clazz.Diagnostic) = nFileToList[nFileName] or {}
		local nVersion = nFileState:getVersion()
		local nDiaList:List(lsp.Diagnostic) = {}
		const nSplitCode = nFileState:getSplitCode()
		for _, dia in ipairs(nRawDiaList) do
			local nNode = dia.node
			const nRangeEnd = nNode.pos == nNode.posEnd and {
				nNode.l, nNode.c + 100
			} or {nSplitCode:fixupPos(nNode.posEnd)}
			local nMsg = dia.msg
			nDiaList[#nDiaList + 1] = {
				range={
					start={
						line=nNode.l-1,
						character=nNode.c-1,
					},
					["end"]={
						line=nRangeEnd[1]-1,
						character=nRangeEnd[2]-1,
					}
				},
				message=nMsg,
				severity=dia.severity,
			}
		end
		self:_write({
			jsonrpc = "2.0",
			method = "textDocument/publishDiagnostics",
			params = {
				uri=nFileName,
				version=nVersion,
				diagnostics=json.array(nDiaList),
			},
		})
	end
end

function SlowServer:publishException(vException:Union(clazz.Exception, String))
	local nNode:OrNil(clazz.IAstNode) = nil
	local nMsg:String = ""
	if Exception.is(vException) then
		nNode = vException.node or self._runtime!:getNode()
		nMsg = vException.msg or "exception's msg field is missing"
	else
		nNode = self._runtime!:getNode()
		nMsg = "root error:"..tostring(vException)
	end
	const nFileState = self._fileStateDict[nNode.path]!
	self:_write({
		jsonrpc = "2.0",
		method = "textDocument/publishDiagnostics",
		params = {
			uri=nNode.path,
			version=nFileState:getVersion(),
			diagnostics={ {
				range={
					start={
						line=nNode.l-1,
						character=0,
					},
					["end"]={
						line=nNode.l-1,
						character=100,
					}
				},
				message=nMsg,
			} }
		},
	})
end

function SlowServer:rerun(vFileUri:String)
	local ok, mainFileUri = self:thluaSearch("main")
	if not ok then
		mainFileUri = vFileUri
		self:info("main.thlua not found, run single file:", mainFileUri)
	else
		self:info("main.thlua found:", mainFileUri)
	end
	const nRuntime=DiagnosticRuntime.new(self)
	const ok, exc = nRuntime:pmain(mainFileUri)
	if not ok then
		if not self._runtime then
			self._runtime = nRuntime
		end
		self:publishException(exc @? Union(clazz.Exception, String))
		return
	end
	self._runtime = nRuntime
	collectgarbage()
	self:publishNormal()
end

function SlowServer:onDidChange(vParams:lsp.DidChangeTextDocumentParams)
	self:attachFileState(vParams.textDocument.uri):syncChangeNoRerun(vParams)
end

return SlowServer
