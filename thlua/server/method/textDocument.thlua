
local json = require "thlua.server.json"
local CodeEnv = require "thlua.code.CodeEnv"
local Exception = require "thlua.Exception"

(@do
	let.lsp=import("thlua.server.protocol").lsp

	let.Position = Struct {
		line=Number,
		character=Number,
	}

	let.Range=Struct {
		start=Position,
		["end"]=Position,
	}

	let.TextDocumentIdentifier = Struct {
		uri=String,
	}

	lsp.VersionedTextDocumentIdentifier = Struct {
		version=Number,
		uri=String,
	}

	let.DidChangeTextDocumentParams = Struct {
		textDocument=lsp.VersionedTextDocumentIdentifier,
		contentChanges=List(Struct {
			range=Range,
			rangeLength=Option(Number),
			text=String,
		}),
	} 

	let.DidOpenTextDocumentParams = Struct {
		textDocument = Struct {
			uri=String,
			languageId=String,
			version=Number,
			text=String,
		}
	}

	let.DefinitionParams = Struct {
		textDocument = TextDocumentIdentifier,
		position=Position,
	}

	let.HoverParams = Struct {
		textDocument = TextDocumentIdentifier,
		position=Position,
	}

	let.CompletionParams = Struct {
		textDocument = TextDocumentIdentifier,
		position=Position,
		context=Option(Struct {
			triggerKind=Union(1,2,3),
			triggerCharacter=Option(String),
		}),
	}

	let.PublishDiagnosticsParams = Struct {
		uri=String,
		version=Option(Number),
		diagnostics=List(Struct {
			range=Range,
			severity=Option(Struct {
			}),
			code=Option(Union(Number, String)),
			codeDescription=Option(Struct {
				href=String,
			}),
			source=Option(String),
			message=String,
			tags=Option(List(Union(1,2))),
			-- relatedInformation
			-- data
		}),
	}

	let.Location = Struct {
		uri=String,
		range=Range,
	}

	let.CompletionItem = Struct {
		label=String,
		labelDetails=Option(Struct{}),
		kind=Union(Nil,1,2,3,4,5,6,7,8),
		--tags=CompletionItemTag,
		detail=Option(String),
		documentation=Option(String),
		deprecated=Option(Boolean),
		preselect=Option(Boolean),
		sortText=Option(String),
		filterText=Option(String),
		insertText=Option(String),
		--....
	}

	let.MarkupContent = Struct {
		kind=Union("markdown", "plaintext"),
		value=String,
	}

end)

local function uriToFileName(vUri)
	return "/"..vUri:gsub("file:/*", "")
end

local function searchIdDefine(vClient, vUri, vPosition)
	local nFileName = uriToFileName(vUri)
	local nSuccEnv = vClient.runtime:getSuccCodeEnv(nFileName)
	if nSuccEnv then
		local nPos = nSuccEnv:lcToPos(vPosition.line + 1, vPosition.character + 1)
		local nNode = nSuccEnv:searchName(nPos)
		if nNode then
			if nNode.tag == "Id" then
				nNode = nSuccEnv:getIdent(nNode.ident_refer)
				return nNode
			end
		end
	end
	return nil
end

local function syncFile(vClient, vTextDocument, vContent)
	local nFileName = uriToFileName(vTextDocument.uri)
	local ok, errNode = vClient.runtime:trySyncFile(nFileName, vContent)
	if not ok then
		vClient:publishException(vTextDocument, Exception.new(errNode[1], errNode))
		return
	end
	local ok, exc = vClient.runtime:runOpen(nFileName, vContent)
	if not ok then
		vClient:publishException(vTextDocument, exc)
		return
	end
	local ok, exc = vClient.runtime:runCheck()
	if not ok then
		vClient:publishException(vTextDocument, exc)
		return
	end
	vClient:publishNoException(vTextDocument)
end

return {
	didChange=function(vClient:lsp.Client, vParams:DidChangeTextDocumentParams)
		local nContent = vParams.contentChanges[1].text
		syncFile(vClient, vParams.textDocument, nContent)
	end,
	didOpen=function(vClient:lsp.Client, vParams:DidOpenTextDocumentParams)
		local nContent = vParams.textDocument.text
		syncFile(vClient, vParams.textDocument, nContent)
	end,
	didSave=function(vClient:lsp.Client, vParams)
	end,
	didClose=function(vClient:lsp.Client, vParams)
	end,
	definition=function(vClient:lsp.Client, vParams:DefinitionParams)::Ret(Location)
		local nDefineNode = searchIdDefine(vClient, vParams.textDocument.uri, vParams.position)
		if nDefineNode then
			return {
				uri=vParams.textDocument.uri,
				range={
					start={ line=nDefineNode.l - 1, character=nDefineNode.c-1, },
					["end"]={ line=nDefineNode.l - 1, character=nDefineNode.c - 1 },
				}
			}
		end
	end,
	completion=function(vClient:lsp.Client, vParams:CompletionParams)::Ret(List(CompletionItem))
		local nFileName = uriToFileName(vParams.textDocument.uri)
		local nSuccEnv = vClient.runtime:getSuccCodeEnv(nFileName)
		if not nSuccEnv then
			return
		end
		local nDirtyEnv = vClient.runtime:getDirtyCodeEnv(nFileName)
		local nPos = nDirtyEnv:lcToPos(vParams.position.line+1, vParams.position.character+1)
		local nContent = nDirtyEnv:getContent():sub(1, nPos)
		local nCodeEnv = CodeEnv.new(nContent, nFileName, nFileName, nil)
		local ok, nErrNode = nCodeEnv:checkOkay()
		local nDefineNode
		if not ok then
			nDefineNode = nSuccEnv:searchNameByError(nErrNode)
		else
			nDefineNode = searchIdDefine(vClient, vParams.textDocument.uri, {
				vParams.position.line,
				vParams.position.character,
			})
		end
		if nDefineNode then
			local nSymbolSet = vClient.runtime:getNodeSymbolSet(nDefineNode)
			local nNameToType = {}
			for nSymbol, _ in pairs(nSymbolSet) do
				local nType = nSymbol:getType()
				for k, v in pairs(nType:getCompletion()) do
					nNameToType[k] = v
				end
			end
			local l = {}
			for k,v in pairs(nNameToType) do
				l[#l + 1] = {
					label=k
				}
			end
			return l
		end
	end,
	hover=function(vClient:lsp.Client, vParams:HoverParams)
		local nDefineNode = searchIdDefine(vClient, vParams.textDocument.uri, vParams.position)
		if nDefineNode then
			local nSymbolSet = vClient.runtime:getNodeSymbolSet(nDefineNode)
			local l = {}
			for nSymbol, _ in pairs(nSymbolSet) do
				l[#l + 1] = tostring(nSymbol:getType())
			end
			local value = table.concat(l, ",")
			return {
				contents = {
					kind="markdown",
					value=value
				} @ MarkupContent
			}
		end
	end,
	references=function(vClient, vParams)
	end,
	typeDefinition=function(vClient, vParams)
	end,
}