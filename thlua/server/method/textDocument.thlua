
const json = require "thlua.server.json"
const TriggerCode = require "thlua.code.TriggerCode"
const CompletionRuntime = require "thlua.runtime.CompletionRuntime"
const Exception = require "thlua.Exception"

(@do
	let.lsp=import("thlua.server.protocol").lsp

	lsp.Position = Struct {
		line=Number,
		character=Number,
	}

	lsp.Range=Struct {
		start=lsp.Position,
		["end"]=lsp.Position,
	}

	let.TextDocumentIdentifier = Struct {
		uri=String,
	}

	lsp.VersionedTextDocumentIdentifier = Struct {
		version=Number,
		uri=String,
	}

	do
		let.TextDocumentPositionParams = Interface {
			textDocument=TextDocumentIdentifier
		}

		let.ProgressToken = Union(Integer, String)

		let.WorkDoneProgressParams = Interface {
			workDoneToke=OrNil(ProgressToken),
		}

		let.PartialResultParams = Interface {
			partialResultToken=OrNil(ProgressToken)
		}

		let.ReferenceParams = ExtendStruct ({
			context = Struct {
				includeDecleration = Boolean,
			}
		}, let.TextDocumentPositionParams, let.WorkDoneProgressParams, let.PartialResultParams)

		let.TypeDefinitionParams = ExtendStruct ({
		}, let.TextDocumentPositionParams, let.WorkDoneProgressParams, let.PartialResultParams)

	end

	let.DidChangeTextDocumentParams = Struct {
		textDocument=lsp.VersionedTextDocumentIdentifier,
		contentChanges=List(Struct {
			range=lsp.Range,
			rangeLength=OrNil(Number),
			text=String,
		}),
	}

	let.DidSaveTextDocumentParams = Struct {
		textDocument=lsp.VersionedTextDocumentIdentifier,
		text=OrNil(String),
	}

	let.DidCloseTextDocumentParams = Struct {
		textDocument=lsp.VersionedTextDocumentIdentifier,
	}

	let.DidOpenTextDocumentParams = Struct {
		textDocument = Struct {
			uri=String,
			languageId=String,
			version=Number,
			text=String,
		}
	}

	let.DefinitionParams = Struct {
		textDocument = TextDocumentIdentifier,
		position=lsp.Position,
	}

	let.HoverParams = Struct {
		textDocument = TextDocumentIdentifier,
		position=lsp.Position,
	}

	let.CompletionParams = Struct {
		textDocument = TextDocumentIdentifier,
		position=lsp.Position,
		context=OrNil(Struct {
			triggerKind=Union(1,2,3),
			triggerCharacter=OrNil(String),
		}),
	}

	let.PublishDiagnosticsParams = Struct {
		uri=String,
		version=OrNil(Number),
		diagnostics=List(Struct {
			range=lsp.Range,
			severity=OrNil(Struct {
			}),
			code=OrNil(Union(Number, String)),
			codeDescription=OrNil(Struct {
				href=String,
			}),
			source=OrNil(String),
			message=String,
			tags=OrNil(List(Union(1,2))),
			-- relatedInformation
			-- data
		}),
	}

	let.Location = Struct {
		uri=String,
		range=lsp.Range,
	}

	let.CompletionItem = Struct {
		label=String,
		labelDetails=OrNil(Struct{}),
		kind=Union(Nil,1,2,3,4,5,6,7,8),
		--tags=CompletionItemTag,
		detail=OrNil(String),
		documentation=OrNil(String),
		deprecated=OrNil(Boolean),
		preselect=OrNil(Boolean),
		sortText=OrNil(String),
		filterText=OrNil(String),
		insertText=OrNil(String),
		--....
	}

	let.MarkupContent = Struct {
		kind=Union("markdown", "plaintext"),
		value=String,
	}

end)

return {
	didChange=function(vServer:lsp.BaseServer, vParams:DidChangeTextDocumentParams)
		const nContentChange = vParams.contentChanges[1]
		if nContentChange then
			const nContent = nContentChange.text
			const nFileName = vServer:uriToPath(vParams.textDocument.uri)
			vServer:syncFile(nContent, nFileName, vParams.textDocument.version)
		else
			vServer:error("content change is empty onDidChange")
		end
		--vServer:rerun(nFileName)
	end,
	didOpen=function(vServer:lsp.BaseServer, vParams:DidOpenTextDocumentParams)
		local nContent = vParams.textDocument.text
		local nFileName = vServer:uriToPath(vParams.textDocument.uri)
		vServer:syncFile(nContent, nFileName, vParams.textDocument.version)
		vServer:rerun(nFileName)
	end,
	didSave=function(vServer:lsp.BaseServer, vParams:DidSaveTextDocumentParams)
		local nFileName = vServer:uriToPath(vParams.textDocument.uri)
		vServer:rerun(nFileName)
	end,
	didClose=function(vServer:lsp.BaseServer, vParams:DidCloseTextDocumentParams)
	end,
	definition=function(vServer:lsp.BaseServer, vParams:DefinitionParams):Ret(OrNil(Location))
		const nFileName = vServer:uriToPath(vParams.textDocument.uri)
		const nFileState = vServer:checkFileState(nFileName)
		const nSuccEnv = nFileState:getSuccEnv()
		if not nSuccEnv then
			return nil
		end
		const nSplitCode = nFileState:getSplitCode()
		const nPos = nSplitCode:lcToPos(vParams.position.line + 1, vParams.position.character + 1)
		const nNode = nSuccEnv:searchIdent(nPos)
		if not nNode then
			return nil
		end
		const nDefineNode = nNode.kind == "def" and nNode or nNode.defineIdent
		if not nDefineNode then
			vServer:error("global ident TODO")
			return nil
		end
		return {
			uri=vParams.textDocument.uri,
			range={
				start={ line=nDefineNode.l - 1, character=nDefineNode.c-1, },
				["end"]={ line=nDefineNode.l - 1, character=nDefineNode.c - 1 },
			}
		}
	end,
	completion=function(vServer:lsp.BaseServer, vParams:CompletionParams):Ret(List(CompletionItem))
		const nCompletionRuntime = vServer:checkRuntime()
		if not CompletionRuntime.is(nCompletionRuntime) then
			return {}
		end
		const nFileName = vServer:uriToPath(vParams.textDocument.uri)
		const nFileState = vServer:checkFileState(nFileName)
		const nSuccEnv = nFileState:getSuccEnv()
		if not nSuccEnv then
			return {}
		end
		const nSplitCode = nFileState:getSplitCode()
		const nPos = nSplitCode:lcToPos(vParams.position.line+1, vParams.position.character+1)
		const nContent = nSplitCode:getContent():sub(1, nPos)
		const nTriggerCode = TriggerCode.new(nContent, nFileName, 0)
		const nPos, nInjectFn = nTriggerCode:tryGenInjectFn()
		if not nPos then
			return {}
		end
		const nType = nCompletionRuntime:injectType(nPos, nSuccEnv, nInjectFn)
		local nRetList:List(CompletionItem) = {}
		for k,v in pairs(nType:getCompletion()) do
			nRetList[#nRetList + 1] = {
				label=k
			}
		end
		return nRetList
	end,
	hover=function(vServer:lsp.BaseServer, vParams:HoverParams)
		--[[
		local nFileName = vServer:uriToPath(vParams.textDocument.uri)
		local nDefineNode = vServer:searchDefine(nFileName, vParams.position.line + 1, vParams.position.character + 1)
		if nDefineNode then
			local nLocalSymbolSet = vServer:checkRuntime():getNodeLocalSymbolSet(nDefineNode)
			local l = {}
			for nLocalSymbol, _ in pairs(nLocalSymbolSet) do
				l[#l + 1] = tostring(nLocalSymbol:getType())
			end
			local value = table.concat(l, ",")
			return {
				contents = {
					kind="markdown",
					value=value
				} @ MarkupContent
			}
		end]]
	end,
	references=function(vServer:lsp.BaseServer, vParams:ReferenceParams) end,
	typeDefinition=function(vServer:lsp.BaseServer, vParams:TypeDefinitionParams) end,
}
