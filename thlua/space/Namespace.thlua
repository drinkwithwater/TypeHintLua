
const AsyncTypeCom = require "thlua.space.AsyncTypeCom"
const StringLiteral = require "thlua.type.basic.StringLiteral"
const BaseSpaceCom = require "thlua.space.BaseSpaceCom"
const SpaceValue = require "thlua.space.SpaceValue"
const BuiltinFnCom = require "thlua.space.BuiltinFnCom"
const Node = require "thlua.code.Node"
const class = require "thlua.class"

(@do
	let.clazz = import($class).clazz
end)

const Namespace = class@<clazz.Namespace, false>(BaseSpaceCom)
Namespace.__tostring=function(self):Ret(String)
	return "namespace-" .. tostring(self._node)
end

function.open Namespace:ctor(_, _, vRefer:clazz.NameReference, ...)
	self._key2child={} @ Dict(String, clazz.NameReference) -- (vIndexTable and setmetatable({}, {__index=vIndexTable}) or {})@StringToRefer,
	self._refer = vRefer
end

function.pass Namespace:getChild(vNode:clazz.IBaseNode, vKey:String):Ret(clazz.NameReference)
	error("abstract namespace get child not implement")
end

function.pass Namespace:spaceCompletion(vCompletion:clazz.FieldCompletion, vValue:clazz.BaseSpaceValue)
	error("abstract namespace putCompletion not implement")
end

function Namespace:getRefer():Ret(clazz.NameReference)
	return self._refer @> clazz.NameReference
end

return Namespace
