
const AsyncTypeCom = require "thlua.space.AsyncTypeCom"
const StringLiteral = require "thlua.type.basic.StringLiteral"
const BaseSpaceCom = require "thlua.space.BaseSpaceCom"
const SpaceValue = require "thlua.space.SpaceValue"
const BuiltinFnCom = require "thlua.space.BuiltinFnCom"
const Node = require "thlua.code.Node"
const class = require "thlua.class"

(@do
	let.clazz = import($class).clazz
end)

const Namespace = class@<clazz.Namespace, false>(BaseSpaceCom)
Namespace.__tostring=function(self):Ret(String)
	return "namespace-" .. tostring(self._node).."|"..tostring(self._key or "!keynotset")
end

function.open Namespace:ctor(_, _, vRefer:clazz.Reference, ...)
	self._key2child={} @ Dict(String, clazz.Reference) -- (vIndexTable and setmetatable({}, {__index=vIndexTable}) or {})@StringToRefer,
	self._key=false@Union(False, String)
	self._refer = vRefer
end

function.pass Namespace:getChild(vNode:clazz.IBaseNode, vKey:String):Ret(clazz.Reference)
	error("abstract namespace get child not implement")
end

function.pass Namespace:spaceCompletion(vCompletion:clazz.FieldCompletion, vValue:clazz.BaseSpaceValue)
	error("abstract namespace putCompletion not implement")
end

function Namespace:getRefer():Ret(clazz.Reference)
	return self._refer
end

return Namespace
