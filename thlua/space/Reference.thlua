
const Exception = require "thlua.Exception"
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const Node = require "thlua.code.Node"
const OldNamespace = require "thlua.space.OldNamespace"

const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const BaseUnionType = require "thlua.type.union.BaseUnionType"

const Namespace = require "thlua.space.Namespace"
const Letspace = require "thlua.space.Letspace"
const AsyncTypeCom = require "thlua.space.AsyncTypeCom"
const TemplateCom = require "thlua.space.TemplateCom"
const BuiltinCom = require "thlua.space.BuiltinCom"
const EasyMapCom = require "thlua.space.EasyMapCom"
const BaseSpaceCom = require "thlua.space.BaseSpaceCom"

const SpaceValue = require "thlua.space.SpaceValue"

const class = require "thlua.class"

(@do
	let.clazz = import($class).clazz
end)

const Reference = {}
Reference.__index = Reference

function Reference.__tostring(self:clazz.Reference):Ret(String)
	return "Reference tostring TODO"
end

function:class(clazz.Reference) Reference.new(vManager:clazz.TypeManager, vKey:String)
	const nTask = vManager:getScheduleManager():newTask()
	const self = setmetatable({.class
		_manager = vManager,
		id=vManager:genTypeId(),
		_task = nTask,
		_key=vKey,
		_assignNode=false@OrFalse(clazz.IBaseNode),
		_referNodes={}@List(clazz.IBaseNode),
		_assignComEvent = nTask:makeEvent(),
		_com=false@OrFalse(clazz.BaseSpaceCom),
		_spaceValue=nil@!clazz.LocalSpaceValue,
	}, Reference)
	self._spaceValue = SpaceValue.create(self)
	return self
end

function Reference:initWithSpace@<T>(vNode:clazz.IBaseNode, vData:T):Ret(Cond(T, clazz.Letspace, clazz.Namespace))
	assert(not self._assignNode, vNode:toExc("init space called after assignNode"))
	self._assignNode = vNode
	if vData then
		const nSpace = Letspace.new(self._manager, vNode, self, vData)
		self._com = nSpace
		return nSpace
	else
		const nSpace = Namespace.new(self._manager, vNode, self)
		self._com = nSpace
		return nSpace
	end
end

function Reference:getSpaceValue()
	return self._spaceValue
end

function Reference:getComNowait():Ret(OrFalse(clazz.BaseSpaceCom))
	return self._com
end

function Reference:getComAwait():Ret(clazz.BaseSpaceCom)
	if not self._com then
		self._assignComEvent:wait()
	end
	const nCom = assert(self._com, "com not setted after wait finish")
	return nCom
end

function Reference:waitAsyncTypeCom(vNode:clazz.IBaseNode):Ret(clazz.AsyncTypeCom)
	const nCom = self:getComAwait()
	assert(AsyncTypeCom.is(nCom), vNode:toExc("type reference expected, but got some other value"))
	return nCom
end

function Reference:waitTemplateCom(vNode:clazz.IBaseNode):Ret(clazz.TemplateCom)
	const nCom = self:getComAwait()
	assert(TemplateCom.is(nCom), vNode:toExc("template expected, but got some other value"))
	return nCom
end

function Reference:_setComAndWakeup(vCom:clazz.BaseSpaceCom)
	self._com = vCom
	self._assignComEvent:wakeup()
end

function Reference:setAssignAsync(vNode:clazz.IBaseNode, vGetFunc:Fn():Ret(Any))
	assert(not self._assignNode, vNode:toExc("refer has been setted:"..tostring(self)))
	self._assignNode = vNode
	self._task:runAsync(function()
		const nAssignValue = vGetFunc()
		if nAssignValue == OldNamespace then -- compatible for old version, TODO remove this
			const nSpace = Namespace.new(self._manager, vNode, self)
			self:_setComAndWakeup(nSpace)
		else
			const nRefer = SpaceValue.checkRefer(nAssignValue)
			if nRefer then
				self:_setComAndWakeup(nRefer:getComAwait())
			elseif BaseSpaceCom.is(nAssignValue) then
				self:_setComAndWakeup(nAssignValue)
			else
				if BaseAtomType.is(nAssignValue) then
					const nCom = self._manager:AsyncTypeCom()
					nCom:setTypeAsync(vNode, function()
						return nAssignValue
					end)
					self:_setComAndWakeup(nCom)
				elseif BaseUnionType.is(nAssignValue) then
					const nCom = self._manager:AsyncTypeCom()
					nCom:setTypeAsync(vNode, function()
						return nAssignValue
					end)
					self:_setComAndWakeup(nCom)
				else
					error(vNode:toExc("namespace assign an illegal value"))
				end
			end
		end
	end)
end

function Reference:getAssignNode():Ret(OrFalse(clazz.IBaseNode))
	return self._assignNode
end

function Reference:getReferNode():Ret(List(clazz.IBaseNode))
	return self._referNodes
end

function Reference:pushReferNode(vNode:clazz.IBaseNode)
	const nNodes = self._referNodes
	nNodes[#nNodes + 1] = vNode
end

function Reference:triggerGet(vNode:clazz.IBaseNode, vKeyType:clazz.IAtomType):Ret(clazz.USpaceValue)
	const nCom = self._com
	if Namespace.is(nCom) then
		const nChild = nCom:getChild(vNode, vKeyType)
		return nChild:getSpaceValue()
	elseif EasyMapCom.is(nCom) then
		return nCom:getValue(vNode, vKeyType)
	else
		error(vNode:toExc("only namespace or easymap can take index"))
	end
end

function Reference:triggerSet(vNode:clazz.IBaseNode, vKeyType:clazz.IAtomType, vValue:clazz.USpaceAny)
	const nCom = self._com
	if Namespace.is(nCom) then
		const nChild = nCom:getChild(vNode, vKeyType)
		if Reference.is(nChild) then
			nChild:setAssignAsync(vNode, function() return vValue end)
		else
			error(vNode:toExc("assign conflict: key="..tostring(vKeyType)))
		end
	elseif EasyMapCom.is(nCom) then
		nCom:setValue(vNode, vKeyType, vValue)
	else
		error(vNode:toExc("only namespace or easymap can take newindex"))
	end
end

function Reference:globalGet(vNode:clazz.IBaseNode, vKeyType:clazz.IAtomType):Ret(clazz.BaseSpaceValue)
	const nCom = self._com
	assert(Letspace.is(nCom), "only letspace com can take global index")
	const nRefer = nCom:pureGet(vKeyType)
	if Reference.is(nRefer) then
		return nRefer:getSpaceValue()
	elseif not nRefer then
        error(Exception.new("key with empty value, key="..tostring(vKeyType), vNode))
	else
		return nRefer
	end
end

function Reference:assertSpaceKeyType(vNode:clazz.IBaseNode, vKey:clazz.USpaceAny):Ret(clazz.IAtomType)
	const nOkay, nType = self._manager:getDirtyProcessor():peasyToMustType(vNode, vKey)
	if not nOkay then
		error(Exception.new(nType, vNode))
	end
	local nFinalKey = nType:checkAtomUnion()
	if not nFinalKey:isUnion() then
		return nFinalKey
	else
		error(Exception.new("namespace's key can't be union type", vNode))
	end
end

function Reference:triggerCall(vNode:clazz.IBaseNode, ...:clazz.USpaceAny):Ret(clazz.USpaceAny)
	const nCom = self._com
	if BuiltinCom.is(nCom) then
		return nCom:call(vNode, ...)
	end
	const nArgList:List(clazz.USpaceAny) = {...}
	const nArgNum = select("#", ...)
	if TemplateCom.is(nCom) then
		return nCom:call(vNode, nArgNum, nArgList)
	elseif nCom then
		error(Exception.new("template reference expected here", vNode))
	end
	const nTypeCom = self._manager:AsyncTypeCom()
	nTypeCom:setTypeAsync(vNode, function()
		const nCom = self:waitTemplateCom(vNode)
		return nCom:call(vNode, nArgNum, nArgList)
	end)
	return nTypeCom
end

function.open Reference.is(v):isguard(clazz.Reference)
	return getmetatable(v) == Reference
end

return Reference
