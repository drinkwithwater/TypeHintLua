

const CodeEnv = require "thlua.code.CodeEnv"
const SeverityEnum = require "thlua.runtime.SeverityEnum"
const FieldCompletion = require "thlua.stack.context.FieldCompletion"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"
const BaseReferSpace = require "thlua.space.BaseReferSpace"
const SpaceValue = require "thlua.space.SpaceValue"
const ListDict = require "thlua.utils.ListDict"
const NameReference = require "thlua.space.NameReference"
const BaseUnionType = require "thlua.type.union.BaseUnionType"
const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const class = require@<let.clazz> "thlua.class"

(@do
	let.node = import("thlua.code.Node").node
	let.InjectFn = import("thlua.code.CodeEnv").InjectFn
end)

const SpaceManager = class@<clazz.SpaceManager, false>()
function.open SpaceManager:ctor(vRuntime:clazz.BaseRuntime)
	self._runtime=vRuntime
	self._rootSpace=nil@OrNil(clazz.LetSpace)
	self._invalidReferSet = {} @ Dict(clazz.NameReference, True)
end

function SpaceManager:invalidReference(vRefer:clazz.NameReference)
	self._invalidReferSet[vRefer] = true
end

function SpaceManager:getNameDiagnostic(vUseWarn:OrNil(Boolean)):Ret(Dict(String, List(clazz.Diagnostic)))
	local nFileToDiaList:Dict(String, List(clazz.Diagnostic)) = {}
	for nRefer, _ in pairs(self._invalidReferSet) do
		const nNodes = nRefer:getReferNodes()
		for _, node in ipairs(nNodes) do
			const nPath = node.path
			local nList = nFileToDiaList[nPath]
			if not nList then
				nList = {}
				nFileToDiaList[nPath] = nList
			end
			nList[#nList + 1] = {
				msg="here refer not setted : "..tostring(nRefer),
				node=node,
				severity=vUseWarn and SeverityEnum.Warn or SeverityEnum.Error,
			}
		end
	end
	return nFileToDiaList
end

function SpaceManager:prebuildRootSpace():Ret(clazz.LetSpace)
	assert(not self._rootSpace, "root space is built")
	const nRefer = NameReference.new(self._runtime, self._runtime:getNode(), "")
	const nRootSpace = nRefer:initWithLetSpace(self._runtime:getNode(), false)
	self._rootSpace = nRootSpace
	return nRootSpace
end

function SpaceManager:getRootSpace():Ret(clazz.LetSpace)
	return self._rootSpace!
end

function SpaceManager:LetSpace(vRegionNode:clazz.IBaseNode, vParentLet:clazz.LetSpace):Ret(clazz.LetSpace)
	const nRefer = NameReference.new(self._runtime, vParentLet, "")
	const nSpace = nRefer:initWithLetSpace(self._runtime:getNode(), vParentLet)
	return nSpace
end

function SpaceManager:NameSpace(vNode:node.Debug, vParent:OrFalse(clazz.NameSpace)):Ret(clazz.NameSpace)
	const nRefer = NameReference.new(self._runtime, vParent or vNode, "")
	const nSpace = nRefer:initWithNameSpace(vNode, vParent)
	return nSpace
end

return SpaceManager