

const CodeEnv = require "thlua.code.CodeEnv"
const SeverityEnum = require "thlua.runtime.SeverityEnum"
const FieldCompletion = require "thlua.stack.context.FieldCompletion"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"
const BaseReferSpace = require "thlua.space.BaseReferSpace"
const SpaceValue = require "thlua.space.SpaceValue"
const ListDict = require "thlua.utils.ListDict"
const NameReference = require "thlua.space.NameReference"
const BaseUnionType = require "thlua.type.union.BaseUnionType"
const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const class = require@<let.clazz> "thlua.class"

(@do
	let.node = import("thlua.code.Node").node
	let.InjectFn = import("thlua.code.CodeEnv").InjectFn
end)

const SpaceManager = class@<clazz.SpaceManager, false>()
function.open SpaceManager:ctor(vRuntime:clazz.BaseRuntime)
	self._runtime=vRuntime
	self._invalidReferSet = {} @ Dict(clazz.NameReference, True)
end

function SpaceManager:invalidReference(vRefer:clazz.NameReference)
	self._invalidReferSet[vRefer] = true
end

function SpaceManager:getNameDiagnostic(vUseWarn:OrNil(Boolean)):Ret(Dict(String, List(clazz.Diagnostic)))
	local nFileToDiaList:Dict(String, List(clazz.Diagnostic)) = {}
	for nRefer, _ in pairs(self._invalidReferSet) do
		const nNodes = nRefer:getReferNodes()
		for _, node in ipairs(nNodes) do
			const nPath = node.path
			local nList = nFileToDiaList[nPath]
			if not nList then
				nList = {}
				nFileToDiaList[nPath] = nList
			end
			nList[#nList + 1] = {
				msg="here refer not setted : "..tostring(nRefer),
				node=node,
				severity=vUseWarn and SeverityEnum.Warn or SeverityEnum.Error,
			}
		end
	end
	return nFileToDiaList
end

return SpaceManager