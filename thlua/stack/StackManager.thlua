

const CodeEnv = require "thlua.code.CodeEnv"
const SeverityEnum = require "thlua.runtime.SeverityEnum"
const FieldCompletion = require "thlua.stack.context.FieldCompletion"
const TermTuple = require "thlua.tuple.TermTuple"
const RefineTerm = require "thlua.term.RefineTerm"
const BaseReferSpace = require "thlua.space.BaseReferSpace"
const SpaceValue = require "thlua.space.SpaceValue"
const ListDict = require "thlua.utils.ListDict"
const NameReference = require "thlua.space.NameReference"
const BaseUnionType = require "thlua.type.union.BaseUnionType"
const BaseAtomType = require "thlua.type.basic.BaseAtomType"
const class = require@<let.clazz> "thlua.class"
const OpenStack = require "thlua.stack.OpenStack"
const SealStack = require "thlua.stack.SealStack"
const DeduceStack = require "thlua.stack.DeduceStack"

(@do
	let.node = import("thlua.code.Node").node
	let.InjectFn = import("thlua.code.CodeEnv").InjectFn
end)

const StackManager = class@<clazz.StackManager, false>()
function.open StackManager:ctor(vRuntime:clazz.BaseRuntime)
	self._runtime=vRuntime
	self._nodeToBranchList = ListDict@<node.Block, clazz.Branch>()
	self._nodeToApplyContextList = ListDict@<clazz.IBaseNode, clazz.ApplyContext>()
end

function StackManager:SealStack(...):Ret(clazz.SealStack)
	return SealStack.new(self._runtime, ...)
end

function StackManager:DeduceStack(...):Ret(clazz.DeduceStack)
	return DeduceStack.new(self._runtime, ...)
end

function StackManager:OpenStack(...):Ret(clazz.OpenStack)
	return OpenStack.new(self._runtime, ...)
end

return StackManager