
const ImmutVariable = require "thlua.term.ImmutVariable"
const VariableCase = require "thlua.term.VariableCase"
const Nil = require "thlua.type.Nil"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const RefineTerm = {}
RefineTerm.__index=RefineTerm
RefineTerm.__bor=function(vLeft:clazz.RefineTerm, vRight:clazz.RefineTerm):Ret(clazz.RefineTerm)
	const nTypeCaseList:List(clazz.TypeCasePair) = {}
	vLeft:foreach(function(vType, vCase)
			nTypeCaseList[#nTypeCaseList + 1] = {vType, vCase}
	end)
	vRight:foreach(function(vType, vCase)
			nTypeCaseList[#nTypeCaseList + 1] = {vType, vCase}
	end)
	return vLeft._manager:mergeToRefineTerm(nTypeCaseList)
end
RefineTerm.__tostring=function(self:clazz.RefineTerm):Ret(String)
	const l:List(String) = {}
	for nType, nVariableCase in pairs(self._typeToCase) do
		l[#l + 1] = tostring(nType) .."=>"..tostring(nVariableCase)
	end
	return "RefineTerm("..table.concat(l, ",")..")"
end

function:class(clazz.RefineTerm) RefineTerm.new(
	vManager:clazz.TypeManager,
	vType:clazz.UAtomUnion,
	vTypeToCase:OrNil(Dict(clazz.IAtomType, clazz.VariableCase)))
	const self = setmetatable({.class
		_manager=vManager,
		_typeToCase=vTypeToCase or {}@Dict(clazz.IAtomType, clazz.VariableCase),
		_type=vType,
		_symbolVariable=false @ Union(False, clazz.ImmutVariable),
	}, RefineTerm)
	vType:foreach(function(vType)
		if not self._typeToCase[vType] then
			self._typeToCase[vType] = VariableCase.new()
		end
	end)
	return self
end

function RefineTerm:foreach(func:Fn(clazz.IAtomType, clazz.VariableCase))
	for nType, nVariableCase in pairs(self._typeToCase) do
		func(nType, nVariableCase)
	end
end

function.open RefineTerm.is(v):isguard(clazz.RefineTerm)
	return getmetatable(v) == RefineTerm
end

function RefineTerm:caseIsType(vGuardType:clazz.LuaTable):Ret(OrNil(clazz.VariableCase))
	local nCase:OrNil(clazz.VariableCase) = nil
	self._type:foreach(function(vType)
		if vType:containAll(vGuardType) then
			nCase = self._typeToCase[vType]
		end
	end)
	if not nCase then
		return nil
	else
		const nReCase = VariableCase.new() & nCase
		const nImmutVariable = self._symbolVariable
		if nImmutVariable then
			nReCase:put_and(nImmutVariable, vGuardType)
		end
		return nReCase
	end
end

function RefineTerm:caseIsNotType(vGuardType:clazz.LuaTable):Ret(OrNil(clazz.VariableCase))
	local reCase:OrNil(clazz.VariableCase) = nil
	self._type:foreach(function(vType)
		const nCase = self._typeToCase[vType]!
		if vGuardType ~= vType then
			if not reCase then
				reCase = nCase
			else
				reCase = reCase | nCase
			end
		end
	end)
	return reCase
end

function RefineTerm:caseTrue():Ret(OrNil(clazz.VariableCase))
	local reCase:OrNil(clazz.VariableCase) = nil
	self._type:trueType():foreach(function(vType)
		const nCase = self._typeToCase[vType]!
		if not reCase then
			reCase = nCase
		else
			reCase = reCase | nCase
		end
	end)
	return reCase
end

function RefineTerm:notnilTerm():Ret(clazz.RefineTerm)
	const nNotnilType = self._type:notnilType()
	const nTypeCaseList:List(clazz.TypeCasePair) = {}
	nNotnilType:foreach(function(vType)
		nTypeCaseList[#nTypeCaseList + 1] = {vType, self._typeToCase[vType]!}
	end)
	return self._manager:mergeToRefineTerm(nTypeCaseList)
end

function RefineTerm:caseNotnil():Ret(OrNil(clazz.VariableCase))
	local reCase:OrNil(clazz.VariableCase) = nil
	self._type:foreach(function(vType)
		if not Nil.is(vType) then
			const nCase = self._typeToCase[vType]!
			if not reCase then
				reCase = nCase
			else
				reCase = reCase | nCase
			end
		end
	end)
	return reCase
end

-- return VariableCase | nil
function RefineTerm:caseFalse():Ret(OrNil(clazz.VariableCase))
	local reCase:OrNil(clazz.VariableCase) = nil
	self._type:falseType():foreach(function(vType)
		const nCase = self._typeToCase[vType]!
		if not reCase then
			reCase = nCase
		else
			reCase = reCase | nCase
		end
	end)
	return reCase
end

function RefineTerm:falseTerm():Ret(clazz.RefineTerm)
	const nFalseType = self._type:falseType()
	const nTypeCaseList:List(clazz.TypeCasePair) = {}
	nFalseType:foreach(function(vType)
		nTypeCaseList[#nTypeCaseList + 1] = {vType, self._typeToCase[vType]!}
	end)
	return self._manager:mergeToRefineTerm(nTypeCaseList)
end

function RefineTerm:trueTerm():Ret(clazz.RefineTerm)
	const nTrueType = self._type:trueType()
	const nTypeCaseList:List(clazz.TypeCasePair) = {}
	nTrueType:foreach(function(vType)
		nTypeCaseList[#nTypeCaseList + 1] = {vType, self._typeToCase[vType]!}
	end)
	return self._manager:mergeToRefineTerm(nTypeCaseList)
end

function RefineTerm:notTerm():Ret(clazz.RefineTerm)
	const nTypeCaseList:List(clazz.TypeCasePair) = {}
	self._type:falseType():foreach(function(vType)
	nTypeCaseList[#nTypeCaseList + 1] = {
		self._manager.type.True,
		self._typeToCase[vType]!
	}
	end)
	self._type:trueType():foreach(function(vType)
	nTypeCaseList[#nTypeCaseList + 1] = {
		self._manager.type.False,
		self._typeToCase[vType]!
	}
	end)
	return self._manager:mergeToRefineTerm(nTypeCaseList)
end

function RefineTerm:getType():Ret(clazz.UAtomUnion)
	return self._type
end

function RefineTerm:and_case(vCase1:clazz.VariableCase)
	for nType, nCase2 in pairs(self._typeToCase) do
		self._typeToCase[nType] = vCase1 & nCase2
	end
end

function RefineTerm:initVariable(vImmutVariable:clazz.ImmutVariable)
	assert(not self._symbolVariable, "term can only set symbolshot once")
	self._symbolVariable = vImmutVariable
	for nType, nVariableCase in pairs(self._typeToCase) do
		const nNewVariableCase = VariableCase.new() & nVariableCase
		const nImmutVariable = self._symbolVariable
		if nImmutVariable then
			nNewVariableCase:put_and(nImmutVariable, nType)
		end
		self._typeToCase[nType] = nNewVariableCase
	end
end

function RefineTerm:filter(vType:clazz.UAllType):Ret(clazz.RefineTerm)
	const nTypeCaseList:List(clazz.TypeCasePair) = {}
	vType:foreach(function(vSubType)
		const nContainType = self._type:containAtom(vSubType)
		if nContainType then
			const nCase = self._typeToCase[nContainType]!
			nTypeCaseList[#nTypeCaseList + 1] = {vSubType, nCase}
		else
			nTypeCaseList[#nTypeCaseList + 1] = {vSubType, VariableCase.new()}
		end
	end)
	return self._manager:mergeToRefineTerm(nTypeCaseList)
end

function RefineTerm:attachImmutVariable():Ret(clazz.ImmutVariable)
	local nImmutVariable = self._symbolVariable
	if not nImmutVariable then
		nImmutVariable = ImmutVariable.new(self)
		self:initVariable(nImmutVariable)
	end
	return nImmutVariable
end

return RefineTerm
