

const TermCase = {}

(@let.class = import("thlua.type.TypeClass").class)

TermCase.__index = TermCase
TermCase.__bor=function(vLeftTermCase, vRightTermCase)::Ret(class.TermCase)
	const nNewTermCase = TermCase.new()
	for nSymbolShot, nLeftType in pairs(vLeftTermCase) do
		const nRightType = vRightTermCase[nSymbolShot]
		if nRightType then
			nNewTermCase[nSymbolShot] = nLeftType | nRightType
		end
	end
	return nNewTermCase
end
TermCase.__band=function(vLeftTermCase:class.TermCase, vRightTermCase:class.TermCase)::Ret(class.TermCase)
	const nNewTermCase = TermCase.new()
	for nSymbolShot, nLeftType in pairs(vLeftTermCase) do
		const nRightType = vRightTermCase[nSymbolShot]
		if nRightType then
			nNewTermCase[nSymbolShot] = nLeftType & nRightType
		else
			nNewTermCase[nSymbolShot] = nLeftType
		end
	end
	for nSymbolShot, nRightType in pairs(vRightTermCase) do
		if not vLeftTermCase[nSymbolShot] then
			nNewTermCase[nSymbolShot] = nRightType
		end
	end
	return nNewTermCase
end
TermCase.__tostring=function(self:class.TermCase)::Ret(String)
	const l:List(String)={"TermCase("}
	for nSymbolShot, vType in pairs(self) do
		l[#l + 1] = tostring(nSymbolShot).."->"..tostring(vType)
	end
	l[#l + 1] = ")"
	return table.concat(l)
end

function TermCase.new()::RetClass(class.TermCase, Dict(class.RefineTerm, class.UAtomUnion))
	return setmetatable({::Self()
	}, TermCase)
end

function TermCase:put_and(vSymbolShot:class.SymbolShot, vType)
	const nCurType = self[vSymbolShot]
	if not nCurType then
		self[vSymbolShot] = vType
	else
		self[vSymbolShot] = nCurType & vType
	end
end

function TermCase:empty()::Ret(Boolean)
	if next(self) then
		return true
	else
		return false
	end
end

function TermCase.is(t)::isguard(class.TermCase)
	return getmetatable(t) == TermCase
end

return TermCase
