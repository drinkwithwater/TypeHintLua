

local TermCase = {}

(@let.class = import("thlua.type.TypeClass").class)

TermCase.__index = TermCase
TermCase.__bor=function(vLeftTermCase, vRightTermCase)::Ret(class.TermCase)
	local nNewTermCase = TermCase.new()
	for nRefineTerm, nLeftType in pairs(vLeftTermCase) do
		local nRightType = vRightTermCase[nRefineTerm]
		if nRightType then
			nNewTermCase[nRefineTerm] = nLeftType | nRightType
		end
	end
	return nNewTermCase
end
TermCase.__band=function(vLeftTermCase:class.TermCase, vRightTermCase:class.TermCase)::Ret(class.TermCase)
	local nNewTermCase = TermCase.new()
	for nRefineTerm, nLeftType in pairs(vLeftTermCase) do
		local nRightType = vRightTermCase[nRefineTerm]
		if nRightType then
			nNewTermCase[nRefineTerm] = nLeftType & nRightType
		else
			nNewTermCase[nRefineTerm] = nLeftType
		end
	end
	for nRefineTerm, nRightType in pairs(vRightTermCase) do
		if not vLeftTermCase[nRefineTerm] then
			nNewTermCase[nRefineTerm] = nRightType
		end
	end
	return nNewTermCase
end
TermCase.__tostring=function(self:class.TermCase)::Ret(String)
	local l:List(String)={"TermCase("}
	for nRefineTerm, vType in pairs(self) do
		local nUnionSymbol = nRefineTerm:getUnionSymbol()
		l[#l + 1] = (nUnionSymbol and nUnionSymbol:getName() or "?").."->"..tostring(vType)
	end
	l[#l + 1] = ")"
	return table.concat(l)
end

function TermCase.new()::RetClass(class.TermCase, Dict(class.RefineTerm, class.UAtomUnion))
	return setmetatable({::Self()
	}, TermCase)
end

function TermCase:put_and(vRefineTerm:class.RefineTerm, vType)
	local nCurType = self[vRefineTerm]
	if not nCurType then
		self[vRefineTerm] = vType
	else
		self[vRefineTerm] = nCurType & vType
	end
end

function TermCase:put_or(vRefineTerm:class.RefineTerm, vType)
	local nCurType = self[vRefineTerm]
	if nCurType then
		self[vRefineTerm] = nCurType | vType
	end
end

function TermCase:empty()::Ret(Boolean)
	if next(self) then
		return true
	else
		return false
	end
end

function TermCase.is(t)::isguard(class.TermCase)
	return getmetatable(t) == TermCase
end

return TermCase
