
const RetTuples = {}
RetTuples.__index=RetTuples
RetTuples.__tostring=function(self)
	return self:detailString({}, false)
end

(@let.class = import("thlua.type.TypeClass").class)

function RetTuples.new(vManager:class.TypeManager)::RetClass(class.RetTuples)
	const self = setmetatable({::Self()
		_manager=vManager,
		_firstToTuple={} @ Dict(class.UAllType, class.TypeTuple),
		_tupleCount=0 @ Number,
		_tupleSizeMin=0x7FFFFFFF @ Number,
		_tupleSizeMax=0 @ Number,
	}, RetTuples)
	return self
end

function RetTuples:getTupleCount()::Ret(Number)
	return self._tupleCount
end

function RetTuples:getTupleMinMax()::Ret(Number, Number)
	return self._tupleSizeMin, self._tupleSizeMax
end

function RetTuples:Merge(vRetTuples:class.RetTuples)::Ret(class.RetTuples)
	assert(RetTuples.is(vRetTuples), "ret tuples must merge with ret tuples")
	local re = self
	for _, t in pairs(vRetTuples._firstToTuple) do
		re = re:Add(t)
	end
	return re
end

function RetTuples:Add(vTypeTuple:class.TypeTuple)::Ret(class.RetTuples)
	assert(not vTypeTuple:getRepeatType(), "RetTuples can't take TypeTuple with repeatType")
	if self._firstToTuple[vTypeTuple:get(1)] then
		return self
	else
		const nNew = RetTuples.new(self._manager)
		for nFirst, nTuple in pairs(self._firstToTuple) do
			nNew._firstToTuple[nFirst] = nTuple
		end
		const nLength = #vTypeTuple
		if nLength > self._tupleSizeMax then
			nNew._tupleSizeMax = nLength
		else
			nNew._tupleSizeMax = self._tupleSizeMax
		end
		if nLength < nNew._tupleSizeMin then
			nNew._tupleSizeMin = nLength
		else
			nNew._tupleSizeMin = self._tupleSizeMin
		end
		nNew._firstToTuple[vTypeTuple:get(1)] = vTypeTuple
		nNew._tupleCount = self._tupleCount + 1
		return nNew
	end
end

function RetTuples:detailString(vCache:Dict(class.IAtomType, String), vVerbose:Boolean)::Ret(String)
	local re:List(String) = {}
	for _, t in pairs(self._firstToTuple) do
		re[#re+1] = t:detailString(vCache, vVerbose)
	end
	return "("..table.concat(re, "|")..")"
end

function RetTuples:assumeContainTuples(vAssumeSet:OrNil(Dict(Integer, Boolean)), vRetTuples:class.RetTuples)::Ret(Boolean)
	for _, t in pairs(vRetTuples._firstToTuple) do
		if not self:assumeContainTuple(vAssumeSet, t) then
			return false
		end
	end
	return true
end

function RetTuples:containTuples(vRetTuples:class.RetTuples)::Ret(Boolean)
	return self:assumeContainTuples(nil, vRetTuples)
end

function RetTuples:assumeContainTuple(vAssumeSet:OrNil(Dict(Integer, Boolean)), vRightTypeTuple:class.TypeTuple)::Ret(Boolean)
	for _, t in pairs(self._firstToTuple) do
		if t:assumeContainTuple(vAssumeSet, vRightTypeTuple) then
			return true
		end
	end
	return false
end

function RetTuples:containTuple(vRightTypeTuple:class.TypeTuple)::Ret(Boolean)
	return self:assumeContainTuple(nil, vRightTypeTuple)
end

function RetTuples:foreach(vFunc:Fn(class.TypeTuple):Ret())
	for _, t in pairs(self._firstToTuple) do
		vFunc(t)
	end
end

function RetTuples:makeFirstType()::Ret(class.UAllType)
	const nCollection = self._manager:TypeCollection()
	for _, nTuple in pairs(self._firstToTuple) do
		nCollection:put(nTuple:get(1))
	end
	return nCollection:mergeToAtomUnion()
end

function RetTuples.is(t)::isguard(class.RetTuples)
	return getmetatable(t) == RetTuples
end

return RetTuples
