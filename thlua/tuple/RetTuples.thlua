
const class = require "thlua.class"

(@let.clazz = import($class).clazz)

const RetTuples = class@<clazz.RetTuples, false>()

RetTuples.__tostring=function(self:clazz.RetTuples)
	return self:detailString({}, false)
end

function.open RetTuples:ctor(
	vManager:clazz.TypeManager,
	vNode:clazz.IBaseNode,
	vTupleList:List(clazz.UTypeTuple),
	vErrType:OrFalse(clazz.UMustType)
)
	assert(#vTupleList > 0, "length of tuple list must be bigger than 0 when pass to RetTuples' constructor")
	const nAsyncFirstType = vManager:AsyncTypeCom(vNode)
	self._node=vNode
	self._manager=vManager
	self._firstType=nAsyncFirstType
	self._firstToTuple=nil@!OrNil(Dict(clazz.UMustType, clazz.UTypeTuple))
	self._errType = vErrType and self._manager:buildUnion(vNode, self._manager.type.String, vErrType) or self._manager.type.String
	nAsyncFirstType:setListAsync(vNode, function()
		const nIndependentList:List(clazz.UMustType) = {}
		const nFirstAtomList:List(clazz.IAtomType) = {}
		const nFirstToTuple:Dict(clazz.UMustType, clazz.UTypeTuple) = {}
		for _, nTuple in ipairs(vTupleList) do
			const nFirst = self._manager:getDirtyProcessor():easyToMustType(vNode, nTuple:get(1))
			assert(not nFirst:isNever(), "can't return never")
			nIndependentList[#nIndependentList + 1] = nFirst
			nFirstToTuple[nFirst] = nTuple
			nFirst:foreachAwait(function(vAtomType)
				nFirstAtomList[#nFirstAtomList + 1] = vAtomType
			end)
		end
		self._firstToTuple = nFirstToTuple
		return nFirstAtomList, function(vResultType)
			const nAtomUnion = nAsyncFirstType:checkAtomUnion()
			if not vManager:typeCheckIndependent(nIndependentList, vResultType) then
				error("return tuples' first type must be independent")
			end
		end
	end)
end

function RetTuples:waitFirstToTuple():Ret(Dict(clazz.UMustType, clazz.UTypeTuple))
	self._firstType:getListAwait()
	return self._firstToTuple!
end

function RetTuples:detailString(vCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
	local re:List(String) = {}
	for _, t in pairs(self:waitFirstToTuple()) do
		re[#re+1] = t:detailString(vCache, vVerbose)
	end
	return "("..table.concat(re, "|")..")"
end

function RetTuples:assumeIncludeTuples(vAssumeSet:OrNil(Dict(Integer, Boolean)), vRetTuples:clazz.RetTuples):Ret(Boolean)
	for _, t in pairs(vRetTuples:waitFirstToTuple()) do
		if not self:assumeIncludeTuple(vAssumeSet, t) then
			return false
		end
	end
	if not self._errType:assumeIncludeAll(vAssumeSet, vRetTuples._errType) then
		return false
	end
	return true
end

function RetTuples:includeTuples(vRetTuples:clazz.RetTuples):Ret(Boolean)
	return self:assumeIncludeTuples(nil, vRetTuples)
end

function RetTuples:assumeIncludeTuple(vAssumeSet:OrNil(Dict(Integer, Boolean)), vRightTypeTuple:clazz.UTypeTuple):Ret(Boolean)
	for _, t in pairs(self:waitFirstToTuple()) do
		if t:assumeIncludeTuple(vAssumeSet, vRightTypeTuple) then
			return true
		end
	end
	return false
end

function RetTuples:includeTuple(vRightTypeTuple:clazz.TypeTuple):Ret(Boolean)
	return self:assumeIncludeTuple(nil, vRightTypeTuple)
end

function RetTuples:foreachWithFirst(vFunc:Fn(clazz.UTypeTuple, clazz.UMustType):Ret())
	for nFirst, nTuple in pairs(self:waitFirstToTuple()) do
		vFunc(nTuple, nFirst)
	end
end

function RetTuples:getFirstType():Ret(clazz.UAtomUnion)
	return self._firstType:checkAtomUnion()
end

function RetTuples:getErrType():Ret(clazz.UAtomUnion)
	return self._errType:checkAtomUnion()
end

return RetTuples
