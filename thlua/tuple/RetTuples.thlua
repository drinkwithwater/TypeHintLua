
const class = require "thlua.class"

(@let.clazz = import($class).clazz)

const RetTuples = class@<clazz.RetTuples, false>()

RetTuples.__tostring=function(self:clazz.RetTuples)
	return self:detailString({}, false)
end

function.open RetTuples:ctor(
	vManager:clazz.TypeManager,
	vNode:clazz.IBaseNode,
	vTupleList:List(clazz.UTypeTuple),
	vErrType:OrFalse(clazz.UAllType)
)
	assert(#vTupleList > 0, "length of tuple list must be bigger than 0 when pass to RetTuples' constructor")
	const nFirstToTuple:Dict(clazz.UAllType, clazz.UTypeTuple) = {}
	for _, nTuple in ipairs(vTupleList) do
		const nFirst = nTuple:get(1)
		nFirstToTuple[nFirst] = nTuple
	end
	const nTask = vManager:getScheduleManager():newTask()
	const nAsyncFirstType = vManager:AsyncUnion(nTask)
	self._node=vNode
	self._task = nTask
	self._manager=vManager
	self._firstType=nAsyncFirstType
	self._firstToTuple=nFirstToTuple
	self._errType = vErrType and self._manager:buildUnion(vNode, self._manager.type.String, vErrType) or self._manager.type.String
	nTask:runAsync(function()
		const nIndependentList:List(clazz.UAllType) = {}
		const nFirstAtomList:List(clazz.IAtomType) = {}
		for _, nTuple in ipairs(vTupleList) do
			const nFirst = nTuple:get(1):checkAtomUnion()
			assert(not nFirst:isNever(), "can't return never")
			nIndependentList[#nIndependentList + 1] = nFirst
			nFirst:foreach(function(vAtomType)
				nFirstAtomList[#nFirstAtomList + 1] = vAtomType
			end)
		end
		const nAtomUnion = nAsyncFirstType:setAtomList(nFirstAtomList)
		if not vManager:typeCheckIndependent(nIndependentList, nAtomUnion) then
			error("return tuples' first type must be independent")
		end
	end)
end

function RetTuples:detailString(vCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
	local re:List(String) = {}
	for _, t in pairs(self._firstToTuple) do
		re[#re+1] = t:detailString(vCache, vVerbose)
	end
	return "("..table.concat(re, "|")..")"
end

function RetTuples:assumeIncludeTuples(vAssumeSet:OrNil(Dict(Integer, Boolean)), vRetTuples:clazz.RetTuples):Ret(Boolean)
	for _, t in pairs(vRetTuples._firstToTuple) do
		if not self:assumeIncludeTuple(vAssumeSet, t) then
			return false
		end
	end
	if not self._errType:assumeIncludeAll(vAssumeSet, vRetTuples._errType) then
		return false
	end
	return true
end

function RetTuples:includeTuples(vRetTuples:clazz.RetTuples):Ret(Boolean)
	return self:assumeIncludeTuples(nil, vRetTuples)
end

function RetTuples:assumeIncludeTuple(vAssumeSet:OrNil(Dict(Integer, Boolean)), vRightTypeTuple:clazz.UTypeTuple):Ret(Boolean)
	for _, t in pairs(self._firstToTuple) do
		if t:assumeIncludeTuple(vAssumeSet, vRightTypeTuple) then
			return true
		end
	end
	return false
end

function RetTuples:includeTuple(vRightTypeTuple:clazz.TypeTuple):Ret(Boolean)
	return self:assumeIncludeTuple(nil, vRightTypeTuple)
end

function RetTuples:foreachWithFirst(vFunc:Fn(clazz.UTypeTuple, clazz.UAllType):Ret())
	for nFirst, nTuple in pairs(self._firstToTuple) do
		vFunc(nTuple, nFirst)
	end
end

function RetTuples:getFirstType():Ret(clazz.UAtomUnion)
	return self._firstType:getTypeAwait()
end

function RetTuples:getErrType():Ret(clazz.UAtomUnion)
	return self._errType:checkAtomUnion()
end

return RetTuples
