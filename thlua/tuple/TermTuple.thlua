
const Exception = require "thlua.Exception"
const AutoHolder = require "thlua.auto.AutoHolder"
const DotsTail = require "thlua.tuple.DotsTail"
const AutoTail = require "thlua.auto.AutoTail"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	clazz.AutoTermTuple = clazz.TermTuple(true)
	clazz.FixedTermTuple = clazz.TermTuple(false)
	clazz.UTermTuple = Union(clazz.AutoTermTuple, clazz.FixedTermTuple)
	let.Element = Template(function(T)
		if clazz.FixedTermTuple:containAll(T) then
			return clazz.RefineTerm
		elseif clazz.AutoTermTuple:containAll(T) then
			return clazz.UAutoTerm
		else
			error("template TermTuple.thlua:let.Element can't take other type as argument:"..tostring(T))
		end
	end)
	let.Tail = Template(function(T)
		if clazz.FixedTermTuple:containAll(T) then
			return OrFalse(clazz.DotsTail)
		elseif clazz.AutoTermTuple:containAll(T) then
			return OrFalse(clazz.DotsTail, clazz.AutoTail)
		else
			error("template TermTuple.thlua:let.Tail can't take other type as argument:"..tostring(T))
		end
	end)
	let.CheckTuple = Template(function(T)
		if clazz.FixedTermTuple:containAll(T) then
			return clazz.UTypeTuple
		elseif clazz.AutoTermTuple:containAll(T) then
			return OrFalse(clazz.UTypeTuple)
		else
			error("template TermTuple.thlua:let.Element can't take other type as argument:"..tostring(T))
		end
	end)
end)

const TermTuple = {}

TermTuple.__index=TermTuple
TermTuple.__tostring=function(self:clazz.UTermTuple):Ret(String)
	const re:List(String) = {}
	for i=1, #self do
		re[i] = tostring(self._list[i]!:getType())
	end
	const nTail = self._tail
	if nTail then
		re[#re + 1] = tostring(nTail) .."*"
	end
	if self._auto then
		return "AutoTermTuple("..table.concat(re, ",")..")"
	else
		return "FixedTermTuple("..table.concat(re, ",")..")"
	end
end

TermTuple.__len=function(self:clazz.UTermTuple)
	return #self._list
end

function:class(clazz.TermTuple) TermTuple.new@<Auto>(
	vContext:clazz.Context,
	vAuto:Auto,
	vTermList:Cond(Auto, List(clazz.UAutoTerm), List(clazz.RefineTerm)),
	vTail:Cond(Auto, OrFalse(clazz.DotsTail, clazz.AutoTail), OrFalse(clazz.DotsTail)),
	vTypeTuple:OrFalse(clazz.UTypeTuple)
)
	const self = setmetatable({.class
		_context=vContext,
		_manager=vContext:getTypeManager(),
		_list=vTermList,
		_tail=vTail,
		_typeTuple=vTypeTuple,
		_auto=vAuto,
	}, TermTuple)
	return self
end

function TermTuple:select(vContext:clazz.Context, i:Integer):Ret(Union(Self, clazz.FixedTermTuple))
	const nList:$self._list = {}
	for n=i,#self._list do
		nList[#nList + 1] = self._list[n]
	end
	-- TODO check i in range
	if self._auto then
		return self._context:UTermTupleByTail(nList, self._tail)
	else
		return self._context:FixedTermTuple(nList, self:getRepeatType())
	end
end

function TermTuple:rawget(i:Number):Ret(OrNil(let.Element(Self)))
	return self._list[i]
end

function TermTuple:checkFixed(vContext:clazz.Context, i:Number):Ret(clazz.RefineTerm)
	const nTerm = self:get(vContext, i)
	return nTerm:checkRefineTerm(vContext)
end

function TermTuple:get(vContext:clazz.Context, i:Number):Ret(let.Element(Self))
	const nMore = i - #self
	if nMore <= 0 then
		return self._list[i]!
	else
		const nTail = self._tail
		if nTail then
			return nTail:getMore(vContext, nMore)
		else
			return self._manager:RefineTerm(self._manager.type.Nil)
		end
	end
end

function TermTuple:getContext():Ret(clazz.Context)
	return self._context
end

function TermTuple:checkTypeTuple():Ret(let.CheckTuple(Self))
	if self._auto then
		const nTypeList:List(clazz.UAllType) = {}
		for i,v in ipairs(self._list) do
			const nType = v:getType()
			if not nType then
				return false
			end
			nTypeList[i] = nType
		end
		const nTail = self._tail
		if AutoTail.is(nTail) then
			const nTailTuple = nTail:checkTypeTuple(self:getContext())
			if not nTailTuple then
				return false
			else
				for i=1,#nTailTuple do
					nTypeList[#nTypeList + 1] = nTailTuple:get(i)
				end
				const nFinalTuple = self._manager:TypeTuple(self:getContext():getNode(), table.unpack(nTypeList))
				const nRepeatType = nTailTuple:getRepeatType()
				if nRepeatType then
					return nFinalTuple:Dots(nRepeatType)
				else
					return nFinalTuple
				end
			end
		else
			const nTuple = self._manager:TypeTuple(self:getContext():getNode(), table.unpack(nTypeList))
			if not nTail then
				return nTuple
			else
				return nTuple:Dots(nTail:getRepeatType())
			end
		end
	else
		local nTypeTuple = self._typeTuple
		if not nTypeTuple then
			const nList:List(clazz.UAllType) = {}
			for i,v in ipairs(self._list) do
				nList[i] = v:getType()
			end
			nTypeTuple = self._manager:TypeTuple(self._context:getNode(), table.unpack(nList))
			const nTail = self._tail
			if nTail then
				nTypeTuple = nTypeTuple:Dots(nTail:getRepeatType())
			end
			self._typeTuple = nTypeTuple
			return nTypeTuple
		else
			return nTypeTuple
		end
	end
end

function TermTuple:getTail():Ret(let.Tail(Self))
	return self._tail
end

function TermTuple:getRepeatType():Ret(OrFalse(clazz.UAllType))
	const nTail = self._tail
	if DotsTail.is(nTail) then
		return nTail:getRepeatType()
	else
		return false
	end
end

function.open TermTuple.is(t)
	return TermTuple.isAuto(t) or TermTuple.isFixed(t)
end

function.open TermTuple.isAuto(t):isguard(clazz.AutoTermTuple)
	return getmetatable(t) == TermTuple and t._auto
end

function.open TermTuple.isFixed(t):isguard(clazz.FixedTermTuple)
	return getmetatable(t) == TermTuple and not t._auto
end

return TermTuple
