
(@let.clazz = import("thlua.type.TypeClass").clazz)

const TermTuple = {}

TermTuple.__index=TermTuple
TermTuple.__tostring=function(self:clazz.TermTuple):Ret(String)
	const re:List(String) = {}
	for i=1, #self do
		re[i] = tostring(self._list[i])
	end
	const nTail = self._tail
	if nTail then
		re[#re + 1] = tostring(nTail) .."*"
	end
	return "TermTuple("..table.concat(re, ",")..")"
end

TermTuple.__bor=function(vLeftTuple:clazz.TermTuple, vRightTuple:clazz.TermTuple):Ret(clazz.TermTuple)
	const nLen = math.max(#vLeftTuple, #vRightTuple)
	const l:List(clazz.RefineTerm) = {}
	const nNil = vLeftTuple._manager.type.Nil
	print("term tuple bor TODO")
	for i=1, nLen do
		const nLeftTerm = vLeftTuple:rawget(i)
		const nRightTerm = vRightTuple:rawget(i)
		if nLeftTerm and nRightTerm then
			l[i] = nLeftTerm | nRightTerm
		else
			l[i] = nLeftTerm or nRightTerm or vLeftTuple._manager:RefineTerm(nNil)
		end
	end
	return vLeftTuple:getContext():TermTuple(l)
end

TermTuple.__len=function(self:clazz.TermTuple)
	return #self._list
end


function:class(clazz.TermTuple) TermTuple.new(vContext:clazz.Context, vTermList:List(clazz.RefineTerm), vTail:OrFalse(clazz.UAllType), vTypeTuple:OrFalse(clazz.UTypeTuple))
	const self = setmetatable({.class
		_context=vContext,
		_manager=vContext:getTypeManager(),
		_list=vTermList,
		_tail=vTail,
		_repeatTermList={}@List(clazz.RefineTerm),
		_typeTuple=vTypeTuple,
	}, TermTuple)
	return self
end

function TermTuple:select(i:Integer):Ret(clazz.TermTuple)
	const nList:List(clazz.RefineTerm) = {}
	for n=i,#self._list do
		nList[#nList + 1] = self._list[n]
	end
	for n=1,#self._repeatTermList do
		nList[#nList + 1] = self._repeatTermList[n]
	end
	return self._context:TermTuple(nList)
end

function TermTuple:rawget(i:Number):Ret(OrNil(clazz.RefineTerm))
	return self._list[i]
end

function TermTuple:get(vContext:clazz.Context, i:Number):Ret(clazz.RefineTerm)
	const more = i - #self
	if more <= 0 then
		return self._list[i]!
	else
		local nTerm = self._repeatTermList[more]
		const nRepeatType = self:getTail()
		if not nTerm then
			local nNil = self._manager.type.Nil
			if nRepeatType then
				nTerm = self._manager:RefineTerm(self._manager:checkedUnion(nRepeatType, nNil))
			else
				-- TODO
				-- vContext:error("tuple unpack but args not enough, index="..i)
				nTerm = self._manager:RefineTerm(nNil)
			end
			self._repeatTermList[more] = nTerm
			return nTerm
		else
			return nTerm
		end
	end
end

function TermTuple:getContext():Ret(clazz.Context)
	return self._context
end

function TermTuple:getDots(vContext:clazz.Context, vStart:Integer):Ret(clazz.TermTuple)
	return self:checkTypeTuple():select(vStart):makeTermTuple(vContext)
end

function TermTuple:checkTypeTuple():Ret(clazz.UTypeTuple)
	local nTypeTuple = self._typeTuple
	if not nTypeTuple then
		const nList:List(clazz.UAllType) = {}
		for i,v in ipairs(self._list) do
			nList[i] = v:getType()
		end
		nTypeTuple = self._manager:TypeTuple(self._context:getNode(), table.unpack(nList))
		const nTail = self._tail
		if nTail then
			nTypeTuple = nTypeTuple:Dots(nTail)
		end
		self._typeTuple = nTypeTuple
		return nTypeTuple
	else
		return nTypeTuple
	end
end

function TermTuple:getTail():Ret(Union(clazz.UAllType, False))
	return self._tail
end

function.open TermTuple.is(t):isguard(clazz.TermTuple)
	return getmetatable(t) == TermTuple
end

return TermTuple
