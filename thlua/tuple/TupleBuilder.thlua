
const class = require "thlua.class"

(@do
    let.clazz = import($class).clazz
end)

const TupleBuilder = class@<clazz.TupleBuilder, false>()

function.open TupleBuilder:ctor(vManager:clazz.TypeManager, vNode:clazz.IBaseNode, ...:clazz.USpaceAny)
	self._manager = vManager
	self._node = vNode
    self._num = select("#", ...)
    self._list = {...} @ List(clazz.USpaceAny)
    self._dots = nil @ clazz.USpaceAny
    self._polyTypeArgList = nil @ OrNil(List(clazz.UMustType))
    self._polyTypeArgSign = nil @ OrNil(String)
end

function TupleBuilder:setRetDots()
    const num = self._num
    assert(num > 0, self._node:toExc("RetDots must take at least 1 value"))
    self._num = num - 1
    const l = self._list
    self._dots = l[num]
    l[num] = nil
end

function TupleBuilder:chainDots(vDots:clazz.USpaceAny)
    const nNode = self._node
    assert(not self._dots, nNode:toExc("Dots has been setted"))
    assert(vDots ~= nil, nNode:toExc("Dots can't take nil"))
    self._dots = vDots
end

function TupleBuilder:buildTuple():Ret(clazz.UTypeTuple)
    const nNode = self._node
    const nSpaceTuple = self._list
    const nTypeList:List(clazz.UMustType) = {}
    for i=1, self._num do
        nTypeList[i] = self._manager:easyToMustType(nNode, nSpaceTuple[i])
    end
    const nTypeTuple = self._manager:TypeTuple(nNode, nTypeList)
    const nDotsType = self._dots
    if nDotsType == nil then
        return nTypeTuple
    else
        const nDotsMustType = self._manager:easyToMustType(nNode, nDotsType)
        return nTypeTuple:withDots(nDotsMustType)
    end
end

function TupleBuilder:getArgNum():Ret(Integer)
    return self._num
end

function TupleBuilder:getArgList():Ret(List(clazz.USpaceAny))
    return self._list
end

function TupleBuilder:checkTemplateArgSign():Ret(String)
    if not self._polyTypeArgSign then
        self._polyTypeArgSign = self._manager:signTemplateArgs(self:buildPolyArgs())
    end
    return self._polyTypeArgSign!
end

function TupleBuilder:buildPolyArgs():Ret(List(clazz.UMustType))
    if not self._polyTypeArgList then
        assert(self._dots == nil, "tuple with dots can't checkout to typelist")
        const nNode = self._node
        const nSpaceTuple = self._list
        const nTypeList:List(clazz.UMustType) = {}
        for i=1, self._num do
            nTypeList[i] = self._manager:easyToMustType(nNode, nSpaceTuple[i]):checkAtomUnion()
        end
        self._polyTypeArgList = nTypeList
    end
    return self._polyTypeArgList!
end

function TupleBuilder:argsMatch(vNode:clazz.IBaseNode, vParamInfo:clazz.ParamInfo)
	if vParamInfo.dots then
		if self:getArgNum() < vParamInfo.num then
			error(vNode:toExc("template args num not enough"))
		end
	else
		if self:getArgNum() ~= vParamInfo.num then
			error(vNode:toExc("template args num not match"))
		end
	end
end

function TupleBuilder:getNode()
    return self._node
end

return TupleBuilder
