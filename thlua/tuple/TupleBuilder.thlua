
const class = require "thlua.class"

(@do
    let.clazz = import($class).clazz
    let.USpaceTuple = Interface({
        [Integer]=clazz.USpaceAny,
        n=Integer,
    }, {__len=Integer})
end)

const TupleBuilder = class@<clazz.TupleBuilder, false>()

function.open TupleBuilder:ctor(vManager:clazz.TypeManager, vNode:clazz.IBaseNode, ...:clazz.USpaceAny)
	self._manager = vManager
    const nDirtyProcessor = vManager:getDirtyProcessor()
    self._dirtyProcessor = nDirtyProcessor
    self._list = table.pack(...) @ USpaceTuple
    self._dots = nil @ clazz.USpaceAny
	self._node = vNode
end

function TupleBuilder:setRetDots()
    const l = self._list
    const n = l.n
    assert(n > 0, self._node:toExc("RetDots must take at least 1 value"))
    self._list = {n = n-1, table.unpack(l, 1, n-1)}
    self._dots = l[#l-1]!
end

function TupleBuilder:chainDots(vDots:clazz.USpaceAny)
    const nNode = self._node
    assert(not self._dots, nNode:toExc("Dots has been setted"))
    assert(vDots ~= nil, nNode:toExc("Dots can't take nil"))
    self._dots = vDots
end

function TupleBuilder:buildTuple():Ret(clazz.UTypeTuple)
    const nNode = self._node
    const nSpaceTuple = self._list
    const nTypeList:List(clazz.UMustType) = {}
    for i=1, nSpaceTuple.n do
        nTypeList[i] = self._dirtyProcessor:easyToMustType(nNode, nSpaceTuple[i])
    end
    const nTypeTuple = self._manager:TypeTuple(nNode, nTypeList)
    const nDotsType = self._dots
    if nDotsType == nil then
        return nTypeTuple
    else
        const nDotsMustType = self._dirtyProcessor:easyToMustType(nNode, nDotsType)
        return nTypeTuple:withDots(nDotsMustType)
    end
end

function TupleBuilder:buildPolyArgs():Ret(Integer, List(clazz.UMustType))
    const nNode = self._node
    const nSpaceTuple = self._list
    const nTypeList:List(clazz.UMustType) = {}
    for i=1, nSpaceTuple.n do
        nTypeList[i] = self._dirtyProcessor:easyToMustType(nNode, nSpaceTuple[i])
    end
    return nSpaceTuple.n, nTypeList
end

return TupleBuilder
