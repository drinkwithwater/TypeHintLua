
const TermTuple = require "thlua.tuple.TermTuple"

(@do
	let.clazz = import("thlua.type.TypeClass").clazz
	clazz.UTypeTuple = Union(clazz.TypeTuple, clazz.TypeTupleDots)
end)

const function.open TupleClass()
	const t = {}
	t.__index=t
	t.__tostring=function(self)
		return self:detailString({}, false)
	end
	function t.__len(self):Ret(Number)
		return #self._list
	end
	function t:detailStringIfFirst(vCache:Dict(Truth, String), vVerbose:Boolean, vHasFirst:Boolean):Ret(String)
		const re:List(String) = {}
		const nStartIndex = vHasFirst and 1 or 2
		for i=nStartIndex, #self do
			re[#re + 1] = self._list[i]!:detailString(vCache, vVerbose)
		end
		const nRepeatType = self:getRepeatType()
		if nRepeatType then
			re[#re + 1] = nRepeatType:detailString(vCache, vVerbose) .."*"
		end
		return "Tuple("..table.concat(re, ",")..")"
	end
	function t:detailString(vCache:Dict(Truth, String), vVerbose:Boolean):Ret(String)
		return self:detailStringIfFirst(vCache, vVerbose, true)
	end
	function t:makeTermTuple(vContext:clazz.OperContext):Ret(clazz.FixedTermTuple)
		const nTermList:List(clazz.RefineTerm) = {}
		for i=1, #self do
			nTermList[i] = self._manager:RefineTerm(self._list[i]!)
		end
		return vContext:FixedTermTuple(nTermList, self:getRepeatType(), self)
	end
	function t:assumeIncludeTuple(vAssumeSet:OrNil(Dict(Integer, Boolean)), vRightTypeTuple:clazz.UTypeTuple):Ret(Boolean)
		const nLeftRepeatType = self:getRepeatType()
		const nRightRepeatType = vRightTypeTuple:getRepeatType()
		if (not nLeftRepeatType) and nRightRepeatType then
			return false
		end
		if nLeftRepeatType and nRightRepeatType then
			if not nLeftRepeatType:assumeIncludeAll(vAssumeSet, nRightRepeatType) then
				return false
			end
		end
		-- TODO thinking more for nilable
		for i=1, #vRightTypeTuple do
			const nLeftType = self._list[i] or nLeftRepeatType
			if not nLeftType then
				return false
			end
			if not nLeftType:assumeIncludeAll(vAssumeSet, vRightTypeTuple:get(i)) then
				return false
			end
		end
		for i=#vRightTypeTuple + 1, #self do
			const nLeftType = self._list[i]!:checkAtomUnion()
			if not nLeftType:isNilable() then
				return false
			end
			if nRightRepeatType then
				if not nLeftType:assumeIncludeAll(vAssumeSet, nRightRepeatType) then
					return false
				end
			end
		end
		return true
	end
	function t:makeParHintStruct():Ret(clazz.ParHintStruct)
		return {dots=self:getRepeatType() or nil, table.unpack(self._list)}
	end
	function t:includeTuple(vRightTypeTuple:clazz.UTypeTuple):Ret(Boolean)
		return self:assumeIncludeTuple(nil, vRightTypeTuple)
	end
	return t
end

return TupleClass
