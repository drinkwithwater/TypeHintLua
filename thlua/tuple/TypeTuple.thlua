
const Reference = require "thlua.refer.Reference"
const TupleClass = require "thlua.tuple.TupleClass"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const Nil = require "thlua.type.basic.Nil"
const TypeTuple = TupleClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.TypeTuple) TypeTuple.new(vManager:clazz.TypeManager, vNode:clazz.IBaseNode, vList:List(clazz.UAllType))
	const self = setmetatable({.class
		_manager=vManager,
		_node=vNode,
		_list=vList,
	}, TypeTuple)
	return self
end

function TypeTuple:getRepeatType():Ret(False)
	return false
end

function TypeTuple:Dots(vType:clazz.UAllType):Ret(clazz.TypeTupleDots)
	const nWithNil = self._manager:buildUnion(self._node, vType, self._manager.type.Nil)
	return TypeTupleDots.new(self._manager, self._node, self._list, vType, nWithNil)
end

function TypeTuple:leftAppend(vType:clazz.UAllType):Ret(clazz.TypeTuple)
	return TypeTuple.new(self._manager, self._node, {vType, table.unpack(self._list)})
end

function TypeTuple:get(i:Number):Ret(clazz.UAllType)
	return self._list[i] or self._manager.type.Nil
end

function TypeTuple:select(i:Integer):Ret(clazz.TypeTuple)
	return self._manager:TypeTuple(self._node, {table.unpack(self._list, i)})
end

function.open TypeTuple.is(t):isguard(clazz.TypeTuple)
	return getmetatable(t) == TypeTuple
end

return TypeTuple
