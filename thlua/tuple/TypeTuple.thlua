
local Reference = require "thlua.type.Reference"
local TupleClass = require "thlua.tuple/TupleClass"
local TypeTupleDots = require "thlua.tuple.TypeTupleDots"
local TypeTuple = TupleClass()

(@let.class = import("thlua.type.TypeClass").class)

function TypeTuple.new(vManager:class.TypeManager, vList:List(class.IValueType))::RetNew(class.TypeTuple)
	local self = setmetatable({::New()
		_manager=vManager,
		_structSign=(false @ Union(String, False)),
		_list=vList,
		_repeatType=false,
	}, TypeTuple)
	return self
end

function TypeTuple:getRepeatType()::Ret(False)
	return false
end

function TypeTuple:Dots(vType:class.IValueType)
	return TypeTupleDots.new(self._manager, self._list, vType)
end

function TypeTuple:replaceFirst(vType:class.IKeyType)::Ret(class.TypeTuple)
	local nTuple = self._manager:Tuple(vType, table.unpack(self._list, 2))
	return nTuple
end

function TypeTuple:get(i:Number)::Ret(class.IValueType)
	return self._list[i] or self._manager.type.Nil
end

function TypeTuple:castOrIn(vContext, vDstTypeTuple)
	for i, nDstType in ipairs(vDstTypeTuple._list) do
		local nSrcType = self:get(i)
		if not vContext:cast(nSrcType, nDstType) then
			if not nDstType:contain(nSrcType) then
				return false
			end
		end
	end
	return true
end

function TypeTuple:select(i)::Ret(class.TypeTuple)
	return self._manager:Tuple(table.unpack(self._list, i))
end

function TypeTuple.is(t)::isguard(class.TypeTuple)
	return getmetatable(t) == TypeTuple
end

return TypeTuple
