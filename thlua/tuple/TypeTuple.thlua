
const Reference = require "thlua.refer.Reference"
const TupleClass = require "thlua.tuple.TupleClass"
const TypeTupleDots = require "thlua.tuple.TypeTupleDots"
const Nil = require "thlua.type.Nil"
const TypeTuple = TupleClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.TypeTuple) TypeTuple.new(vManager:clazz.TypeManager, vNode:clazz.IAstNode, vList:List(clazz.UAllType))
	const self = setmetatable({.class
		_manager=vManager,
		_node=vNode,
		_list=vList,
	}, TypeTuple)
	return self
end

function TypeTuple:getRepeatType():Ret(False)
	return false
end

function TypeTuple:Dots(vType:clazz.UAllType):Ret(clazz.TypeTupleDots)
	const nWithNil = self._manager:buildUnion(self._node, vType, self._manager.type.Nil)
	const nNoNilRefer = self._manager:Reference(false)
	nNoNilRefer:setUnionAsync(self._node, function()
		const nAtomList:List(clazz.IAtomType) = {}
		vType:foreachAwait(function(vAtom)
			if not Nil.is(vAtom) then
				nAtomList[#nAtomList + 1] = vAtom
			end
		end)
		return nAtomList
	end)
	return TypeTupleDots.new(self._manager, self._node, self._list, nNoNilRefer, nWithNil)
end

function TypeTuple:replaceFirst(vType:clazz.UAllType):Ret(clazz.TypeTuple)
	return TypeTuple.new(self._manager, self._node, {vType, table.unpack(self._list, 2)})
end

function TypeTuple:get(i:Number):Ret(clazz.UAllType)
	return self._list[i] or self._manager.type.Nil
end

function TypeTuple:castOrIn(vContext:clazz.Context, vDstTypeTuple:clazz.UTypeTuple):Ret(Boolean)
	if #self < #vDstTypeTuple then
		for i=#self + 1, #vDstTypeTuple do
			if not vDstTypeTuple:get(i):checkAtomUnion():isNilable() then
				return false
			end
		end
	elseif #vDstTypeTuple < #self then
		const nDstRepeatType = vDstTypeTuple:getRepeatType()
		if not nDstRepeatType then
			return false
		else
			for i=#vDstTypeTuple + 1, #self do
				const nSelfi = self:get(i):checkAtomUnion()
				if not vContext:castLuaType(nSelfi, nDstRepeatType) then
					if not nDstRepeatType:containAll(nSelfi) then
						return false
					end
				end
			end
		end
	end
	for i=1, #vDstTypeTuple do
		const nDstType = vDstTypeTuple:get(i)
		const nSrcType = self:get(i)
		if not vContext:castLuaType(nSrcType, nDstType) then
			if not nDstType:containAll(nSrcType) then
				return false
			end
		end
	end
	return true
end

function TypeTuple:select(i:Integer):Ret(clazz.TypeTuple)
	return self._manager:TypeTuple(self._node, table.unpack(self._list, i))
end

function.open TypeTuple.is(t):isguard(clazz.TypeTuple)
	return getmetatable(t) == TypeTuple
end

return TypeTuple
