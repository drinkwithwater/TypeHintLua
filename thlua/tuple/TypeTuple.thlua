
local Reference = require "thlua.type.Reference"
local TupleClass = require "thlua.tuple/TupleClass"
local TypeTupleDots = require "thlua.tuple.TypeTupleDots"
local TypeTuple = TupleClass()

(@var.class = import("thlua.type.TypeClass").class)

function TypeTuple.new(vManager:class.TypeManager, vList:List(class.IValueType))::RetNew(class.TypeTuple)
	local self = setmetatable({::Self()
		_manager=vManager,
		_structSign=(false @ Union(String, False)),
		_list=vList,
		_repeatType=false,
	}, TypeTuple)
	return self
end

function TypeTuple:getRepeatType()::Ret(False)
	return false
end

function TypeTuple:Dots(vType:class.IValueType)
	return TypeTupleDots.new(self._manager, self._list, vType)
end

function TypeTuple:replaceFirst(vType:class.IKeyType)::Ret(class.TypeTuple)
	local nTuple = self._manager:Tuple(vType, table.unpack(self._list, 2))
	return nTuple
end

function TypeTuple:get(i:Number)::Ret(class.IValueType)
	return self._list[i] or self._manager.type.Nil
end

function TypeTuple:cast(vContext, vRightTypeTuple)
	for i, nRightType in ipairs(vRightTypeTuple._list) do
		self._manager:cast(vContext, nRightType, self:get(i))
	end
	return self:contain(vRightTypeTuple)
end

function TypeTuple:select(i)::Ret(class.TypeTuple)
	return self._manager:Tuple(table.unpack(self._list, i))
end

function TypeTuple.is(t)::isguard(class.TypeTuple)
	return getmetatable(t) == TypeTuple
end

return TypeTuple
