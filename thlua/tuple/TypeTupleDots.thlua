
const TupleClass = require "thlua.tuple.TupleClass"
const TypeTupleDots = TupleClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.TypeTupleDots) TypeTupleDots.new(
	vManager:clazz.TypeManager,
	vNode:clazz.IAstNode,
	vList:List(clazz.UAllType),
	vRepeatType:clazz.UAllType,
	vRepeatTypeWithNil:clazz.UAllType
)
	const self = setmetatable({.class
		_manager=vManager,
		_node=vNode,
		_list=vList,
		_repeatType=vRepeatType,
		_repeatTypeWithNil=vRepeatTypeWithNil,
	}, TypeTupleDots)
	return self
end

function TypeTupleDots:getRepeatType():Ret(clazz.UAllType)
	return self._repeatType
end

function TypeTupleDots:replaceFirst(vType:clazz.UAllType):Ret(clazz.TypeTupleDots)
	return TypeTupleDots.new(self._manager, self._node, {vType, table.unpack(self._list, 2)}, self._repeatType, self._repeatTypeWithNil)
end

function TypeTupleDots:get(i:Number):Ret(clazz.UAllType)
	if i <= #self then
		return self._list[i]!
	else
		return self._repeatTypeWithNil
	end
end

function TypeTupleDots:select(i:Integer):Ret(clazz.TypeTupleDots)
	const nList: List(clazz.UAllType) = {table.unpack(self._list, i)}
	return TypeTupleDots.new(self._manager, self._node, nList, self._repeatType, self._repeatTypeWithNil)
end

function TypeTupleDots:castOrIn(vContext:clazz.Context, vDstTypeTuple:clazz.UTypeTuple):Ret(Boolean)
	const nRepeatDstType = vDstTypeTuple:getRepeatType()
	if not nRepeatDstType then
		return false
	else
		const nRepeatSrcType = self._repeatType
		if not vContext:castLuaType(nRepeatSrcType, nRepeatDstType) then
			if not nRepeatDstType:containAll(nRepeatSrcType) then
				return false
			end
		end
	end
	for i=1, #vDstTypeTuple do
		const nDstType = vDstTypeTuple:get(i)
		const nSrcType = self:get(i)
		if not vContext:castLuaType(nSrcType, nDstType) then
			if not nDstType:containAll(nSrcType) then
				return false
			end
		end
	end
	return true
end

function.open TypeTupleDots.is(t):isguard(clazz.TypeTupleDots)
	return getmetatable(t) == TypeTupleDots
end

return TypeTupleDots
