
local TupleClass = require "thlua.tuple/TupleClass"
local TypeTupleDots = TupleClass()

(@var.class = import("thlua.type.TypeClass").class)

function TypeTupleDots.new(
	vManager:class.TypeManager,
	vList:List(class.IValueType),
	vRepeatType:class.IValueType)::RetNew(class.TypeTupleDots)
	local self = setmetatable({::New()
		_manager=vManager,
		_structSign=(false @ Union(String, False)),
		_list=vList,
		_repeatType=vRepeatType,
	}, TypeTupleDots)
	return self
end

function TypeTupleDots:getRepeatType()::Ret(class.IValueType)
	return self._repeatType
end

function TypeTupleDots:replaceFirst(vType)
	local nList: List(class.IValueType) = {vType, table.unpack(self._list, 2)}
	return TypeTupleDots.new(self._manager, nList, self._repeatType)
end

function TypeTupleDots:get(i)
	if i <= #self then
		return self._list[i]
	else
		return self._repeatType
	end
end

function TypeTupleDots:select(i)
	local nList: List(class.IValueType) = {table.unpack(self._list, i)}
	return TypeTupleDots.new(self._manager, nList, self._repeatType)
end

function TypeTupleDots:castOrIn(vContext, vDstTypeTuple)
	local nRepeatDstType = vDstTypeTuple:getRepeatType()
	if not nRepeatDstType then
		return false
	else
		local nRepeatSrcType = self._repeatType
		if not vContext:cast(nRepeatSrcType, nRepeatDstType) then
			if not nRepeatDstType:contain(nRepeatSrcType) then
				return false
			end
		end
	end
	for i, nDstType in ipairs(vDstTypeTuple._list) do
		local nSrcType = self:get(i)
		if not vContext:cast(nSrcType, nDstType) then
			if not nDstType:contain(nSrcType) then
				return false
			end
		end
	end
	return true
end

function TypeTupleDots.is(t)
	return getmetatable(t) == TypeTupleDots
end

return TypeTupleDots
