
const TupleClass = require "thlua.tuple.TupleClass"
const TypeTupleDots = TupleClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.TypeTupleDots) TypeTupleDots.new(
	vManager:clazz.TypeManager,
	vNode:clazz.IBaseNode,
	vList:List(clazz.UAllType),
	vRepeatType:clazz.UAllType,
	vRepeatTypeWithNil:clazz.UAllType
)
	const self = setmetatable({.class
		_manager=vManager,
		_node=vNode,
		_list=vList,
		_repeatType=vRepeatType,
		_repeatTypeWithNil=vRepeatTypeWithNil,
	}, TypeTupleDots)
	return self
end

function TypeTupleDots:getRepeatType():Ret(clazz.UAllType)
	return self._repeatType
end

function TypeTupleDots:leftAppend(vType:clazz.UAllType):Ret(clazz.TypeTupleDots)
	return TypeTupleDots.new(self._manager, self._node, {vType, table.unpack(self._list)} @ List(clazz.UAllType), self._repeatType, self._repeatTypeWithNil)
end

function TypeTupleDots:get(i:Integer):Ret(clazz.UAllType)
	if i <= #self then
		return self._list[i]!
	else
		return self._repeatTypeWithNil
	end
end

function TypeTupleDots:select(i:Integer):Ret(clazz.TypeTupleDots)
	const nList: List(clazz.UAllType) = {table.unpack(self._list, i)}
	return TypeTupleDots.new(self._manager, self._node, nList, self._repeatType, self._repeatTypeWithNil)
end

function.open TypeTupleDots.is(t):isguard(clazz.TypeTupleDots)
	return getmetatable(t) == TypeTupleDots
end

return TypeTupleDots
