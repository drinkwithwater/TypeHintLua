

const ReadyTypeClass = require "thlua.type.ReadyTypeClass"
const Exception = require "thlua.Exception"
const OPER_ENUM = require "thlua.type.OPER_ENUM"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const function.open AtomTypeClass()
	const t = ReadyTypeClass()
	function t:foreach(vFunc)
		vFunc(self)
	end
	function t:isSingleton()
		error(tostring(self).."is singleton TODO")
		return false
	end
	--- meta method --------------
	function.pass t:meta_ipairs(vContext)
		error(tostring(self).."meta_ipairs not implement")
	end
	function t:meta_pairs(vContext)
		error(tostring(self).."meta_pairs not implement")
		return false
	end
	function t:meta_set(vContext, vKeyType, vValueType)
		vContext:error(tostring(self).." can't take set index")
	end
	function t:meta_get(vContext, vKeyType)
		vContext:error(tostring(self).." can't take get index")
		return self._manager.type.Never
	end
	function t:meta_call(vContext, vTypeTuple)
		vContext:error(tostring(self).." can't take call")
		vContext:pushRetTuples(self._manager:VoidRetTuples())
	end
	function t:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
		if #vPolyArgs > 0 then
			const nCast = self:castPoly(vContext, vPolyArgs) or self
			nCast:meta_call(vContext, vTypeTuple)
		else
			self:meta_call(vContext, vTypeTuple)
		end
	end
	function t:meta_bop_func(vContext, vOper)
		if OPER_ENUM.mathematic[vOper] then
			return false, self._manager.builtin.bop.mathematic
		elseif OPER_ENUM.bitwise[vOper] then
			return false, self._manager.builtin.bop.bitwise
		elseif OPER_ENUM.comparison[vOper] then
			return false, self._manager.builtin.bop.comparison
		elseif vOper == ".." then
			return false, self._manager.builtin.bop.concat
		else
			vContext:error("invalid bop:"..tostring(vOper))
			return false, nil
		end
	end
	function t:meta_len(vContext)
		vContext:error(tostring(self).." can't take len oper")
		return self._manager.type.Number
	end
	function t:meta_uop_some(vContext, vOper)
		vContext:error(tostring(self).." can't take uop :"..vOper)
		return self._manager.type.Number
	end
	--- native method --------------
	function.pass t:native_next(vContext, vInitType)
		error("native_next not implement")
	end
	function t:native_tostring()
		return self._manager.type.String
	end
	function t:native_rawget(vContext, vKeyType)
		vContext:error(tostring(self).." rawget not implement")
		return self._manager.type.Nil
	end
	function t:native_rawset(vContext, vKeyType, vValueType)
		vContext:error(tostring(self).." rawset not implement")
	end
	function t:castPoly(vContext, vTypeArgsList)
		vContext:error("poly cast can't work on this type:"..tostring(self))
		return false
	end
	function t:native_type()
		print("native_type not implement ")
		return self._manager.type.String
	end
	function t:native_getmetatable(vContext)
		return self._manager.type.Nil
	end
	function t:native_setmetatable(vContext, vTable)
		error(Exception.new(tostring(self).." setmetatable not implement"))
	end
	function t:checkBaseObjectType()
		return false
	end
	function t:assumeIncludeAtom(vAssumeSet, vRight)
		error(tostring(self).."assumeIncludeAtom not implement")
	end
	function t:assumeIntersectAtom(vAssumeSet, vRight)
		error(tostring(self).."assumeIntersectAtom TODO")
	end
	function t:lockAsMetaIndex()
		return false
	end
	function t:lockAsMetaNewIndex()
		return false
	end
	return t
end

return AtomTypeClass
