

const Exception = require "thlua.Exception"
const FieldCompletion = require "thlua.context.FieldCompletion"
const OPER_ENUM = require "thlua.type.OPER_ENUM"

const class = require "thlua.class"
const BaseReadyType = require "thlua.type.BaseReadyType"

(@let.clazz = import($class).clazz)

const BaseAtomType = class@<clazz.BaseAtomType, clazz.IAtomType>(BaseReadyType)

function.open BaseAtomType:ctor(vManager:clazz.TypeManager, ...)
	self.id = vManager:genTypeId()
	self.bits = false @? Integer
	self._manager:atomRecordTypeUnionSign(self)
end

function BaseAtomType.__bor(vLeft:clazz.UAllType, vRight:clazz.UAllType):Ret(clazz.UAtomUnion)
	return vLeft._manager:checkedUnion(vLeft, vRight)
end

function BaseAtomType:foreach(vFunc)
	vFunc(self)
end

function BaseAtomType:isSingleton()
	error(tostring(self).."is singleton TODO")
	return false
end

--- meta method --------------
function BaseAtomType:meta_ipairs(vContext)
	vContext:error(tostring(self).."'s meta_ipairs not implement")
	return false
end

function BaseAtomType:meta_pairs(vContext)
	vContext:error(tostring(self).."'s meta_pairs not implement")
	return false
end

function BaseAtomType:meta_set(vContext, vKeyType, vValueType)
	vContext:error(tostring(self).." can't take set index")
end

function BaseAtomType:meta_get(vContext, vKeyType)
	vContext:error(tostring(self).." can't take get index")
	return false
end

function BaseAtomType:meta_call(vContext, vTypeTuple)
	vContext:error(tostring(self).." can't take call")
	vContext:pushRetTuples(self._manager:VoidRetTuples(vContext:getNode()))
end

function BaseAtomType:meta_invoke(vContext, vSelfType, vPolyArgs, vTypeTuple)
	if #vPolyArgs > 0 then
		const nCast = self:castPoly(vContext, vPolyArgs) or self
		nCast:meta_call(vContext, vTypeTuple)
	else
		self:meta_call(vContext, vTypeTuple)
	end
end

function BaseAtomType:meta_bop_func(vContext, vOper)
	if OPER_ENUM.mathematic[vOper] then
		return false, self._manager.builtin.bop.mathematic
	elseif OPER_ENUM.bitwise[vOper] then
		return false, self._manager.builtin.bop.bitwise
	elseif OPER_ENUM.comparison[vOper] then
		return false, self._manager.builtin.bop.comparison
	elseif vOper == ".." then
		return false, self._manager.builtin.bop.concat
	else
		vContext:error("invalid bop:"..tostring(vOper))
		return false, nil
	end
end

function BaseAtomType:meta_len(vContext)
	vContext:error(tostring(self).." can't take len oper")
	return self._manager.type.Number
end

function BaseAtomType:meta_uop_some(vContext, vOper)
	vContext:error(tostring(self).." can't take uop :"..vOper)
	return self._manager.type.Number
end

--- native method --------------
function.pass BaseAtomType:native_next(vContext, vInitType)
	error("native_next not implement")
end

function BaseAtomType:native_tostring()
	return self._manager.type.String
end

function BaseAtomType:native_rawget(vContext, vKeyType)
	vContext:error(tostring(self).." rawget not implement")
	return self._manager.type.Nil
end

function BaseAtomType:native_rawset(vContext, vKeyType, vValueType)
	vContext:error(tostring(self).." rawset not implement")
end

function BaseAtomType:castPoly(vContext, vTypeArgsList)
	vContext:error("poly cast can't work on this type:"..tostring(self))
	return false
end

function BaseAtomType:native_type()
	print("native_type not implement ")
	return self._manager.type.String
end

function BaseAtomType:native_getmetatable(vContext)
	return self._manager.type.Nil
end

function BaseAtomType:native_setmetatable(vContext, vTable)
	error(Exception.new(tostring(self).." setmetatable not implement"))
end

function BaseAtomType:checkTypedObject()
	return false
end

function BaseAtomType:isUnion()
	return false
end

function BaseAtomType:checkAtomUnion()
	return self
end

function BaseAtomType:isNever()
	return false
end

function BaseAtomType:isNilable()
	return false
end

function BaseAtomType:assumeIncludeAtom(vAssumeSet, vRightType, vSelfType)
	if self == vRightType then
		return self
	else
		return false
	end
end

function BaseAtomType:assumeIntersectAtom(vAssumeSet, vRightType)
	if self == vRightType then
		return self
	elseif vRightType:assumeIncludeAtom(nil, self) then
		return self
	elseif self:assumeIncludeAtom(nil, vRightType) then
		return vRightType
	else
		return false
	end
end

function BaseAtomType:putCompletion(vCompletion)
end

function BaseAtomType:findRequireStack():Ret(OrFalse(clazz.OpenStack))
	return false
end

return BaseAtomType
