
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const AtomTypeClass = require "thlua.type.AtomTypeClass"

const Nil = AtomTypeClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.Nil) Nil.new(vManager:clazz.TypeManager):impl(clazz.IAtomType)
	const self = setmetatable({.class
		_manager=vManager,
		id=vManager:genTypeId(),
		bits=TYPE_BITS.NIL,
	}, Nil)
	return self
end

function Nil:detailString(v, vVerbose)
	return "Nil"
end

function Nil:native_getmetatable(vContext)
	return self._manager.type.Nil
end

function Nil:native_type()
	return self._manager:Literal("nil")
end

function Nil:isSingleton()
	return true
end

function Nil:assumeIntersectAtom(vAssumeSet, vType)
	if self == vType then
		return self
	else
		return false
	end
end

function Nil:assumeIncludeAtom(vAssumeSet, vType)
	if self == vType then
		return self
	else
		return false
	end
end

function Nil:trueType()
    return self._manager.type.Never
end

function Nil:falseType()
    return self
end

function Nil:isNilable()
	return true
end

function Nil:notnilType()
    return self._manager.type.Never
end

function.open Nil.is(v):isguard(clazz.Nil)
	return getmetatable(v) == Nil
end

return Nil
