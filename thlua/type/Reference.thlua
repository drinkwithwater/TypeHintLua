
local TypeClass = require "thlua.type.TypeClass"
local TypeCollection = require "thlua.manager.TypeCollection"
local Exception = require "thlua.Exception"
local TYPE_BITS = require "thlua.type.TYPE_BITS"

local Reference = TypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function Reference.new(vManager:class.TypeManager, vKeyOrFalse:Union(String, False))::RetClass(class.Reference)
	local self = setmetatable({::Self()
		_manager=vManager,
		_key=vKeyOrFalse,
		id=vManager:genTypeId(),
		bits=false,
		_waitRefer=false@Union(False, class.Reference),
		_collection=false@Union(False, class.TypeCollection),
		_referType=(false @ Union(class.UAtomUnion, False)),
		_thread=false,
		_waitThreads={},
	}, Reference)
	return self
end

function Reference:trySetKey(vKey:String)
	if not self._key then
		self._key = vKey
	end
end

function Reference:detailString(v)::Ret(String)
	if self._referType and not self._key then
		return "`"..self._referType:detailString(v)
	else
		return "Reference("..(self._key or "!nameless")..")"

	end
end

(@let.RawItem = Union(class.IAtomType, class.TypeCollection))

function Reference:setRawAsync(vFunc:Fn():Ret(let.RawItem))::nocheck()
	assert(not self._thread, "refer has been setted:"..tostring(self))
	assert(not self._referType, "refer has type"..tostring(self))
	local co = coroutine.create(function()
		local nTypeOrCollection = vFunc()
		if TypeCollection.is(nTypeOrCollection) then
			self._collection = nTypeOrCollection
		else
			self._referType = nTypeOrCollection
			if self._referType.setReferName and self._key then
				self._referType:setReferName(self._key)
			end
		end
		local l = self._waitThreads
		for i=#l,1,-1 do
			assert(coroutine.resume(l[i]))
		end
	end)
	self._manager.coToRefer[co] = self
	self._thread = co
	assert(coroutine.resume(co))
end

function Reference:getRawAwait()::Ret(let.RawItem)
	local nReturn = self._referType or self._collection
	if not nReturn then
		local co, _ = coroutine.running()
		local nWaitingRefer = self._manager.coToRefer[co]!
		assert(nWaitingRefer, "can only call getRawAwait in Reference's coroutine")
		nWaitingRefer._waitRefer = self
		local nCurRefer = self._waitRefer
		while nCurRefer do
			if nCurRefer == self then
				error(Exception.new("recursive build type"))
			else
				nCurRefer = nCurRefer._waitRefer
			end
		end
		local l = self._waitThreads
		l[#l+1] = coroutine.running()
		coroutine.yield()
		nWaitingRefer._waitRefer = false
	end
	return self._referType or self._collection
end

function Reference:getType()
	return self._referType
end

function Reference:checkAtomUnion()::Ret(class.UAtomUnion)
	local nReferType = self._referType
	if not nReferType then
		assert(self._collection, Exception.new("reference "..tostring(self).." has not been setted"))
		nReferType = self._collection:mergeToAtomUnion()
		self._referType = nReferType
		if self._referType.setReferName and self._key then
			self._referType:setReferName(self._key)
		end
	end
	return nReferType
end

function Reference:isNilable()
	return self:checkAtomUnion():isNilable()
end

function Reference:isUnion()
	return self:checkAtomUnion():isUnion()
end

function Reference:isReference()
	return true
end

function Reference:foreach(vFunc:Fn(class.IAtomType):Ret())
	if self._referType then
		self._referType:foreach(vFunc)
	else
		self._collection:foreach(vFunc)
	end
end

function Reference:_intersectOneNotRefer(vType:class.IAtomType)::Ret(Union(class.UAtomUnion, False))
	return self:checkAtomUnion():_intersectOneNotRefer(vType)
end

function Reference:_containOneNotRefer(vType:class.IAtomType)::Ret(Union(class.UAtomUnion, False))
	return self:checkAtomUnion():_containOneNotRefer(vType)
end

function Reference:trueType()
	return self:checkAtomUnion():trueType()
end

function Reference:falseType()
	return self:checkAtomUnion():falseType()
end

function Reference.is(v)::isguard(class.Reference)
	return getmetatable(v) == Reference
end

return Reference
