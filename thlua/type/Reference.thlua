
local TypeClass = require "thlua.type.TypeClass"
local TypeCollection = require "thlua.manager.TypeCollection"
local Exception = require "thlua.Exception"
local TYPE_BITS = require "thlua.type.TYPE_BITS"

local Reference = TypeClass()

(@let.class = import("thlua.type.TypeClass").class)

function Reference.new(vManager:class.TypeManager, vKeyOrFalse:OrFalse(String))::RetClass(class.Reference, class.IType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_key=vKeyOrFalse,
		_setNode=false@OrFalse(class.AstNode),
		id=vManager:genTypeId(),
		bits=false,
		_waitRefer=false@OrFalse(class.Reference),
		_listType=false@OrFalse(List(class.IAtomType)),
		_resultType=false@OrFalse(class.UAtomUnion),
		_isInterfaceKey=true@Boolean,
		_thread=false,
		_waitListThreads={},
		_waitResultThreads={},
	}, Reference)
	return self
end

function Reference:detailString(v)::Ret(String)
	return "Reference("..(self._key or tostring(self._setNode))..")"
end

function Reference:setTypeAsync(vNode:class.AstNode, vType:Union(class.Reference, class.IAtomType))
	if Reference.is(vType) then
		self:setRawAsync(vNode, function()
			return vType:getListAwait()
		end, function(_)
			return vType:getTypeAwait()
		end)
	else
		assert(not vType:isUnion(), "set type async can't take IUnionType")
		self:setRawAsync(vNode, function()
			return {vType}
		end, function(_)
			return vType
		end)
	end
end

function Reference:setRawAsync(vNode:class.AstNode,
	vGetList:Fn():Ret(List(class.IAtomType)),
	vMakeType:Fn(List(class.IAtomType)):Ret(class.UAtomUnion))::nocheck()
	assert(not self._setNode, Exception.new("refer has been setted:"..tostring(self), vNode))
	self._setNode = vNode
	local co = coroutine.create(function()
		local ok, nListOrExc = pcall(vGetList)
		if not ok then
			if Exception.is(nListOrExc) then
				nListOrExc:fixNode(vNode)
				error(nListOrExc)
			else
				error(Exception.new(tostring(nListOrExc), vNode))
			end
		end
		self._listType = nListOrExc
		for _, nType in ipairs(nListOrExc) do
			if not nType:isStrNumLiteral() then
				self._isInterfaceKey = false
				break
			end
		end
		local l = self._waitListThreads
		for i=#l,1,-1 do
			assert(coroutine.resume(l[i]))
		end
		local ok, nTypeOrExc = pcall(vMakeType, nListOrExc)
		if not ok then
			if Exception.is(nTypeOrExc) then
				nTypeOrExc:fixNode(vNode)
				error(nTypeOrExc)
			else
				error(Exception.new(tostring(nTypeOrExc), vNode))
			end
		end
		self._resultType = nTypeOrExc
		if not nTypeOrExc:isUnion() then
			local nKey = self._key
			if nKey then
				nTypeOrExc:addNamedReference(self, nKey)
			end
		end
		local l = self._waitResultThreads
		for i=#l,1,-1 do
			assert(coroutine.resume(l[i]))
		end
	end)
	self._manager.coToRefer[co] = self
	self._thread = co
	assert(coroutine.resume(co))
end

function Reference:getTypeAwait()::Ret(class.UAtomUnion)
	local nReturn = self._resultType
	if not nReturn then
		local co, _ = coroutine.running()
		local nWaitingRefer = self._manager.coToRefer[co]
		assert(nWaitingRefer, "can only call getTypeAwait in Reference's coroutine:"..tostring(self))
		nWaitingRefer._waitRefer = self
		local nCurRefer = self._waitRefer
		while nCurRefer do
			if nCurRefer == self then
				error(Exception.new("recursive build type"))
			else
				nCurRefer = nCurRefer._waitRefer
			end
		end
		local l = self._waitResultThreads
		l[#l+1] = coroutine.running()
		coroutine.yield()
		nWaitingRefer._waitRefer = false
	end
	return (assert(self._resultType, "result type not setted"))
end

function Reference:getListAwait()::Ret(List(class.IAtomType))
	local nReturn = self._listType
	if not nReturn then
		local co, _ = coroutine.running()
		local nWaitingRefer = self._manager.coToRefer[co]
		assert(nWaitingRefer, "can only call getListAwait in Reference's coroutine:"..tostring(self))
		nWaitingRefer._waitRefer = self
		local nCurRefer = self._waitRefer
		while nCurRefer do
			if nCurRefer == self then
				error(Exception.new("recursive build type"))
			else
				nCurRefer = nCurRefer._waitRefer
			end
		end
		local l = self._waitListThreads
		l[#l+1] = coroutine.running()
		coroutine.yield()
		nWaitingRefer._waitRefer = false
	end
	return (assert(self._listType, "type list not setted"))
end

function Reference:getSetNode()::Ret(OrFalse(class.AstNode))
	return self._setNode
end

function Reference:getType()::Ret(OrFalse(class.UAtomUnion))
	return self._resultType
end

function Reference:checkAtomUnion()::Ret(class.UAtomUnion)
	local nReferType = self._resultType
	if not nReferType then
		error(Exception.new("reference "..tostring(self).." has not been setted"))
	end
	return nReferType
end

function Reference:isNilable()
	return self:checkAtomUnion():isNilable()
end

function Reference:isUnion()::Ret(Boolean)
	return self:checkAtomUnion():isUnion()
end

function Reference:isReference()::Ret(True)
	return true
end

function Reference:foreachAwait(vFunc)
	if self._resultType then
		self._resultType:foreach(vFunc)
	else
		local nListType = self:getListAwait()
		for _, v in ipairs(nListType) do
			vFunc(v)
		end
	end
end

function Reference:foreach(vFunc)
	if self._resultType then
		self._resultType:foreach(vFunc)
	else
		error("TODO"..debug.traceback())
		local nListType = self:getListAwait()
		for _, v in ipairs(nListType) do
			vFunc(v)
		end
	end
end

function Reference:intersectAtom(vType:class.IAtomType)::Ret(OrFalse(class.UAtomUnion))
	return self:checkAtomUnion():intersectAtom(vType)
end

function Reference:containAtom(vRightType)
	local nType = self:getTypeAwait()
	return nType:containAtom(vRightType)
end

function Reference:assumeContainAll(vAssumeSet, vRightType)::Ret(Boolean)
	local nResultType = self._resultType
	if nResultType then
		return nResultType:assumeContainAll(vAssumeSet, vRightType)
	end
	local nTypeList = self:getListAwait()
	local nAllContain:Boolean = true
	vRightType:foreachAwait(function(vAtomType)
		if not nAllContain then
			return
		end
		local nCurContain:Boolean = false
		for _, nType in ipairs(nTypeList) do
			if nType:assumeContainAtom(vAssumeSet, vAtomType) then
				nCurContain = true
				break
			end
		end
		if not nCurContain then
			nAllContain = false
		end
	end)
	return nAllContain
end

function Reference:assumeContainAtom(vAssumeSet, vAtomType:class.IAtomType)::Ret(OrFalse(class.IAtomType))
	local nTypeList = self:getListAwait()
	for _, nType in ipairs(nTypeList) do
		if nType:assumeContainAtom(vAssumeSet, vAtomType) then
			return nType
		end
	end
	return false
end

function Reference:isInterfaceKey()::Ret(Boolean)
	return self._isInterfaceKey
end

function Reference:trueType()
	return self:checkAtomUnion():trueType()
end

function Reference:falseType()
	return self:checkAtomUnion():falseType()
end

function Reference.is(v)::isguard(class.Reference)
	return getmetatable(v) == Reference
end

return Reference
