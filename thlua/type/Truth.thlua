
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local AtomTypeClass = require "thlua.type.AtomTypeClass"

local Truth = AtomTypeClass()

(@var.class = import("thlua.type.TypeClass").class)

function Truth.new(vManager:class.TypeManager)::RetNew(class.Truth, class.IAtomType)
	local self = setmetatable({::Self()
		_manager=vManager,
		id=vManager:genTypeId(),
		bits=TYPE_BITS.TRUTH,
	}, Truth)
	return self
end

function Truth:detailString(vToStringCache:Dict(String,String))
	return "Truth"
end

function Truth:native_setmetatable(vMetaTableType)
	return self
end

function Truth:native_getmetatable()
	return self
end

function Truth:native_type()
	-- TODO use TypeSet
	return self._manager.type.String
end

function Truth:native_rawget(vContext, vKeyType, vSilent)
	return self
end

function Truth:native_rawset(vContext, vKeyType, vValueTypeSet, vOverride)
end

function Truth:meta_get(vContext, vKeyType)
	return self
end

function Truth:meta_set(vContext, vKeyType, vValueTypeSet)
end

function Truth:meta_set_override(vContext, vKeyType, vValueTypeSet)
end

function Truth:meta_call(vContext, vTypeTuple)
	return self._manager:EmptyRetTuples()
end

function Truth:isSingleton()
	return false
end

function Truth:_intersectOneNotRefer(vType)
	local nManagerType = self._manager.type
	if vType == nManagerType.Nil then
		return false
	elseif vType == nManagerType.False then
		return false
	else
		return vType
	end
end

function Truth:_containOneNotRefer(vType)
	local nManagerType = self._manager.type
	if vType == nManagerType.Nil then
		return false
	elseif vType == nManagerType.False then
		return false
	else
		return self
	end
end

return Truth
