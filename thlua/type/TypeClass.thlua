
(@do

let.node = import("thlua.code.Node").node

let.clazz = namespace()

clazz.MetaIndexField = Struct {
	keyType=clazz.UAtomUnion,
	valueDict=Dict(clazz.IAtomType, clazz.UAtomUnion),
	fnType=OrFalse(clazz.TypeFunction, clazz.LuaFunction),
}

clazz.TLongHintInfo = Template(function(vHandler)
	return Struct {
		attrSet = Dict(String, Literal(1)),
		caller = Fn(vHandler),
	}
end)

clazz.RelationEnum = Union("<", ">", "=", "~", "&")


clazz.IAstNode = node.IAstNode

clazz.UIndexType = Union(clazz.LuaFunction, clazz.LuaTable, clazz.TypeFunction)

clazz.LspCompletion = Dict(String, True)

clazz.UAtomUnion = Union(clazz.IAtomType, clazz.IUnionType)
clazz.UAllType = Union(clazz.IAtomType, clazz.IUnionType, clazz.Reference)
clazz.USymbol = Union(clazz.ImmutVariable, clazz.LocalSymbol, clazz.AutoHolder)
clazz.UTermHolder = Union(clazz.AutoHolder, clazz.RefineTerm)

clazz.UObjectAtomUnion = Union(clazz.MetaObject, clazz.LuaTable, clazz.ObjectUnion, clazz.Never)
clazz.UFnAtomUnion = Union(clazz.PolyFunction, clazz.TypeFunction, clazz.LuaFunction, clazz.OpenFunction, clazz.FuncUnion, clazz.AnyFunction, clazz.Never)
clazz.TypeCasePair = Struct {clazz.UAtomUnion, clazz.VariableCase}
clazz.UMemberAllType = Union(clazz.UAllType, clazz.MemberFunction)
clazz.MemberDict = Dict(clazz.IAtomType, clazz.UMemberAllType)

clazz.IType = Interface ({
	_manager=clazz.TypeManager,
	id=Number,
	foreachAwait=Mfn(Fn(clazz.IAtomType)),

	unionSign=Mfn():Ret(String),

	detailString=Mfn(Dict(Truth, String), Boolean):Ret(String),

	intersectSome=Mfn(clazz.UAllType):Ret(Boolean),
	safeIntersect=Mfn(clazz.UAllType):Ret(OrFalse(clazz.UAtomUnion)),
	assumeIntersectSome=Mfn(OrNil(Dict(Integer, Boolean)), clazz.UAllType):Ret(Boolean),
	intersectAtom=Mfn(clazz.IAtomType):Ret(Union(Boolean, clazz.UAtomUnion)),

	containAll=Mfn(clazz.UAllType):Ret(Boolean),
	assumeIncludeAll=Mfn(OrNil(Dict(Integer, Boolean)), clazz.UAllType):Ret(Boolean),
	containAtom=Mfn(clazz.IAtomType):Ret(OrFalse(clazz.IAtomType)),

	mayRecursive=Mfn():Ret(Boolean),

	same=Mfn(clazz.UAllType):Ret(Boolean),
}, {
	__bor=Fn(clazz.UAllType, clazz.UAllType):Ret(clazz.UAtomUnion),
	__band=Fn(clazz.UAllType, clazz.UAllType):Ret(clazz.UAtomUnion),
})

clazz.IReadyType = Interface {
	foreach=Mfn(Fn(clazz.IAtomType)),
	isNever=Mfn():Ret(Boolean),
	notnilType=Mfn():Ret(clazz.UAtomUnion),
	isNilable=Mfn():Ret(Boolean),
	objectPartType=Mfn():Ret(clazz.UObjectAtomUnion),
	fnPartType=Mfn():Ret(clazz.UFnAtomUnion),
	falseType=Mfn():Ret(clazz.UAtomUnion),
	trueType=Mfn():Ret(clazz.UAtomUnion),
	assumeIncludeAtom=Mfn(OrNil(Dict(Integer, Boolean)), clazz.IAtomType):Ret(OrFalse(clazz.IAtomType)),
	assumeIntersectAtom=Mfn(OrNil(Dict(Integer, Boolean)), clazz.IAtomType):Ret(Union(Boolean, clazz.UAtomUnion)),
}

clazz.IMetaNative = Interface {
	native_rawget=Mfn(clazz.Context, clazz.IAtomType):Ret(clazz.UAtomUnion),
	native_rawset=Mfn(clazz.Context, clazz.IAtomType, clazz.UAtomUnion),
	native_next=Mfn(clazz.Context, clazz.UAtomUnion):Ret(clazz.UAtomUnion, Dict(clazz.IAtomType, clazz.UAtomUnion)),

	meta_get=Mfn(clazz.Context, clazz.IAtomType):Ret(clazz.UAtomUnion),
	meta_set=Mfn(clazz.Context, clazz.IAtomType, clazz.UAtomUnion),
}

clazz.IAtomType = Intersect(clazz.IType, clazz.IReadyType, clazz.IMetaNative, Interface {
	bits=Number,
	isReference=Mfn():Ret(False),
	linkNamedReference=Mfn(clazz.TypeReferCom),
	checkAtomUnion=Mfn():Ret(clazz.IAtomType),

	isSingleton=Mfn():Ret(Boolean),
	isUnion=Mfn():Ret(False),
	isStrNumLiteral=Mfn():Ret(Boolean),

	checkBaseObjectType=Mfn():Ret(OrFalse(clazz.MetaObject)),

	castPoly=Mfn(clazz.Context, List(clazz.UAllType)):Ret(OrFalse(clazz.TypeFunction)),

	meta_call=Mfn(clazz.Context, clazz.UTermTuple):Ret(clazz.RetTuples),
	meta_invoke=Mfn(clazz.Context, clazz.IAtomType, List(clazz.UAllType), clazz.UTermTuple):Ret(clazz.RetTuples),

	meta_pairs=Mfn(clazz.Context):Ret(OrFalse(clazz.UTypeTuple)),
	meta_ipairs=Mfn(clazz.Context):Ret(OrFalse(clazz.UTypeTuple)),
	meta_len=Mfn(clazz.Context):Ret(clazz.UAtomUnion),
	meta_uop_some=Mfn(clazz.Context, String):Ret(clazz.UAtomUnion),
	meta_bop_func=Mfn(clazz.Context, String):Ret(True, clazz.IAtomType):Ret(False, Union(clazz.IAtomType, Nil)),

	meta_get_invoke=Mfn(clazz.Context, clazz.IAtomType):Ret(clazz.UAtomUnion),

	native_getmetatable=Mfn(clazz.Context):Ret(clazz.UAtomUnion),
	native_setmetatable=Mfn(clazz.Context, clazz.LuaTable),

	native_tostring=Mfn():Ret(clazz.String),
	native_type=Mfn():Ret(clazz.UAtomUnion),
})

clazz.IUnionType = Intersect(clazz.IType, clazz.IReadyType, Interface {
	bits=Number,
	isReference=Mfn():Ret(False),
	checkAtomUnion=Mfn():Ret(clazz.IUnionType),

	initTypeId=Mfn(Integer),

	isUnion=Mfn():Ret(True),

	putAwait=Mfn(clazz.IAtomType),
})

clazz.URegionFunction = Union(clazz.AutoFunction, clazz.TypeFunction, clazz.OpenFunction)
clazz.GenFunc = Fn(clazz.URegionFunction, clazz.Context, clazz.UTermTuple, List(clazz.UAllType), OrFalse(clazz.UAllType)):Ret(clazz.FixedTermTuple)
clazz.OpenCaller = Fn(clazz.Context, clazz.FixedTermTuple):Ret(clazz.FixedTermTuple):Ret(clazz.RefineTerm)


end)

const OPER_ENUM = require "thlua.type.OPER_ENUM"
const function.open TypeClass()
	const t = {.open}
	t.__index=t
	function t.__tostring(self)
		return self:detailString({}, false)
	end
	function t:foreachAwait(vFunc)
		self:foreach(vFunc)
	end
	function t:isReference()
		return false
	end
	function t:checkAtomUnion()
		return self
	end
	function t:intersectAtom(vRight)
		return self:assumeIntersectAtom(nil, vRight)
	end
	function t:containAtom(vRight)
		return self:assumeIncludeAtom(nil, vRight)
	end
	function t:assumeIntersectSome(vAssumeSet, vRight)
		local nSomeIntersect:Boolean = false
		vRight:foreachAwait(function(vSubType)
			if not nSomeIntersect and self:assumeIntersectAtom(vAssumeSet, vSubType) then
				nSomeIntersect = true
			end
		end)
		return nSomeIntersect
	end
	function t:assumeIncludeAll(vAssumeSet, vRight)
		local nAllInclude:Boolean = true
		vRight:foreachAwait(function(vSubType)
			if nAllInclude and not self:assumeIncludeAtom(vAssumeSet, vSubType) then
				nAllInclude = false
			end
		end)
		return nAllInclude
	end
	function t:intersectSome(vRight)
		return self:assumeIntersectSome(nil, vRight)
	end
	function t:containAll(vRight)
		return self:assumeIncludeAll(nil, vRight)
	end
	function t:safeIntersect(vRight)
		const nLeft = self:isReference() and self:checkAtomUnion() or self
		const nRight = vRight:isReference() and vRight:checkAtomUnion() or vRight
		if not nRight:isUnion() then
			const nIntersect = nLeft:assumeIntersectAtom(nil, nRight)
			if nIntersect == true then
				return false
			else
				return nIntersect or self._manager.type.Never
			end
		else
			const nCollection = self._manager:TypeCollection()
			nRight:foreach(function(vSubType)
				local nIntersect = nLeft:assumeIntersectAtom(nil, vSubType)
				if nIntersect then
					if nIntersect == true then
						return
					else
						nCollection:put(nIntersect)
					end
				end
			end)
			return nCollection:mergeToAtomUnion()
		end
	end
	function t.__band(vLeft:clazz.UAllType, vRight:clazz.UAllType):Ret(clazz.UAtomUnion)
		const nTypeOrFalse = vLeft:safeIntersect(vRight)
		if nTypeOrFalse then
			return nTypeOrFalse
		else
			error("unexpected intersect")
		end
	end
	function t:isUnion()
		return false
	end
	function t:unionSign()
		return tostring(self.id)
	end
	function t.__bor(vLeft:clazz.UAllType, vRight:clazz.UAllType):Ret(clazz.UAtomUnion)
		return vLeft._manager:checkedUnion(vLeft, vRight)
	end
	function t:mayRecursive()
		return false
	end
	function t:same(vType):Ret(Boolean)
		if vType:isReference() then
			vType = vType:checkAtomUnion()
		end
		if self:isReference() then
			return self:checkAtomUnion() == vType
		else
			return self == vType
		end
	end
	function t:getCompletion():Ret(clazz.LspCompletion)
		return {}
	end
	return t
end

return TypeClass
