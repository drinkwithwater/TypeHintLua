
(@do

let.class = namespace()

class.AstNode = Interface {
	path=String,
}

class.UIndexType = Union(class.LuaFunction, class.LuaTable, class.TypeFunction)

class.LspCompletion = Dict(String, True)

class.GenFunc = Fn(class.Context, class.TermTuple):Ret(class.TermTuple)
class.GenNativeFunc = Fn(class.Context, class.TermTuple):Ret(class.TermTuple):Ret(class.RefineTerm)

class.UContext = Union(class.Runtime, class.Context)

class.UAtomUnion = Union(class.IAtomType, class.IUnionType)
class.UAllType = Union(class.IAtomType, class.IUnionType, class.Reference)
class.USymbol = Union(class.ImmutShot, class.LocalSymbol)

class.TypeCasePair = Struct {class.UAtomUnion, class.TermCase}
class.MemberDict = Dict(class.IAtomType, Union(class.UAllType, class.MemberFunction))

class.IType = Interface ({
	id=Number,
	bits=Number,
	foreach=Mfn(Fn(class.IAtomType)),
	foreachAwait=Mfn(Fn(class.IAtomType)),
	anyObject=Mfn(Fn(class.MetaObject):Ret(Boolean)),

	isSingleton=Mfn():Ret(Boolean),
	isNilable=Mfn():Ret(Boolean),
	isNever=Mfn():Ret(Boolean),

	unionSign=Mfn():Ret(String),

	detailString=Mfn(Dict(class.IAtomType, String), Boolean):Ret(String),
	intersectAtom=Mfn(class.IAtomType):Ret(OrFalse(class.UAtomUnion)),

	containAll=Mfn(class.UAllType):Ret(Boolean),
	assumeContainAll=Mfn(OrNil(Dict(Integer, True)), class.UAllType):Ret(Boolean),
	containAtom=Mfn(class.IAtomType):Ret(OrFalse(class.IAtomType)),

	notnilType=Mfn():Ret(class.UAtomUnion),
	trueType=Mfn():Ret(class.UAtomUnion),
	falseType=Mfn():Ret(class.UAtomUnion),

	same=Mfn(class.UAllType):Ret(Boolean),
}, {
	__bor=Fn(class.UAllType, class.UAllType):Ret(class.UAtomUnion),
	__band=Fn(class.UAllType, class.UAllType):Ret(class.UAtomUnion),
})

class.IAtomContainAssume = Interface {
	assumeContainAtom=Mfn(OrNil(Dict(Integer, True)), class.IAtomType):Ret(OrFalse(class.IAtomType)),
}

class.IMetaCall = Interface {
	meta_call=Mfn(class.Context, class.UTypeTuple):Ret(class.RetTuples),
}

class.IMetaNative = Interface {
	native_rawget=Mfn(class.Context, class.IAtomType):Ret(class.UAtomUnion),
	native_rawset=Mfn(class.Context, class.IAtomType, class.UAtomUnion, Union(Nil, Boolean)),
	native_next=Mfn(class.Context, class.UAtomUnion):Ret(class.UAtomUnion, Dict(class.IAtomType, class.UAtomUnion)),

	meta_pairs=Mfn(class.Context):Ret(class.UAtomUnion, class.UAtomUnion, class.UAtomUnion),
	meta_ipairs=Mfn(class.Context):Ret(class.UAtomUnion, class.UAtomUnion, class.UAtomUnion),
	meta_get=Mfn(class.Context, class.IAtomType):Ret(class.UAtomUnion),
	meta_set=Mfn(class.Context, class.IAtomType, class.UAtomUnion),
	meta_set_override=Mfn(class.Context, class.IAtomType, class.UAtomUnion),

	meta_len=Mfn(class.Context):Ret(class.IAtomType),
	meta_uop_some=Mfn(class.Context, String):Ret(class.UAtomUnion),
	meta_bop_func=Mfn(class.Context, String):Ret(True, class.IAtomType):Ret(False, Union(class.IAtomType, Nil)),
}

class.IAtomType = Intersect(class.IType, class.IAtomContainAssume, class.IMetaCall, class.IMetaNative, Interface {
	_manager=class.TypeManager,
	isReference=Mfn():Ret(False),
	addNamedReference=Mfn(class.Reference, String),
	checkAtomUnion=Mfn():Ret(class.IAtomType),
	getType=Mfn():Ret(class.IAtomType),

	isUnion=Mfn():Ret(False),
	isStrNumLiteral=Mfn():Ret(Boolean),

	native_type=Mfn():Ret(class.UAtomUnion),
	native_tostring=Mfn():Ret(class.UAtomUnion),
	native_getmetatable=Mfn():Ret(class.UAtomUnion),
	native_setmetatable=Mfn(class.Context, class.LuaTable),

	checkStruct=Mfn():Ret(OrFalse(class.MetaObject))
})

class.IUnionType = Intersect(class.IType, class.IAtomContainAssume, Interface {
	_manager=class.TypeManager,
	isReference=Mfn():Ret(False),
	checkAtomUnion=Mfn():Ret(class.IUnionType),
	getType=Mfn():Ret(class.IUnionType),

	isUnion=Mfn():Ret(True),

	putAwait=Mfn(class.IAtomType),
})


end)

const OPER_ENUM = require "thlua.type.OPER_ENUM"
const function TypeClass()::open()
	const t = {}
	t.__index=t
	function t.__tostring(self)
		const cache = {}
		return self:detailString(cache, false)
	end
	function t:anyObject?(vFunc)
		return false
	end
	function t:foreachAwait?(vFunc)
		self:foreach(vFunc)
	end
	function t.is?(v)::Ret(Boolean):nocheck()
		return getmetatable(v) == t
	end
	function t:isReference?()
		return false
	end
	function t:checkAtomUnion?()
		return self
	end
	function t:getType?()
		return self
	end
	function t:isSingleton?(v)
		error(tostring(self).."is singleton TODO")
		return false
	end
	function t:isNilable?()
		return false
	end
	function t:intersectAtom?(vRight)
		error(tostring(self).."intersectAtom TODO")
	end
	function t:containAtom?(vRight)
		return self:assumeContainAtom(nil, vRight)
	end
	function t:assumeContainAtom?(vAssumeSet, vRight)
		error(tostring(self).."containAtom TODO")
	end
	function t:assumeContainAll?(vAssumeSet, vRight)
		local nContain:Boolean = true
		vRight:foreachAwait(function(vSubType)
			if nContain and not self:assumeContainAtom(vAssumeSet, vSubType) then
				nContain = false
			end
		end)
		return nContain
	end
	function t:containAll(vRight)
		return self:assumeContainAll(nil, vRight)
	end
	function t:intersect(vRight:class.UAllType)
		local vLeft:class.UAllType = self
		if vLeft:isReference() then
			vLeft = vLeft:checkAtomUnion()
		end
		if vRight:isReference() then
			vRight = vRight:checkAtomUnion()
		end
		if not vRight:isUnion() then
			const sth = vLeft:intersectAtom(vRight)
			return sth or vLeft._manager.type.Never
		else
			const nCollection = vLeft._manager:TypeCollection()
			vRight:foreach(function(vSubType)
				local nIntersect = vLeft:intersectAtom(vSubType)
				if nIntersect then
					nCollection:put(nIntersect)
				end
			end)
			return nCollection:mergeToAtomUnion()
		end
	end
	function t.__band(vLeft, vRight)
		return vLeft:intersect(vRight)
	end
	function t:isUnion?()
		return false
	end
	function t:foreach?(vFunc)
		error("foreach TODO")
	end
	function t:unionSign?()
		return tostring(self.id)
	end
	function t.__bor(vLeft:class.UAllType, vRight:class.UAllType)::Ret(class.UAtomUnion)
		return vLeft._manager:checkedUnion(vLeft, vRight):getTypeAwait()
	end
	function t:isNever?()
			return false
	end
	function t:notnilType?()
		return self:checkAtomUnion()
	end
	function t:trueType?()
			return self:checkAtomUnion()
	end
	function t:falseType?()
			return self._manager.type.Never
	end
	function t:same(vType)::Ret(Boolean)
		if vType:isReference() then
			vType = vType:checkAtomUnion()
		end
		if self:isReference() then
			return self:checkAtomUnion() == vType
		else
			return self == vType
		end
	end
	function t:addNamedReference?(vRefer, vName)
	end
	function t:getCompletion?()::Ret(class.LspCompletion)
		return {}
	end
	return t
end

return TypeClass
