
(@do

let.class = namespace()

class.AstNode = Interface {
	path=String,
}

class.GenFunc = Fn(class.Context, class.TermTuple):Ret(class.TermTuple)

class.TypeCollection = Struct {
	put=Mfn(class.UKeyType):Ret(),
	mergeToType=Mfn():Ret(class.UKeyType)
}

class.UContext = Union(class.Runtime, class.Context)

class.UKeyType = Union(class.IAtomType, class.IUnionType)
class.UValueType = Union(class.IAtomType, class.IUnionType, class.Reference)

class.IAtomType = Interface ({
	id=Number,
	_manager=class.TypeManager,
	bits=Number,
}, {get={
	isReference=Mfn():Ret(False),
	foreach=Mfn(Fn(class.IAtomType):Ret()):Ret(),
	every=Mfn(Fn(class.IAtomType):Ret(Boolean)):Ret(Boolean),
	checkType=Mfn():Ret(class.IAtomType),
	getType=Mfn():Ret(class.IAtomType),

	isUnion=Mfn():Ret(False),
	isSingleton=Mfn():Ret(Boolean),
	isNilable=Mfn():Ret(Boolean),

	detailString=Mfn(Dict(class.IAtomType, Union(True,String)), Boolean):Ret(String),
	contain=Mfn(class.UValueType):Ret(Union(class.UKeyType, False)),

	_mapContinue=Mfn(Boolean, Fn(class.IAtomType):Ret():Ret(Boolean)):Ret(Boolean),
	_intersectOneNotRefer=Mfn(class.IAtomType):Ret(Union(class.UKeyType, False)),
	_containOneNotRefer=Mfn(class.IAtomType):Ret(Union(class.IAtomType, False)),

	native_type=Mfn():Ret(class.UKeyType),
	native_tostring=Mfn():Ret(class.UKeyType),
	native_getmetatable=Mfn():Ret(class.UKeyType),
	native_setmetatable=Mfn(class.Context, class.UKeyType):Ret(class.UKeyType),

	native_rawget=Mfn(class.Context, class.IAtomType):Ret(class.UKeyType),
	native_rawset=Mfn(class.Context, class.IAtomType, class.UKeyType, Union(Nil, Boolean)):Ret(),

	meta_get=Mfn(class.Context, class.IAtomType):Ret(class.UKeyType),
	meta_set=Mfn(class.Context, class.IAtomType, class.UKeyType):Ret(),
	meta_set_override=Mfn(class.Context, class.IAtomType, class.UKeyType):Ret(),

	meta_len=Mfn(class.Context):Ret(class.IAtomType),
	meta_uop_some=Mfn(class.Context, String):Ret(class.UKeyType),
	meta_bop_func=Mfn(class.Context, String):Ret(Boolean, Union(class.IAtomType, Nil)),

	meta_call=Mfn(class.Context, class.TypeTuple):Ret(class.RetTuples),

	notnilType=Mfn():Ret(class.UKeyType),
	trueType=Mfn():Ret(class.UKeyType),
	falseType=Mfn():Ret(class.UKeyType),

	same=Mfn(class.UValueType):Ret(Boolean),
}})

class.IUnionType = Interface ({
	id=Number,
	_manager=class.TypeManager,
	bits=Number,
}, {get={
	detailString=Mfn(Dict(class.IAtomType, Union(True,String)), Boolean):Ret(String),
	isReference=Mfn():Ret(False),
	foreach=Mfn(Fn(class.IAtomType):Ret()):Ret(),
	every=Mfn(Fn(class.IAtomType):Ret(Boolean)):Ret(Boolean),
	checkType=Mfn():Ret(class.IUnionType),
	getType=Mfn():Ret(class.IUnionType),

	_mapContinue=Mfn(Boolean, Fn(class.IAtomType):Ret():Ret(Boolean)):Ret(Boolean),
	isUnion=Mfn():Ret(True),
	isNilable=Mfn():Ret(Boolean),
	contain=Mfn(class.UValueType):Ret(Union(class.UKeyType, False)),

	notnilType=Mfn():Ret(class.UKeyType),
	trueType=Mfn():Ret(class.UKeyType),
	falseType=Mfn():Ret(class.UKeyType),

	_intersectOneNotRefer=Mfn(class.IAtomType):Ret(Union(class.UKeyType, False)),
	_containOneNotRefer=Mfn(class.IAtomType):Ret(Union(class.IAtomType, False)),

	same=Mfn(class.UValueType):Ret(Boolean),
	_put=Mfn(class.IAtomType):Ret()
}})


end)

local OPER_ENUM = require "thlua.type.OPER_ENUM"
local function TypeClass()::open()
	local t = {}
	t.__index=t
	function t.__tostring(self)
		local cache = {}
		return self:detailString(cache, false)
	end
	function t:preBuild?()
	end
	function t:postBuild?()
	end
	function t.is?(v)::Ret(Boolean):nocheck()
		return getmetatable(v) == t
	end
	function t:isReference?()
		return false
	end
	function t:checkType?()
		return self
	end
	function t:getType?()
		return self
	end
	function t:isSingleton?(v)
		error(tostring(self).."is singleton TODO")
	end
	function t:isNilable?()
		return false
	end
	function t:_intersectOneNotRefer?(vRight)
		error(tostring(self).."_intersectOneNotRefer TODO")
	end
	function t:_containOneNotRefer?(vRight)
		error(tostring(self).."_containOneNotRefer TODO")
	end
	function t:contain(vRight)
		local nLeft:class.UKeyType = self
		if nLeft:isReference() then
			nLeft = nLeft:checkType()
		end
		if vRight:isReference() then
			vRight = vRight:checkType()
		end
		if not vRight:isUnion() then
			return nLeft:_containOneNotRefer(vRight)
		else
			local nCollection = nLeft._manager:TypeCollection()
			local nContain = vRight:every(function(vSubType)
				local nContainType = nLeft:_containOneNotRefer(vSubType)
				if not nContainType then
					return false
				else
					nCollection:put(nContainType)
					return true
				end
			end)
			if nContain then
				return nCollection:mergeToType()
			else
				return false
			end
		end
	end
	function t:intersect(vRight)
		local vLeft = self
		if vLeft:isReference() then
			vLeft = vLeft:checkType()
		end
		if vRight:isReference() then
			vRight = vRight:checkType()
		end
		if not vRight:isUnion() then
			local sth = vLeft:_intersectOneNotRefer(vRight)
			return sth or vLeft._manager.type.Never
		else
			local nTypeDict = {}
			local nCollection = vLeft._manager:TypeCollection()
			vRight:foreach(function(vSubType)
				local nIntersect = vLeft:_intersectOneNotRefer(vSubType)
				if nIntersect then
					nCollection:put(nIntersect)
				end
			end)
			return nCollection:mergeToType()
		end
	end
	function t.__band(vLeft, vRight)
		return vLeft:intersect(vRight)
	end
	function t:isUnion?()
		return false
	end
	function t:_mapContinue?(vContinue, vFunc)::Ret(Boolean):nocheck()
		return vFunc(self) or vContinue
	end
	function t:foreach(vFunc)
		self:_mapContinue(true, vFunc)
	end
	function t:every(vFunc)
		return self:_mapContinue(false, vFunc)
	end
	function t:unionSign?()
		local nUnionSign = self._unionSign
		if not nUnionSign then
			nUnionSign = tostring(self.id)
			self._unionSign = nUnionSign
		end
		return nUnionSign
	end
	function t.__bor(vLeft, vRight)
		return vLeft._manager:Union(vLeft, vRight)
	end
    function t:isNever?()
        return false
    end
	function t:notnilType?()
		return self:checkType()
	end
    function t:trueType?()
        return self:checkType()
    end
    function t:falseType?()
        return self._manager.type.Never
    end
	function t:same(vType)::Ret(Boolean)
		if vType:isReference() then
			vType = vType:checkType()
		end
		if self:isReference() then
			return self:checkType() == vType
		else
			return self == vType
		end
	end
	function t:setReferName(vReferName)
		self._referName = vReferName
	end
	function t:isNative?()
		return false
	end
	function t:getCompletion?()
		return {}
	end
	return t
end

return TypeClass
