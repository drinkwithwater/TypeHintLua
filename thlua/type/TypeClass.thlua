
(@do

let.node = import("thlua.code.Node").node

let.class = namespace()

class.MetaIndexField = Struct {
	keyType=class.UAtomUnion,
	valueDict=Dict(class.IAtomType, class.UAtomUnion),
	fnType=OrFalse(class.TypeFunction, class.LuaFunction),
}

class.TLongHintInfo = function(vHandler)
	return Struct {
		attrSet = Dict(String, Literal(1)),
		caller = Fn(vHandler),
	}
end

class.RelationEnum = Union("<", ">", "=", "~", "&")

class.IAstNode = node.IAstNode

class.UIndexType = Union(class.LuaFunction, class.LuaTable, class.TypeFunction)

class.LspCompletion = Dict(String, True)

class.UAtomUnion = Union(class.IAtomType, class.IUnionType)
class.UAllType = Union(class.IAtomType, class.IUnionType, class.Reference)
class.USymbol = Union(class.ImmutShot, class.LocalSymbol)

class.UObjectAtomUnion = Union(class.MetaObject, class.LuaTable, class.ObjectUnion, class.Never)
class.UFnAtomUnion = Union(class.PolyFunction, class.TypeFunction, class.LuaFunction, class.OpenFunction, class.FuncUnion, class.AnyFunction, class.Never)
class.TypeCasePair = Struct {class.UAtomUnion, class.TermCase}
class.UMemberAllType = Union(class.UAllType, class.MemberFunction)
class.MemberDict = Dict(class.IAtomType, class.UMemberAllType)

class.IType = Interface ({
	_manager=class.TypeManager,
	id=Number,
	foreach=member:Fn(Fn(class.IAtomType)),
	foreachAwait=member:Fn(Fn(class.IAtomType)),

	isNilable=member:Fn():Ret(Boolean),
	isNever=member:Fn():Ret(Boolean),

	unionSign=member:Fn():Ret(String),

	detailString=member:Fn(Dict(Truth, String), Boolean):Ret(String),

	intersectSome=member:Fn(class.UAllType):Ret(Boolean),
	safeIntersect=member:Fn(class.UAllType):Ret(OrFalse(class.UAtomUnion)),
	assumeIntersectSome=member:Fn(OrNil(Dict(Integer, Boolean)), class.UAllType):Ret(Boolean),
	intersectAtom=member:Fn(class.IAtomType):Ret(Union(Boolean, class.UAtomUnion)),

	containAll=member:Fn(class.UAllType):Ret(Boolean),
	assumeContainAll=member:Fn(OrNil(Dict(Integer, Boolean)), class.UAllType):Ret(Boolean),
	containAtom=member:Fn(class.IAtomType):Ret(OrFalse(class.IAtomType)),

	mayRecursive=member:Fn():Ret(Boolean),

	notnilType=member:Fn():Ret(class.UAtomUnion),
	trueType=member:Fn():Ret(class.UAtomUnion),
	falseType=member:Fn():Ret(class.UAtomUnion),
	objectPartType=member:Fn():Ret(class.UObjectAtomUnion),
	fnPartType=member:Fn():Ret(class.UFnAtomUnion),

	same=member:Fn(class.UAllType):Ret(Boolean),
}, {
	__bor=Fn(class.UAllType, class.UAllType):Ret(class.UAtomUnion),
	__band=Fn(class.UAllType, class.UAllType):Ret(class.UAtomUnion),
})

class.IAssumeRelationBase = Interface {
	assumeContainAtom=member:Fn(OrNil(Dict(Integer, Boolean)), class.IAtomType):Ret(OrFalse(class.IAtomType)),
	assumeIntersectAtom=member:Fn(OrNil(Dict(Integer, Boolean)), class.IAtomType):Ret(Union(Boolean, class.UAtomUnion)),
}

class.IMetaNative = Interface {
	native_rawget=member:Fn(class.Context, class.IAtomType):Ret(class.UAtomUnion),
	native_rawset=member:Fn(class.Context, class.IAtomType, class.UAtomUnion, Union(Nil, Boolean)),
	native_next=member:Fn(class.Context, class.UAtomUnion):Ret(class.UAtomUnion, Dict(class.IAtomType, class.UAtomUnion)),

	meta_get=member:Fn(class.Context, class.IAtomType):Ret(class.UAtomUnion),
	meta_set=member:Fn(class.Context, class.IAtomType, class.UAtomUnion),
}

class.IAtomType = Intersect(class.IType, class.IAssumeRelationBase, class.IMetaNative, Interface {
	bits=Number,
	isReference=member:Fn():Ret(False),
	linkNamedReference=member:Fn(class.TypeReferCom),
	checkAtomUnion=member:Fn():Ret(class.IAtomType),

	isSingleton=member:Fn():Ret(Boolean),
	isUnion=member:Fn():Ret(False),
	isStrNumLiteral=member:Fn():Ret(Boolean),

	checkBaseObjectType=member:Fn():Ret(OrFalse(class.MetaObject)),

	castPoly=member:Fn(class.Context, List(class.UAllType)):Ret(OrFalse(class.TypeFunction)),

	meta_call=member:Fn(class.Context, class.UTypeTuple):Ret(class.RetTuples),
	meta_invoke=member:Fn(class.Context, class.IAtomType, List(class.UAllType), class.UTypeTuple):Ret(class.RetTuples),

	meta_pairs=member:Fn(class.Context):Ret(OrFalse(class.TypeTuple)),
	meta_ipairs=member:Fn(class.Context):Ret(OrFalse(class.TypeTuple)),
	meta_len=member:Fn(class.Context):Ret(class.UAtomUnion),
	meta_uop_some=member:Fn(class.Context, String):Ret(class.UAtomUnion),
	meta_bop_func=member:Fn(class.Context, String):Ret(True, class.IAtomType):Ret(False, Union(class.IAtomType, Nil)),

	meta_set_override=member:Fn(class.Context, class.IAtomType, class.UAtomUnion),
	meta_get_invoke=member:Fn(class.Context, class.IAtomType):Ret(class.UAtomUnion),

	native_getmetatable=member:Fn(class.Context):Ret(class.UAtomUnion),
	native_setmetatable=member:Fn(class.Context, class.LuaTable),

	native_tostring=member:Fn():Ret(class.String),
	native_type=member:Fn():Ret(class.UAtomUnion),
})

class.IUnionType = Intersect(class.IType, class.IAssumeRelationBase, Interface {
	bits=Number,
	isReference=member:Fn():Ret(False),
	checkAtomUnion=member:Fn():Ret(class.IUnionType),

	initTypeId=member:Fn(Integer),

	isUnion=member:Fn():Ret(True),

	putAwait=member:Fn(class.IAtomType),
})

class.URegionFunction = Union(class.TypeFunction, class.OpenFunction)
class.GenFunc = Fn(class.URegionFunction, class.Context, class.TermTuple, List(class.UAllType), OrFalse(class.UAllType)):Ret(class.TermTuple)
class.OpenCaller = Fn(class.Context, class.TermTuple):Ret(class.TermTuple):Ret(class.RefineTerm)
class.GenericFunction = Fn():Dots(class.UAllType):Ret(class.UAllType) -- TODO not good, replace with AnyFunction in the future


end)

const OPER_ENUM = require "thlua.type.OPER_ENUM"
const function.open TypeClass()
	const t = {}
	t.__index=t
	function t.__tostring(self)
		return self:detailString({}, false)
	end
	function t:foreachAwait?(vFunc)
		self:foreach(vFunc)
	end
	function t:isReference?()
		return false
	end
	function t:checkAtomUnion?()
		return self
	end
	function t:isNilable?()
		return false
	end
	function t:intersectAtom?(vRight)
		return self:assumeIntersectAtom(nil, vRight)
	end
	function t:containAtom?(vRight)
		return self:assumeContainAtom(nil, vRight)
	end
	function t:assumeIntersectSome?(vAssumeSet, vRight)
		local nSomeIntersect:Boolean = false
		vRight:foreachAwait(function(vSubType)
			if not nSomeIntersect and self:assumeIntersectAtom(vAssumeSet, vSubType) then
				nSomeIntersect = true
			end
		end)
		return nSomeIntersect
	end
	function t:assumeContainAll?(vAssumeSet, vRight)
		local nAllContain:Boolean = true
		vRight:foreachAwait(function(vSubType)
			if nAllContain and not self:assumeContainAtom(vAssumeSet, vSubType) then
				nAllContain = false
			end
		end)
		return nAllContain
	end
	function t:intersectSome(vRight)
		return self:assumeIntersectSome(nil, vRight)
	end
	function t:containAll(vRight)
		return self:assumeContainAll(nil, vRight)
	end
	function t:safeIntersect(vRight)
		const nLeft = self:isReference() and self:checkAtomUnion() or self
		const nRight = vRight:isReference() and vRight:checkAtomUnion() or vRight
		if not nRight:isUnion() then
			const nIntersect = nLeft:assumeIntersectAtom(nil, nRight)
			if nIntersect == true then
				return false
			else
				return nIntersect or self._manager.type.Never
			end
		else
			const nCollection = self._manager:TypeCollection()
			nRight:foreach(function(vSubType)
				local nIntersect = nLeft:assumeIntersectAtom(nil, vSubType)
				if nIntersect then
					if nIntersect == true then
						return false
					else
						nCollection:put(nIntersect)
					end
				end
			end)
			return nCollection:mergeToAtomUnion()
		end
	end
	function t.__band(vLeft:class.UAllType, vRight:class.UAllType):Ret(class.UAtomUnion)
		const nTypeOrFalse = vLeft:safeIntersect(vRight)
		if nTypeOrFalse then
			return nTypeOrFalse
		else
			error("unexpected intersect")
		end
	end
	function t:isUnion?()
		return false
	end
	function t:foreach?(vFunc)
		error("foreach TODO")
	end
	function t:unionSign?()
		return tostring(self.id)
	end
	function t.__bor(vLeft:class.UAllType, vRight:class.UAllType):Ret(class.UAtomUnion)
		return vLeft._manager:checkedUnion(vLeft, vRight)
	end
	function t:isNever?()
			return false
	end
	function t:notnilType?()
		return self:checkAtomUnion()
	end
	function t:trueType?()
			return self:checkAtomUnion()
	end
	function t:mayRecursive?()
		return false
	end
	function t:objectPartType?()
			return self._manager.type.Never
	end
	function t:fnPartType?()
			return self._manager.type.Never
	end
	function t:falseType?()
			return self._manager.type.Never
	end
	function t:same(vType):Ret(Boolean)
		if vType:isReference() then
			vType = vType:checkAtomUnion()
		end
		if self:isReference() then
			return self:checkAtomUnion() == vType
		else
			return self == vType
		end
	end
	function t:getCompletion?():Ret(class.LspCompletion)
		return {}
	end
	return t
end

return TypeClass
