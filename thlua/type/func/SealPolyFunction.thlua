
const class = require "thlua.class"
const PolyFunction = require "thlua.type.func.PolyFunction"
const SealFunction = require "thlua.type.func.SealFunction"

(@let.clazz = import("thlua.type.TypeClass").clazz)

const SealPolyFunction = class@<clazz.SealPolyFunction, false>(PolyFunction)

function.open SealPolyFunction:ctor(_,_,_,_, vLexStack:clazz.BaseStack, vDeduceFn:OrNil(Fn(clazz.SealPolyFunction, clazz.UTermTuple):Ret(clazz.TupleBuilder)))
	self._fnDict = {} @ Dict(String, clazz.SealFunction)
	self._lexStack = vLexStack
	self._useNodeSet = {}
	self._deducePolyArgs = vDeduceFn
end

function SealPolyFunction:makeFn(vTupleBuilder:clazz.TupleBuilder):Ret(clazz.SealFunction)
	const nSign = vTupleBuilder:checkTemplateArgSign()
	const nFn = self._fnDict[nSign]
	if not nFn then
		const nResult = self._makerFn(vTupleBuilder)
		if SealFunction.is(nResult) then
			self._fnDict[nSign] = nResult
            self._lexStack:getSealStack():scheduleSealType(nResult)
			return nResult
		else
			error("poly function must return mono-function type but got:"..tostring(nResult))
		end
	else
		return nFn
	end
end

function SealPolyFunction:meta_call(vContext, vTermTuple)
	const nTupleBuilder = self._deducePolyArgs!(self, vTermTuple)
	self:makeFn(nTupleBuilder):meta_call(vContext, vTermTuple)
end

function.pass SealPolyFunction:newStack(vNode:clazz.IBaseNode, vApplyStack:clazz.BaseStack):Ret(clazz.OpenStack)
	return self._manager:getRuntime():DeduceStack(vNode, false, self, vApplyStack)
end

return SealPolyFunction