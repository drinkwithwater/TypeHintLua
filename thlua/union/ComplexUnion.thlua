
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local UnionClass = require "thlua.union.UnionClass"
local Truth = require "thlua.type.Truth"

local ComplexUnion = UnionClass()

(@let.class = import("thlua.type.TypeClass").class)

function ComplexUnion.new(vManager:class.TypeManager, vBits:Number, vBitToType:Dict(Number, class.IKeyType))::RetClass(class.ComplexUnion, class.IUnionType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_bitToType=vBitToType,
		bits=vBits,
		id=0,
	}, ComplexUnion)
	return self
end

function ComplexUnion:_mapContinue(vContinue, vFunc)::Ret(Boolean):nocheck()
	for nBits, nType in pairs(self._bitToType) do
		if not (nType:_mapContinue(vContinue, vFunc) or vContinue) then
			return false
		end
	end
	return true
end

function ComplexUnion:_containOneNotRefer(vType)
	local nSimpleType = self._bitToType[vType.bits]
	if nSimpleType then
		return nSimpleType:_containOneNotRefer(vType)
	else
		return false
	end
end

function ComplexUnion:_intersectOneNotRefer(vType)
	local nSimpleType = self._bitToType[vType.bits]
	if nSimpleType then
		return nSimpleType:_intersectOneNotRefer(vType)
	elseif Truth.is(vType) then
		return self
	else
		return false
	end
end

function ComplexUnion:isNilable()
	if self._bitToType[TYPE_BITS.NIL] then
		return true
	else
		return false
	end
end

return ComplexUnion
