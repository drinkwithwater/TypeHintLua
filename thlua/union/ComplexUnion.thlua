
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const UnionClass = require "thlua.union.UnionClass"
const Truth = require "thlua.type.Truth"

const ComplexUnion = UnionClass()

(@let.class = import("thlua.type.TypeClass").class)

function ComplexUnion.new(vManager:class.TypeManager, vBits:Number, vBitToType:Dict(Number, class.UAtomUnion))::RetClass(class.ComplexUnion, class.IUnionType)
	const self = setmetatable({::Self()
		_manager=vManager,
		_bitToType=vBitToType,
		bits=vBits,
		id=0@Integer,
	}, ComplexUnion)
	return self
end

function ComplexUnion:anyObject(vFunc)
	const nObjectPart = self._bitToType[TYPE_BITS.OBJECT]
	if nObjectPart then
		return nObjectPart:anyObject(vFunc)
	end
	return false
end

function ComplexUnion:foreach(vFunc)
	for nBits, nType in pairs(self._bitToType) do
		nType:foreach(vFunc)
	end
end

function ComplexUnion:assumeContainAtom(vAssumeSet, vType)
	const nSimpleType = self._bitToType[vType.bits]
	if nSimpleType then
		return nSimpleType:assumeContainAtom(vAssumeSet, vType)
	else
		return false
	end
end

function ComplexUnion:intersectAtom(vType)
	const nSimpleType = self._bitToType[vType.bits]
	if nSimpleType then
		return nSimpleType:intersectAtom(vType)
	elseif Truth.is(vType) then
		return self
	else
		return false
	end
end

function ComplexUnion:isNilable()
	if self._bitToType[TYPE_BITS.NIL] then
		return true
	else
		return false
	end
end

return ComplexUnion
