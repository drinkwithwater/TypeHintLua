
local Reference = require "thlua.type.Reference"
local UnionClass = require "thlua.union.UnionClass"

local FullUnion = UnionClass()

(@let.class = import("thlua.type.TypeClass").class)

function FullUnion.new(vManager:class.TypeManager, vReferList:List(class.Reference), vBitToCom:Dict(Number, Union(class.ISetCom, class.IAtomType)))::RetClass(class.FullUnion)
	local self = setmetatable({::Self()
		_manager=vManager,
		_referList=vReferList,
		_typeList={},
		_bitToCom=vBitToCom,
		bits=0,
		id=vManager:genTypeId(),
	}, FullUnion)
	return self
end

function FullUnion:preBuild()
	local nReferList = self._referList
	if not nReferList then
		return
	else
		self._referList = false
	end
	local nTypeList = self._typeList
	local nBit = 0
	for i,v in ipairs(nReferList) do
		local nType = v:getTypeAwait()
		if FullUnion.is(nType) then
			nType:foreach(function(vType)
				nTypeList[#nTypeList + 1] = vType
				nBit = nBit | vType.bits
			end)
		else
			nTypeList[#nTypeList + 1] = nType
			nBit = nBit | nType.bits
		end
	end
	self.bits = nBit
end

function FullUnion:postBuild()
	if not self._bitToCom then
		local nCollection = self._manager:TypeCollection()
		for k,v in pairs(self._typeList) do
			nCollection:put(v)
		end
		self._bitToCom = nCollection:makeBitToCom()
	end
end

function FullUnion:_mapContinue(vContinue, vFunc)::Ret(Boolean):nocheck()
	local nBitToCom = self._bitToCom
	if nBitToCom then
		for _, nCom in pairs(self._bitToCom) do
			if not (nCom:_mapContinue(vContinue, vFunc) or vContinue) then
				return false
			end
		end
		return true
	else
		for _, nType in pairs(self._typeList) do
			if not (vFunc(nType) or vContinue) then
				return false
			end
		end
		return true
	end
end

function FullUnion:_containOneNotRefer(vType)
	local nSimpleType = self._bitToCom[vType.bits]
	if nSimpleType then
		return nSimpleType:_containOneNotRefer(vType)
	else
		return false
	end
end

function FullUnion:_intersectOneNotRefer(vType)
	local nSimpleType = self._bitToCom[vType.bits]
	if nSimpleType then
		return nSimpleType:_intersectOneNotRefer(vType)
	elseif Truth.is(vType) then
		return self
	else
		return false
	end
end

function FullUnion:isNilable()
	if self._bitToCom[TYPE_BITS.NIL] then
		return true
	else
		return false
	end
end

function FullUnion.is(vType)::isguard(class.FullUnion)
	return getmetatable(vType) == FullUnion
end

return FullUnion
