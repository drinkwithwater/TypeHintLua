
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local Truth = require "thlua.type.Truth"
local NativeFunction = require "thlua.func.NativeFunction"
local LuaFunction = require "thlua.func.LuaFunction"
local TypeFunction = require "thlua.func.TypeFunction"

local SetComClass = require "thlua.union.SetComClass"
local FuncSetCom = SetComClass()

(@let.class = import("thlua.type.TypeClass").class)

function FuncSetCom.new(vManager:class.TypeManager)::RetClass(class.FuncSetCom, class.ISetCom)
	local self = setmetatable({::Self()
		_manager=vManager,
		_nativeFnDict={} @Dict(class.NativeFunction, True),
		_typeFnDict={} @Dict(class.TypeFunction, True),
		_luaFnDict={} @Dict(class.LuaFunction, True),
	}, FuncSetCom)
	return self
end

function FuncSetCom:foreach(vFunc)
	for nType, _ in pairs(self._nativeFnDict) do
		vFunc(nType)
	end
	for nType, _ in pairs(self._typeFnDict) do
		vFunc(nType)
	end
	for nType, _ in pairs(self._luaFnDict) do
		vFunc(nType)
	end
end

function FuncSetCom:_put(vType)
	if self:_containOneNotRefer(vType) then
		return
	end
	if NativeFunction.is(vType) then
		self._nativeFnDict[vType] = true
	elseif LuaFunction.is(vType) then
		for nTypeFn, _ in pairs(self._typeFnDict) do
			if nTypeFn:contain(vType) then
				return
			end
		end
		self._luaFnDict[vType] = true
	elseif TypeFunction.is(vType) then
		-- delete small struct
		local nDeleteList:List(class.TypeFunction) = {}
		for nTypeFn, _ in pairs(self._typeFnDict) do
			if vType:contain(nTypeFn) then
				nDeleteList[#nDeleteList + 1] = nTypeFn
			end
		end
		for _, nTypeFn in pairs(nDeleteList) do
			self._typeFnDict[nTypeFn] = nil
		end
		self._typeFnDict[vType] = true
	else
		error("fn-type unexpected")
	end
end

function FuncSetCom:_intersectOneNotRefer(vType)
	if Truth.is(vType) then
		return self
	else
		return self:_containOneNotRefer(vType)
	end
end

function FuncSetCom:_containOneNotRefer(vType)
	if NativeFunction.is(vType) then
		if self._nativeFnDict[vType] then
			return vType
		else
			return false
		end
	elseif LuaFunction.is(vType) then
		if self._luaFnDict[vType] then
			return vType
		else
			return false
		end
	end
	for nTypeFn, _ in pairs(self._typeFnDict) do
		if nTypeFn:contain(vType) then
			return nTypeFn
		end
	end
	return false
end

return FuncSetCom
