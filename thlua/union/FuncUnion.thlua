
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local UnionClass = require "thlua.union.UnionClass"
local Truth = require "thlua.type.Truth"
local NativeFunction = require "thlua.func.NativeFunction"
local LuaFunction = require "thlua.func.LuaFunction"
local TypeFunction = require "thlua.func.TypeFunction"

local FuncUnion = UnionClass()

(@let.class = import("thlua.type.TypeClass").class)

function FuncUnion.new(vManager:class.TypeManager)::RetClass(class.FuncUnion, class.IUnionType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_nativeFnDict={} @Dict(class.NativeFunction, True),
		_typeFnDict={} @Dict(class.TypeFunction, True),
		_luaFnDict={} @Dict(class.LuaFunction, True),
		bits=TYPE_BITS.FUNCTION,
		id=0,
	}, FuncUnion)
	return self
end

function FuncUnion:foreach(vFunc)
	for nType, _ in pairs(self._nativeFnDict) do
		vFunc(nType)
	end
	for nType, _ in pairs(self._typeFnDict) do
		vFunc(nType)
	end
	for nType, _ in pairs(self._luaFnDict) do
		vFunc(nType)
	end
end

function FuncUnion:putAwait(vType)
	if self:containAtom(vType) then
		return
	end
	if NativeFunction.is(vType) then
		self._nativeFnDict[vType] = true
	elseif LuaFunction.is(vType) then
		for nTypeFn, _ in pairs(self._typeFnDict) do
			if nTypeFn:containAll(vType) then
				return
			end
		end
		self._luaFnDict[vType] = true
	elseif TypeFunction.is(vType) then
		-- delete small struct
		local nDeleteList:List(class.TypeFunction) = {}
		for nTypeFn, _ in pairs(self._typeFnDict) do
			if vType:containAll(nTypeFn) then
				nDeleteList[#nDeleteList + 1] = nTypeFn
			end
		end
		for _, nTypeFn in pairs(nDeleteList) do
			self._typeFnDict[nTypeFn] = nil
		end
		self._typeFnDict[vType] = true
	else
		error("fn-type unexpected")
	end
end

function FuncUnion:_intersectOneNotRefer(vType)
	if Truth.is(vType) then
		return self
	else
		return self:containAtom(vType)
	end
end

function FuncUnion:atomContainAssume(vAssumeSet, vType)
	if NativeFunction.is(vType) then
		if self._nativeFnDict[vType] then
			return vType
		else
			return false
		end
	elseif LuaFunction.is(vType) then
		if self._luaFnDict[vType] then
			return vType
		else
			return false
		end
	end
	for nTypeFn, _ in pairs(self._typeFnDict) do
		if nTypeFn:atomContainAssume(vAssumeSet, vType) then
			return nTypeFn
		end
	end
	return false
end

return FuncUnion
