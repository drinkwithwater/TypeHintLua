
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const UnionClass = require "thlua.union.UnionClass"
const Truth = require "thlua.type.Truth"

const AnyFunction = require "thlua.func.AnyFunction"
const OpenFunction = require "thlua.func.OpenFunction"
const TypedFunction = require "thlua.func.TypedFunction"
const BaseFunction = require "thlua.func.BaseFunction"

const FuncUnion = UnionClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.FuncUnion) FuncUnion.new(vManager:clazz.TypeManager):impl(clazz.IUnionType)
	const self = setmetatable({.class
		_manager=vManager,
		_notTypeFnDict={} @Dict(clazz.BaseFunction, True),
		_typeFnDict={} @Dict(clazz.TypedFunction, True),
		_openFnDict={} @Dict(clazz.OpenFunction, True),
		_anyFn=false@OrFalse(clazz.AnyFunction),
		bits=TYPE_BITS.FUNCTION,
		id=0@Integer,
	}, FuncUnion)
	return self
end

function FuncUnion:foreach(vFunc)
	for nType, _ in pairs(self._openFnDict) do
		vFunc(nType)
	end
	const nAnyFn = self._anyFn
	if not nAnyFn then
		for nType, _ in pairs(self._typeFnDict) do
			vFunc(nType)
		end
		for nType, _ in pairs(self._notTypeFnDict) do
			vFunc(nType)
		end
	else
		vFunc(nAnyFn)
	end
end

function FuncUnion:putAwait(vType)
	if self:includeAtom(vType) then
		return
	end
	if OpenFunction.is(vType) then
		self._openFnDict[vType] = true
	elseif AnyFunction.is(vType) then
		self._anyFn = vType
		do.pass
			self._notTypeFnDict = {}
			self._typeFnDict = {}
		end
	-- TODO lua fn may be typefn or polyfn or openfn, deal by case TODO
	elseif TypedFunction.is(vType) then
		-- delete small struct
		const nDeleteList:List(clazz.TypedFunction) = {}
		for nTypeFn, _ in pairs(self._typeFnDict) do
			if vType:includeAtom(nTypeFn) then
				nDeleteList[#nDeleteList + 1] = nTypeFn
			else
				const nIntersect = vType:intersectAtom(nTypeFn)
				if nIntersect then
					error("unexpected intersect when union function")
				end
			end
		end
		for _, nTypeFn in pairs(nDeleteList) do
			self._typeFnDict[nTypeFn] = nil
		end
		self._typeFnDict[vType] = true
	elseif BaseFunction.is(vType) then
		self._notTypeFnDict[vType] = true
	else
		error("fn-type unexpected")
	end
end

function FuncUnion:assumeIntersectAtom(vAssumeSet, vType)
	if Truth.is(vType) then
		return self
	end
	if self:includeAtom(vType) then
		return vType
	end
	if TypedFunction.is(vType) then
		const nCollection = self._manager:TypeCollection()
		self:foreach(function(vSubType)
			if vType:includeAtom(vSubType) then
				nCollection:put(vSubType)
			end
		end)
		return nCollection:mergeToAtomUnion()
	end
	return false
end

function FuncUnion:assumeIncludeAtom(vAssumeSet, vType)
	if OpenFunction.is(vType) then
		if self._openFnDict[vType] then
			return vType
		else
			return false
		end
	elseif TypedFunction.is(vType) then
		for nTypeFn, _ in pairs(self._typeFnDict) do
			if nTypeFn:assumeIncludeAtom(vAssumeSet, vType) then
				return nTypeFn
			end
		end
	elseif BaseFunction.is(vType) then
		if self._notTypeFnDict[vType] then
			return vType
		else
			return false
		end
	end
	return false
end

function FuncUnion:fnPartType()
	return self
end

function FuncUnion:mayRecursive()
	return true
end

return FuncUnion
