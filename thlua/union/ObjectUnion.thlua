
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const UnionClass = require "thlua.union.UnionClass"
const LuaTable = require "thlua.object.LuaTable"
const MetaObject = require "thlua.object.MetaObject"
const Truth = require "thlua.type.Truth"

const ObjectUnion = UnionClass()

(@let.class = import("thlua.type.TypeClass").class)

function ObjectUnion.new(vManager:class.TypeManager)::RetClass(class.ObjectUnion, class.IUnionType)
	const self = setmetatable({::Self()
		_manager=vManager,
		_structDict={} @Dict(class.MetaObject, True),
		_luaTableDict={} @Dict(class.LuaTable, True),
		bits=TYPE_BITS.OBJECT,
		id=0@Integer,
	}, ObjectUnion)
	return self
end

function ObjectUnion:anyObject(vFunc)
	for k,v in pairs(self._structDict) do
		if vFunc(k) then
			return true
		end
	end
	return false
end

function ObjectUnion:foreach(vFunc)
	for nType, _ in pairs(self._structDict) do
		vFunc(nType)
	end
	for nType, _ in pairs(self._luaTableDict) do
		vFunc(nType)
	end
end

function ObjectUnion:putAwait(vType:class.IAtomType)
	if self:containAtom(vType) then
		return
	end
	if MetaObject.is(vType) then
		-- delete small lua table
		const nDeleteList1:List(class.LuaTable) = {}
		for nLuaTable, _ in pairs(self._luaTableDict) do
			if vType:containAtom(nLuaTable) then
				nDeleteList1[#nDeleteList1 + 1] = nLuaTable
			end
		end
		for _, nLuaTable in pairs(nDeleteList1) do
			self._luaTableDict[nLuaTable] = nil
		end
		-- delete small struct
		const nDeleteList2:List(class.MetaObject) = {}
		for nStruct, _ in pairs(self._structDict) do
			if vType:containAtom(nStruct) then
				nDeleteList2[#nDeleteList2 + 1] = nStruct
			end
		end
		for _, nStruct in pairs(nDeleteList2) do
			self._structDict[nStruct] = nil
		end
		self._structDict[vType] = true
	elseif LuaTable.is(vType) then
		for nStructType, _ in pairs(self._structDict) do
			if nStructType:containAtom(vType) then
				return
			end
		end
		self._luaTableDict[vType] = true
	else
		error("object-type unexpected")
	end
end

function ObjectUnion:intersectAtom(vType)
	if Truth.is(vType) then
		return self
	end
	if self:containAtom(vType) then
		return vType
	end
	if MetaObject.is(vType) then
		const nCollection = self._manager:TypeCollection()
		self:foreach(function(vSubType)
			if vType:containAtom(vSubType) then
				nCollection:put(vSubType)
			end
		end)
		return nCollection:mergeToAtomUnion()
	end
	return false
end

function ObjectUnion:assumeContainAtom(vAssumeSet, vType)
	if LuaTable.is(vType) then
		if self._luaTableDict[vType] then
			return vType
		end
	end
	for nStructType, _ in pairs(self._structDict) do
		if nStructType:assumeContainAtom(vAssumeSet, vType) then
			return nStructType
		end
	end
	return false
end

return ObjectUnion
