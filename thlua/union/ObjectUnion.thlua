
local TYPE_BITS = require "thlua.type.TYPE_BITS"
local UnionClass = require "thlua.union.UnionClass"
local LuaTable = require "thlua.object.LuaTable"
local MetaObject = require "thlua.object.MetaObject"
local Truth = require "thlua.type.Truth"

local ObjectUnion = UnionClass()

(@let.class = import("thlua.type.TypeClass").class)

function ObjectUnion.new(vManager:class.TypeManager)::RetClass(class.ObjectUnion, class.IUnionType)
	local self = setmetatable({::Self()
		_manager=vManager,
		_structDict={} @Dict(class.MetaObject, True),
		_luaTableDict={} @Dict(class.LuaTable, True),
		bits=TYPE_BITS.OBJECT,
		id=0,
	}, ObjectUnion)
	return self
end

function ObjectUnion:foreach(vFunc)
	for nType, _ in pairs(self._structDict) do
		vFunc(nType)
	end
	for nType, _ in pairs(self._luaTableDict) do
		vFunc(nType)
	end
end

function ObjectUnion:putAwait(vType:class.IAtomType)
	if self:containAtom(vType) then
		return
	end
	if MetaObject.is(vType) then
		-- delete small lua table
		local nDeleteList1:List(class.LuaTable) = {}
		for nLuaTable, _ in pairs(self._luaTableDict) do
			if vType:containAtom(nLuaTable) then
				nDeleteList1[#nDeleteList1 + 1] = nLuaTable
			end
		end
		for _, nLuaTable in pairs(nDeleteList1) do
			self._luaTableDict[nLuaTable] = nil
		end
		-- delete small struct
		local nDeleteList2:List(class.MetaObject) = {}
		for nStruct, _ in pairs(self._structDict) do
			if vType:containAtom(nStruct) then
				nDeleteList2[#nDeleteList2 + 1] = nStruct
			end
		end
		for _, nStruct in pairs(nDeleteList2) do
			self._structDict[nStruct] = nil
		end
		self._structDict[vType] = true
	elseif LuaTable.is(vType) then
		for nStructType, _ in pairs(self._structDict) do
			if nStructType:containAtom(vType) then
				return
			end
		end
		self._luaTableDict[vType] = true
	else
		error("object-type unexpected")
	end
end

function ObjectUnion:_intersectOneNotRefer(vType)
    if Truth.is(vType) then
        return self
    else
        return self:containAtom(vType)
    end
end

function ObjectUnion:atomContainAssume(vAssumeSet, vType)
	if LuaTable.is(vType) then
		if self._luaTableDict[vType] then
			return vType
		end
	end
	for nStructType, _ in pairs(self._structDict) do
		if nStructType:atomContainAssume(vAssumeSet, vType) then
			return nStructType
		end
	end
	return false
end

return ObjectUnion
