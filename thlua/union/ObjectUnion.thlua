
const TYPE_BITS = require "thlua.type.TYPE_BITS"
const UnionClass = require "thlua.union.UnionClass"
const BaseTable = require "thlua.object.BaseTable"
const TypedObject = require "thlua.object.TypedObject"
const Truth = require "thlua.type.Truth"

const ObjectUnion = UnionClass()

(@let.clazz = import("thlua.type.TypeClass").clazz)

function:class(clazz.ObjectUnion) ObjectUnion.new(vManager:clazz.TypeManager):impl(clazz.IUnionType)
	const self = setmetatable({.class
		_manager=vManager,
		_structDict={} @Dict(clazz.TypedObject, True),
		_luaTableDict={} @Dict(clazz.BaseTable, True),
		bits=TYPE_BITS.OBJECT,
		id=0@Integer,
	}, ObjectUnion)
	return self
end

function ObjectUnion:foreach(vFunc)
	for nType, _ in pairs(self._structDict) do
		vFunc(nType)
	end
	for nType, _ in pairs(self._luaTableDict) do
		vFunc(nType)
	end
end

function ObjectUnion:putAwait(vType:clazz.IAtomType)
	if self:includeAtom(vType) then
		return
	end
	if TypedObject.is(vType) then
		-- delete small lua table
		const nDeleteList1:List(clazz.BaseTable) = {}
		for nBaseTable, _ in pairs(self._luaTableDict) do
			if vType:includeAtom(nBaseTable) then
				nDeleteList1[#nDeleteList1 + 1] = nBaseTable
			end
		end
		for _, nBaseTable in pairs(nDeleteList1) do
			self._luaTableDict[nBaseTable] = nil
		end
		-- delete small struct
		const nDeleteList2:List(clazz.TypedObject) = {}
		for nStruct, _ in pairs(self._structDict) do
			if vType:includeAtom(nStruct) then
				nDeleteList2[#nDeleteList2 + 1] = nStruct
			else
				const nIntersect = vType:intersectAtom(nStruct)
				if nIntersect then
					error("unexpected intersect when union object")
				end
			end
		end
		for _, nStruct in pairs(nDeleteList2) do
			self._structDict[nStruct] = nil
		end
		self._structDict[vType] = true
	elseif BaseTable.is(vType) then
		for nStructType, _ in pairs(self._structDict) do
			if nStructType:includeAtom(vType) then
				return
			end
		end
		self._luaTableDict[vType] = true
	else
		error("object-type unexpected")
	end
end

function ObjectUnion:assumeIntersectAtom(vAssumeSet, vType)
	if Truth.is(vType) then
		return self
	end
	if not TypedObject.is(vType) and not BaseTable.is(vType) then
		return false
	end
	const nCollection = self._manager:TypeCollection()
	local nExplicitCount:OrFalse(Integer) = 0
	self:foreach(function(vSubType)
		if nExplicitCount then
			const nCurIntersect = vType:assumeIntersectAtom(vAssumeSet, vSubType)
			if nCurIntersect == true then
				nExplicitCount = false
			elseif nCurIntersect then
				nExplicitCount = nExplicitCount + 1
				nCollection:put(nCurIntersect)
			end
		end
	end)
	if not nExplicitCount then
		return true
	else
		return nExplicitCount > 0 and nCollection:mergeToAtomUnion()
	end
end

function ObjectUnion:objectPartType()
	return self
end

function ObjectUnion:mayRecursive()
	return true
end

function ObjectUnion:assumeIncludeAtom(vAssumeSet, vType)
	if BaseTable.is(vType) then
		for nTable, _ in pairs(self._luaTableDict) do
			if nTable:assumeIncludeAtom(vAssumeSet, vType) then
				return nTable
			end
		end
	end
	for nStructType, _ in pairs(self._structDict) do
		if nStructType:assumeIncludeAtom(vAssumeSet, vType) then
			return nStructType
		end
	end
	return false
end

return ObjectUnion
