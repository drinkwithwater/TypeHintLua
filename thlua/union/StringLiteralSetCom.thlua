
local StringLiteral = require "thlua.type.StringLiteral"
local String = require "thlua.type.String"
local Truth = require "thlua.type.Truth"
local TYPE_BITS = require "thlua.type.TYPE_BITS"

local SetComClass = require "thlua.union.SetComClass"
local StringLiteralSetCom = SetComClass()

(@let.class = import("thlua.type.TypeClass").class)

function StringLiteralSetCom.new(vTypeManager:class.TypeManager)::RetClass(class.StringLiteralSetCom, class.ISetCom)
	return setmetatable({::Self()
		_manager=vTypeManager,
		_literalSet={} @Dict(class.StringLiteral,True), -- literal to true
	}, StringLiteralSetCom)
end

function StringLiteralSetCom:_put(vType)
	if StringLiteral.is(vType) then
		self._literalSet[vType] = true
	else
		error("set put wrong")
	end
end

function StringLiteralSetCom:_intersectOneNotRefer(vType)
    if String.is(vType) or Truth.is(vType) then
        return self
    else
        return self:_containOneNotRefer(vType)
    end
end

function StringLiteralSetCom:_containOneNotRefer(vType)
	if StringLiteral.is(vType) then
		if self._literalSet[vType] then
			return vType
		else
			return false
		end
	else
		return false
	end
end

function StringLiteralSetCom:_mapContinue(vContinue, vFunc)::Ret(Boolean):nocheck()
	for nLiteralType, v in pairs(self._literalSet) do
		if not (vFunc(nLiteralType) or vContinue) then
			return false
		end
	end
	return true
end

return StringLiteralSetCom
